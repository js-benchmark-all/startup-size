const e=Object.freeze({status:`aborted`});function t(e,t,n){function r(n,r){var i;Object.defineProperty(n,`_zod`,{value:n._zod??{},enumerable:false});(i=n._zod).traits??(i.traits=new Set);n._zod.traits.add(e);t(n,r);for(const e in o.prototype)if(!(e in n))Object.defineProperty(n,e,{value:o.prototype[e].bind(n)});n._zod.constr=o;n._zod.def=r}const i=n?.Parent??Object;class a extends i{}Object.defineProperty(a,`name`,{value:e});function o(e){var t;const i=n?.Parent?new a:this;r(i,e);(t=i._zod).deferred??(t.deferred=[]);for(const e of i._zod.deferred)e();return i}Object.defineProperty(o,`init`,{value:r});Object.defineProperty(o,Symbol.hasInstance,{value:t=>{if(n?.Parent&&t instanceof n.Parent)return true;return t?._zod?.traits?.has(e)}});Object.defineProperty(o,`name`,{value:e});return o}const n=Symbol(`zod_brand`);var r=class extends Error{constructor(){super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`)}};const i={};function a(e){if(e)Object.assign(i,e);return i}function o(e,t){if(typeof t===`bigint`)return t.toString();return t}function s(e){const t=false;return{get value(){{const t=e();Object.defineProperty(this,`value`,{value:t});return t}}}}function c(e,t,n){const r=false;Object.defineProperty(e,t,{get(){{const r=n();e[t]=r;return r}},set(n){Object.defineProperty(e,t,{value:n})},configurable:true})}function l(e,t,n){Object.defineProperty(e,t,{value:n,writable:true,enumerable:true,configurable:true})}function u(e){return JSON.stringify(e)}const d=`captureStackTrace`in Error?Error.captureStackTrace:(...e)=>{};function f(e){return typeof e===`object`&&e!==null&&!Array.isArray(e)}const p=s(()=>{if(typeof navigator!==`undefined`&&navigator?.userAgent?.includes(`Cloudflare`))return false;try{const e=Function;new e(``);return true}catch(e){return false}});function m(e,t,n){const r=new e._zod.constr(t??e._zod.def);if(!t||n?.parent)r._zod.parent=e;return r}function h(e){const t=e;if(!t)return{};if(typeof t===`string`)return{error:()=>t};if(t?.message!==void 0){if(t?.error!==void 0)throw new Error("Cannot specify both `message` and `error` params");t.error=t.message}delete t.message;if(typeof t.error===`string`)return{...t,error:()=>t.error};return t}function g(e){return Object.keys(e).filter(t=>{return e[t]._zod.optin===`optional`&&e[t]._zod.optout===`optional`})}const _={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-34028234663852886e22,34028234663852886e22],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]};function v(e,t=0){for(let n=t;n<e.issues.length;n++)if(e.issues[n]?.continue!==true)return true;return false}function y(e,t){return t.map(t=>{var n;(n=t).path??(n.path=[]);t.path.unshift(e);return t})}function b(e){return typeof e===`string`?e:e?.message}function x(e,t,n){const r={...e,path:e.path??[]};if(!e.message){const i=b(e.inst?._zod.def?.error?.(e))??b(t?.error?.(e))??b(n.customError?.(e))??b(n.localeError?.(e))??`Invalid input`;r.message=i}delete r.inst;delete r.continue;if(!t?.reportInput)delete r.input;return r}const S=(e,t)=>{e.name=`$ZodError`;Object.defineProperty(e,`_zod`,{value:e._zod,enumerable:false});Object.defineProperty(e,`issues`,{value:t,enumerable:false});e.message=JSON.stringify(t,o,2);Object.defineProperty(e,`toString`,{value:()=>e.message,enumerable:false})};const C=t(`$ZodError`,S);const w=t(`$ZodError`,S,{Parent:Error});const ee=e=>(t,n,i,o)=>{const s=i?Object.assign(i,{async:false}):{async:false};const c=t._zod.run({value:n,issues:[]},s);if(c instanceof Promise)throw new r;if(c.issues.length){const t=new(o?.Err??e)(c.issues.map(e=>x(e,s,a())));d(t,o?.callee);throw t}return c.value};const T=ee(w);const E=e=>async(t,n,r,i)=>{const o=r?Object.assign(r,{async:true}):{async:true};let s=t._zod.run({value:n,issues:[]},o);if(s instanceof Promise)s=await s;if(s.issues.length){const t=new(i?.Err??e)(s.issues.map(e=>x(e,o,a())));d(t,i?.callee);throw t}return s.value};const D=E(w);const O=e=>(t,n,i)=>{const o=i?{...i,async:false}:{async:false};const s=t._zod.run({value:n,issues:[]},o);if(s instanceof Promise)throw new r;return s.issues.length?{success:false,error:new(e??C)(s.issues.map(e=>x(e,o,a())))}:{success:true,data:s.value}};const k=O(w);const A=e=>async(t,n,r)=>{const i=r?Object.assign(r,{async:true}):{async:true};let o=t._zod.run({value:n,issues:[]},i);if(o instanceof Promise)o=await o;return o.issues.length?{success:false,error:new e(o.issues.map(e=>x(e,i,a())))}:{success:true,data:o.value}};const j=A(w);const te=`(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;const ne=new RegExp(`^${te}$`);const M=e=>{const t=e?`[\\s\\S]{${e?.minimum??0},${e?.maximum??``}}`:`[\\s\\S]*`;return new RegExp(`^${t}$`)};const N=/^-?\d+(?:\.\d+)?/i;const P=/true|false/i;var F=class{constructor(e=[]){this.content=[];this.indent=0;if(this)this.args=e}indented(e){this.indent+=1;e(this);this.indent-=1}write(e){if(typeof e===`function`){e(this,{execution:`sync`});e(this,{execution:`async`});return}const t=e;const n=t.split(`
`).filter(e=>e);const r=Math.min(...n.map(e=>e.length-e.trimStart().length));const i=n.map(e=>e.slice(r)).map(e=>` `.repeat(this.indent*2)+e);for(const e of i)this.content.push(e)}compile(){const e=Function;const t=this?.args;const n=this?.content??[``];const r=[...n.map(e=>`  ${e}`)];return new e(...t,r.join(`
`))}};const I={major:4,minor:0,patch:10};const L=t(`$ZodType`,(e,t)=>{var n;e??(e={});e._zod.def=t;e._zod.bag=e._zod.bag||{};e._zod.version=I;const i=[...e._zod.def.checks??[]];if(e._zod.traits.has(`$ZodCheck`))i.unshift(e);for(const t of i)for(const n of t._zod.onattach)n(e);if(i.length===0){(n=e._zod).deferred??(n.deferred=[]);e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse})}else{const t=(e,t,n)=>{let i=v(e);let a;for(const o of t){if(o._zod.def.when){const t=o._zod.def.when(e);if(!t)continue}else if(i)continue;const t=e.issues.length;const s=o._zod.check(e);if(s instanceof Promise&&n?.async===false)throw new r;if(a||s instanceof Promise)a=(a??Promise.resolve()).then(async()=>{await s;const n=e.issues.length;if(n===t)return;if(!i)i=v(e,t)});else{const n=e.issues.length;if(n===t)continue;if(!i)i=v(e,t)}}if(a)return a.then(()=>{return e});return e};e._zod.run=(n,a)=>{const o=e._zod.parse(n,a);if(o instanceof Promise){if(a.async===false)throw new r;return o.then(e=>t(e,i,a))}return t(o,i,a)}}e[`~standard`]={validate:t=>{try{const n=k(e,t);return n.success?{value:n.data}:{issues:n.error?.issues}}catch(n){return j(e,t).then(e=>e.success?{value:e.data}:{issues:e.error?.issues})}},vendor:`zod`,version:1}});const R=t(`$ZodString`,(e,t)=>{L.init(e,t);e._zod.pattern=[...e?._zod.bag?.patterns??[]].pop()??M(e._zod.bag);e._zod.parse=(n,r)=>{if(t.coerce)try{n.value=String(n.value)}catch(e){}if(typeof n.value===`string`)return n;n.issues.push({expected:`string`,code:`invalid_type`,input:n.value,inst:e});return n}});const z=t(`$ZodNumber`,(e,t)=>{L.init(e,t);e._zod.pattern=e._zod.bag.pattern??N;e._zod.parse=(n,r)=>{if(t.coerce)try{n.value=Number(n.value)}catch(e){}const i=n.value;if(typeof i===`number`&&!Number.isNaN(i)&&Number.isFinite(i))return n;const a=typeof i===`number`?Number.isNaN(i)?`NaN`:!Number.isFinite(i)?`Infinity`:void 0:void 0;n.issues.push({expected:`number`,code:`invalid_type`,input:i,inst:e,...a?{received:a}:{}});return n}});const B=t(`$ZodBoolean`,(e,t)=>{L.init(e,t);e._zod.pattern=P;e._zod.parse=(n,r)=>{if(t.coerce)try{n.value=Boolean(n.value)}catch(e){}const i=n.value;if(typeof i===`boolean`)return n;n.issues.push({expected:`boolean`,code:`invalid_type`,input:i,inst:e});return n}});function V(e,t,n){if(e.issues.length)t.issues.push(...y(n,e.issues));t.value[n]=e.value}const H=t(`$ZodArray`,(e,t)=>{L.init(e,t);e._zod.parse=(n,r)=>{const i=n.value;if(!Array.isArray(i)){n.issues.push({expected:`array`,code:`invalid_type`,input:i,inst:e});return n}n.value=Array(i.length);const a=[];for(let e=0;e<i.length;e++){const o=i[e];const s=t.element._zod.run({value:o,issues:[]},r);if(s instanceof Promise)a.push(s.then(t=>V(t,n,e)));else V(s,n,e)}if(a.length)return Promise.all(a).then(()=>n);return n}});function U(e,t,n,r){if(e.issues.length)t.issues.push(...y(n,e.issues));if(e.value===void 0){if(n in r)t.value[n]=void 0}else t.value[n]=e.value}const W=t(`$ZodObject`,(e,t)=>{L.init(e,t);const n=s(()=>{const e=Object.keys(t.shape);for(const n of e)if(!(t.shape[n]instanceof L))throw new Error(`Invalid element at key "${n}": expected a Zod schema`);const n=g(t.shape);return{shape:t.shape,keys:e,keySet:new Set(e),numKeys:e.length,optionalKeys:new Set(n)}});c(e._zod,`propValues`,()=>{const e=t.shape;const n={};for(const t in e){const r=e[t]._zod;if(r.values){n[t]??(n[t]=new Set);for(const e of r.values)n[t].add(e)}}return n});const r=e=>{const t=new F([`shape`,`payload`,`ctx`]);const r=n.value;const i=e=>{const t=u(e);return`shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)`};t.write(`const input = payload.value;`);const a=Object.create(null);let o=0;for(const e of r.keys)a[e]=`key_${o++}`;t.write(`const newResult = {}`);for(const e of r.keys){const n=a[e];const r=u(e);t.write(`const ${n} = ${i(e)};`);t.write(`
        if (${n}.issues.length) {
          payload.issues = payload.issues.concat(${n}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${r}, ...iss.path] : [${r}]
          })));
        }
        
        if (${n}.value === undefined) {
          if (${r} in input) {
            newResult[${r}] = undefined;
          }
        } else {
          newResult[${r}] = ${n}.value;
        }
      `)}t.write(`payload.value = newResult;`);t.write(`return payload;`);const s=t.compile();return(t,n)=>s(e,t,n)};let a;const o=f;const l=!i.jitless;const d=p;const m=l&&d.value;const h=t.catchall;let _;e._zod.parse=(i,s)=>{_??(_=n.value);const c=i.value;if(!o(c)){i.issues.push({expected:`object`,code:`invalid_type`,input:c,inst:e});return i}const u=[];if(l&&m&&s?.async===false&&s.jitless!==true){if(!a)a=r(t.shape);i=a(i,s)}else{i.value={};const e=_.shape;for(const t of _.keys){const n=e[t];const r=n._zod.run({value:c[t],issues:[]},s);if(r instanceof Promise)u.push(r.then(e=>U(e,i,t,c)));else U(r,i,t,c)}}if(!h)return u.length?Promise.all(u).then(()=>i):i;const d=[];const f=_.keySet;const p=h._zod;const g=p.def.type;for(const e of Object.keys(c)){if(f.has(e))continue;if(g===`never`){d.push(e);continue}const t=p.run({value:c[e],issues:[]},s);if(t instanceof Promise)u.push(t.then(t=>U(t,i,e,c)));else U(t,i,e,c)}if(d.length)i.issues.push({code:`unrecognized_keys`,keys:d,input:c,inst:e});if(!u.length)return i;return Promise.all(u).then(()=>{return i})}});function G(e,t){return new e({type:`string`,...h(t)})}function K(e,t){return new e({type:`number`,checks:[],...h(t)})}function q(e,t){return new e({type:`boolean`,...h(t)})}const J=t(`ZodMiniType`,(e,t)=>{if(!e._zod)throw new Error(`Uninitialized schema in ZodMiniType.`);L.init(e,t);e.def=t;e.parse=(t,n)=>T(e,t,n,{callee:e.parse});e.safeParse=(t,n)=>k(e,t,n);e.parseAsync=async(t,n)=>D(e,t,n,{callee:e.parseAsync});e.safeParseAsync=async(t,n)=>j(e,t,n);e.check=(...n)=>{return e.clone({...t,checks:[...t.checks??[],...n.map(e=>typeof e===`function`?{_zod:{check:e,def:{check:`custom`},onattach:[]}}:e)]})};e.clone=(t,n)=>m(e,t,n);e.brand=()=>e;e.register=((t,n)=>{t.add(e,n);return e})});const Y=t(`ZodMiniString`,(e,t)=>{R.init(e,t);J.init(e,t)});function X(e){return G(Y,e)}const re=t(`ZodMiniNumber`,(e,t)=>{z.init(e,t);J.init(e,t)});function Z(e){return K(re,e)}const ie=t(`ZodMiniBoolean`,(e,t)=>{B.init(e,t);J.init(e,t)});function Q(e){return q(ie,e)}const ae=t(`ZodMiniArray`,(e,t)=>{H.init(e,t);J.init(e,t)});function oe(e,t){return new ae({type:`array`,element:e,...h(t)})}const se=t(`ZodMiniObject`,(e,t)=>{W.init(e,t);J.init(e,t);c(e,`shape`,()=>t.shape)});function $(e,t){const n={type:`object`,get shape(){l(this,`shape`,{...e});return this.shape},...h(t)};return new se(n)}var ce=$({number:Z(),negNumber:Z(),maxNumber:Z(),string:X(),longString:X(),boolean:Q(),deeplyNested:$({foo:X(),num:Z(),bool:Q()}),items:oe(Z())});export{ce as default};