function e(e){return{ok:false,code:`invalid_type`,expected:e}}const t=e([]);const n=e([`string`]);const r=e([`number`]);const i=e([`bigint`]);const a=e([`boolean`]);const o=e([`undefined`]);const s=e([`null`]);const c=e([`object`]);const l=e([`array`]);const u={ok:false,code:`missing_value`};function d(e,t){return e?{ok:false,code:`join`,left:e,right:t}:t}function f(e,t){return{ok:false,code:`prepend`,key:e,tree:t}}function p(e,t){var n;const r=e.code;switch(r){case`invalid_type`:return{code:r,path:t,expected:e.expected};case`invalid_literal`:return{code:r,path:t,expected:e.expected};case`missing_value`:return{code:r,path:t};case`invalid_length`:return{code:r,path:t,minLength:e.minLength,maxLength:e.maxLength};case`unrecognized_keys`:return{code:r,path:t,keys:e.keys};case`invalid_union`:return{code:r,path:t,tree:e.tree,issues:m(e.tree)};case`custom_error`:if(typeof e.error===`object`&&e.error.path!==void 0)t.push(...e.error.path);return{code:r,path:t,message:typeof e.error===`string`?e.error:(n=e.error)===null||n===void 0?void 0:n.message,error:e.error}}}function m(e,t=[],n=[]){for(;;)if(e.code===`join`){m(e.left,t.slice(),n);e=e.right}else if(e.code===`prepend`){t.push(e.key);e=e.tree}else{n.push(p(e,t));return n}}function h(e,t){if(e.length===0)return`nothing`;else if(e.length===1)return e[0];else return`${e.slice(0,-1).join(`, `)} ${t} ${e[e.length-1]}`}function g(e){return typeof e===`bigint`?`${e}n`:JSON.stringify(e)}function _(e){let t=0;for(;;)if(e.code===`join`){t+=_(e.left);e=e.right}else if(e.code===`prepend`)e=e.tree;else return t+1}function v(e){let t=``;let n=0;for(;;)if(e.code===`join`){n+=_(e.right);e=e.left}else if(e.code===`prepend`){t+=`.${e.key}`;e=e.tree}else break;let r=`validation failed`;if(e.code===`invalid_type`)r=`expected ${h(e.expected,`or`)}`;else if(e.code===`invalid_literal`)r=`expected ${h(e.expected.map(g),`or`)}`;else if(e.code===`missing_value`)r=`missing value`;else if(e.code===`unrecognized_keys`){const t=e.keys;r=`unrecognized ${t.length===1?`key`:`keys`} ${h(t.map(g),`and`)}`}else if(e.code===`invalid_length`){const t=e.minLength;const n=e.maxLength;r=`expected an array with `;if(t>0)if(n===t)r+=`${t}`;else if(n!==void 0)r+=`between ${t} and ${n}`;else r+=`at least ${t}`;else r+=`at most ${n!==null&&n!==void 0?n:`âˆž`}`;r+=` item(s)`}else if(e.code===`custom_error`){const n=e.error;if(typeof n===`string`)r=n;else if(n!==void 0){if(n.message!==void 0)r=n.message;if(n.path!==void 0)t+=`.`+n.path.join(`.`)}}let i=`${e.code} at .${t.slice(1)} (${r})`;if(n===1)i+=` (+ 1 other issue)`;else if(n>1)i+=` (+ ${n} other issues)`;return i}function y(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:r,writable:false});return n}var b=class extends Error{constructor(e){super(v(e));Object.setPrototypeOf(this,new.target.prototype);this.name=new.target.name;this._issueTree=e}get issues(){return y(this,`issues`,m(this._issueTree),true)}};var ee=class{constructor(e){this.ok=false;this._issueTree=e}get issues(){return y(this,`issues`,m(this._issueTree),true)}get message(){return y(this,`message`,v(this._issueTree),true)}throw(){throw new b(this._issueTree)}};function x(e){return{ok:true,value:e}}function S(e){return typeof e===`object`&&e!==null&&!Array.isArray(e)}const C=1;const w=2;const T=4;const E=0;const te=1;const D=2;const O=3;const ne=4;const k=5;const re=6;const A=7;const ie=8;const j=9;const M=10;const N=11;const P=12;const F=13;const I=14;const ae=15;const L=(e,t)=>{return{tag:e,match:t}};function R(e,c,l){switch(e.tag){case E:return void 0;case te:return t;case D:return typeof c===`string`?void 0:n;case O:return typeof c===`number`?void 0:r;case ne:return typeof c===`bigint`?void 0:i;case k:return typeof c===`boolean`?void 0:a;case re:return c===null?void 0:s;case A:return c===void 0?void 0:o;case ie:return e.match(c,l);case j:return e.match(c,l);case M:return e.match(c,l);case N:return e.match(c,l);case P:return e.match(c,l);case F:return e.match(c,l);case I:return e.match(c,l);default:return e.match(c,l)}}const z=Symbol.for(`@valita/internal`);var B=class{default(e){const t=x(e);return new Y(this.optional(),e=>{return e===void 0?t:void 0})}assert(e,t){const n={ok:false,code:`custom_error`,error:t};return new Y(this,(t,r)=>e(t,J(r))?void 0:n)}map(e){return new Y(this,(t,n)=>({ok:true,value:e(t,J(n))}))}chain(e){if(typeof e===`function`)return new Y(this,(t,n)=>{const r=e(t,J(n));return r.ok?r:r._issueTree});return new Y(this,(t,n)=>R(e[z],t,n))}};var V=class extends B{optional(e){const t=new se(this);if(!e)return t;return new Y(t,t=>{return t===void 0?{ok:true,value:e()}:void 0})}nullable(e){const t=new oe([xe(),this]);if(!e)return t;return new Y(t,t=>{return t===null?{ok:true,value:e()}:void 0})}_toTerminals(e){e(this)}try(e,t){const n=R(this[z],e,t===void 0?C:t.mode===`strip`?w:t.mode===`passthrough`?0:C);return n===void 0||n.ok?{ok:true,value:n===void 0?e:n.value}:new ee(n)}parse(e,t){const n=R(this[z],e,t===void 0?C:t.mode===`strip`?w:t.mode===`passthrough`?0:C);if(n===void 0||n.ok)return n===void 0?e:n.value;throw new b(n)}};var oe=class extends V{constructor(e){super();this.name=`union`;this.options=e}get[z](){const e=this.options.map(e=>e[z]);return y(this,z,L(F,(n,r)=>{let i=t;for(const t of e){const e=R(t,n,r);if(e===void 0||e.ok)return e;i=e}return i}),false)}_toTerminals(e){for(const t of this.options)t._toTerminals(e)}};var se=class extends B{constructor(e){super();this.name=`optional`;this.type=e}optional(e){if(!e)return this;return new Y(this,t=>{return t===void 0?{ok:true,value:e()}:void 0})}get[z](){const e=this.type[z];return y(this,z,L(j,(t,n)=>t===void 0||n&T?void 0:R(e,t,n)),false)}_toTerminals(e){e(this);e(Se());this.type._toTerminals(e)}};function H(e,t){if(typeof e!==`number`){const n=t>>5;for(let t=e.length;t<=n;t++)e.push(0);e[n]|=1<<t%32;return e}else if(t<32)return e|1<<t;else return H([e,0],t)}function U(e,t){if(typeof e===`number`)return t<32?e>>>t&1:0;else return e[t>>5]>>>t%32&1}var ce=class e extends V{constructor(e,t,n){super();this.name=`object`;this.shape=e;this._restType=t;this._checks=n}get[z](){const e=le(this.shape,this._restType,this._checks);return y(this,z,L(M,(t,n)=>S(t)?e(t,n):c),false)}check(t,n){var r;const i={ok:false,code:`custom_error`,error:n};return new e(this.shape,this._restType,[...(r=this._checks)!==null&&r!==void 0?r:[],{func:t,issue:i}])}rest(t){return new e(this.shape,t)}extend(t){return new e(Object.assign(Object.assign({},this.shape),t),this._restType)}pick(...t){const n={};for(const e of t)W(n,e,this.shape[e]);return new e(n,void 0)}omit(...t){const n=Object.assign({},this.shape);for(const e of t)delete n[e];return new e(n,this._restType)}partial(){var t;const n={};for(const e of Object.keys(this.shape))W(n,e,this.shape[e].optional());const r=(t=this._restType)===null||t===void 0?void 0:t.optional();return new e(n,r)}};function W(e,t,n){if(t===`__proto__`)Object.defineProperty(e,t,{value:n,writable:true,enumerable:true,configurable:true});else e[t]=n}function le(e,t,n){const r=Object.keys(e).map((t,n)=>{const r=e[t];let i=false;r._toTerminals(e=>{i||(i=e.name===`optional`)});return{key:t,index:n,matcher:r[z],optional:i,missing:f(t,u)}});const i=Object.create(null);for(const e of r)i[e.key]=e;const a=t===null||t===void 0?void 0:t[z];const o=r.length===0&&(t===null||t===void 0?void 0:t.name)===`unknown`&&n===void 0;return(e,t)=>{if(o)return void 0;let s=void 0;let c=void 0;let l=void 0;let u=0;let p=0;if(t&(C|w)||a!==void 0)for(const n in e){const o=e[n];const m=i[n];if(m===void 0&&a===void 0){if(t&C)if(l===void 0){l=[n];c=d(c,{ok:false,code:`unrecognized_keys`,keys:l})}else l.push(n);else if(t&w&&c===void 0&&s===void 0){s={};for(let t=0;t<r.length;t++)if(U(u,t)){const n=r[t].key;W(s,n,e[n])}}continue}const h=m===void 0?R(a,o,t):R(m.matcher,o,t);if(h===void 0){if(s!==void 0&&c===void 0)W(s,n,o)}else if(!h.ok)c=d(c,f(n,h));else if(c===void 0){if(s===void 0){s={};if(a===void 0){for(let t=0;t<r.length;t++)if(U(u,t)){const n=r[t].key;W(s,n,e[n])}}else for(const t in e)W(s,t,e[t])}W(s,n,h.value)}if(m!==void 0){p++;u=H(u,m.index)}}if(p<r.length)for(let n=0;n<r.length;n++){if(U(u,n))continue;const i=r[n];const o=e[i.key];let l=0;if(o===void 0&&!(i.key in e)){if(!i.optional){c=d(c,i.missing);continue}l=T}const p=R(i.matcher,o,t|l);if(p===void 0){if(s!==void 0&&c===void 0&&!l)W(s,i.key,o)}else if(!p.ok)c=d(c,f(i.key,p));else if(c===void 0){if(s===void 0){s={};if(a===void 0){for(let t=0;t<r.length;t++)if(t<n||U(u,t)){const n=r[t].key;W(s,n,e[n])}}else{for(const t in e)W(s,t,e[t]);for(let t=0;t<n;t++)if(!U(u,t)){const n=r[t].key;W(s,n,e[n])}}}W(s,i.key,p.value)}}if(c!==void 0)return c;if(n!==void 0){for(const{func:t,issue:r}of n)if(!t(s!==null&&s!==void 0?s:e))return r}return s&&{ok:true,value:s}}}var ue=class e extends V{constructor(e,t,n){super();this.name=`array`;this._prefix=e;this._rest=t;this._suffix=n}get[z](){var e,t;const n=this._prefix.map(e=>e[z]);const r=this._suffix.map(e=>e[z]);const i=(t=(e=this._rest)===null||e===void 0?void 0:e[z])!==null&&t!==void 0?t:L(1,()=>u);const a=n.length+r.length;const o=this._rest?1/0:a;const s={ok:false,code:`invalid_length`,minLength:a,maxLength:o===1/0?void 0:o};return y(this,z,L(N,(e,t)=>{if(!Array.isArray(e))return l;const c=e.length;if(c<a||c>o)return s;const u=n.length;const p=e.length-r.length;let m=void 0;let h=e;for(let a=0;a<e.length;a++){const o=a<u?n[a]:a>=p?r[a-p]:i;const s=R(o,e[a],t);if(s!==void 0)if(s.ok){if(h===e)h=e.slice();h[a]=s.value}else m=d(m,f(a,s))}if(m)return m;else if(e===h)return void 0;else return{ok:true,value:h}}),false)}concat(t){if(this._rest){if(t._rest)throw new TypeError(`can not concatenate two variadic types`);return new e(this._prefix,this._rest,[...this._suffix,...t._prefix,...t._suffix])}else if(t._rest)return new e([...this._prefix,...this._suffix,...t._prefix],t._rest,t._suffix);else return new e([...this._prefix,...this._suffix,...t._prefix,...t._suffix],t._rest,t._suffix)}};function G(e){const t=typeof e;if(t!==`object`)return t;else if(e===null)return`null`;else if(Array.isArray(e))return`array`;else return t}function K(e){return[...new Set(e)]}function q(e){var t,n,r;const i=new Map;const a=new Map;const o=new Map;const s=[];const c=[];const l=[];for(const{root:u,terminal:d}of e){i.set(u,(t=i.get(u))!==null&&t!==void 0?t:i.size);if(d.name===`never`){}else if(d.name===`optional`)c.push(u);else if(d.name===`unknown`)s.push(u);else if(d.name===`literal`){const e=(n=a.get(d.value))!==null&&n!==void 0?n:[];e.push(u);a.set(d.value,e);l.push(G(d.value))}else{const e=(r=o.get(d.name))!==null&&r!==void 0?r:[];e.push(u);o.set(d.name,e);l.push(d.name)}}const u=(e,t)=>{var n,r;return((n=i.get(e))!==null&&n!==void 0?n:0)-((r=i.get(t))!==null&&r!==void 0?r:0)};for(const[e,t]of a){const n=o.get(G(e));if(n){n.push(...t);a.delete(e)}else a.set(e,K(t.concat(s)).sort(u))}for(const[e,t]of o)o.set(e,K(t.concat(s)).sort(u));return{types:o,literals:a,unknowns:K(s).sort(u),optionals:K(c).sort(u),expectedTypes:K(l)}}function de(e,t){var n;const r=[];for(const{root:n,terminal:i}of e)i.shape[t]._toTerminals(e=>r.push({root:n,terminal:e}));const{types:i,literals:a,optionals:o,unknowns:s,expectedTypes:c}=q(r);if(s.length>0||o.length>1)return void 0;for(const e of a.values())if(e.length>1)return void 0;for(const e of i.values())if(e.length>1)return void 0;const l=f(t,u);const d=f(t,i.size===0?{ok:false,code:`invalid_literal`,expected:[...a.keys()]}:{ok:false,code:`invalid_type`,expected:c});const p=a.size>0?new Map:void 0;if(p)for(const[e,t]of a)p.set(e,t[0][z]);const m=i.size>0?{}:void 0;if(m)for(const[e,t]of i)m[e]=t[0][z];const h=(n=o[0])===null||n===void 0?void 0:n[z];return(e,n)=>{var r;const i=e[t];if(i===void 0&&!(t in e))return h===void 0?l:R(h,e,n);const a=(r=m===null||m===void 0?void 0:m[G(i)])!==null&&r!==void 0?r:p===null||p===void 0?void 0:p.get(i);return a?R(a,e,n):d}}function fe(e){var t;const n=[];const r=new Map;for(const{root:i,terminal:a}of e){if(a.name===`unknown`)return void 0;if(a.name===`object`){for(const e in a.shape)r.set(e,((t=r.get(e))!==null&&t!==void 0?t:0)+1);n.push({root:i,terminal:a})}}if(n.length<2)return void 0;for(const[e,t]of r)if(t===n.length){const t=de(n,e);if(t)return t}return void 0}function pe(e){const{expectedTypes:t,literals:n,types:r,unknowns:i,optionals:a}=q(e);const o=r.size===0&&i.length===0?{ok:false,code:`invalid_literal`,expected:[...n.keys()]}:{ok:false,code:`invalid_type`,expected:t};const s=n.size>0?new Map:void 0;if(s)for(const[e,t]of n)s.set(e,t.map(e=>e[z]));const c=r.size>0?{}:void 0;if(c)for(const[e,t]of r)c[e]=t.map(e=>e[z]);const l=a.map(e=>e[z]);const u=i.map(e=>e[z]);return(e,t)=>{var n,r;const i=t&T?l:(r=(n=c===null||c===void 0?void 0:c[G(e)])!==null&&n!==void 0?n:s===null||s===void 0?void 0:s.get(e))!==null&&r!==void 0?r:u;let a=0;let f=o;for(let n=0;n<i.length;n++){const r=R(i[n],e,t);if(r===void 0||r.ok)return r;f=a>0?d(f,r):r;a++}if(a>1)return{ok:false,code:`invalid_union`,tree:f};return f}}var me=class extends V{constructor(e){super();this.name=`union`;this.options=e}_toTerminals(e){for(const t of this.options)t._toTerminals(e)}get[z](){const e=[];for(const t of this.options)t._toTerminals(n=>{e.push({root:t,terminal:n})});const t=pe(e);const n=fe(e);return y(this,z,L(P,(e,r)=>n!==void 0&&S(e)?n(e,r):t(e,r)),false)}};const he=Object.freeze({mode:`strict`});const ge=Object.freeze({mode:`strip`});const _e=Object.freeze({mode:`passthrough`});function J(e){return e&C?he:e&w?ge:_e}var Y=class e extends V{constructor(e,t){super();this.name=`transform`;this._transformed=e;this._transform=t}get[z](){const t=[];let n=this;while(n instanceof e){t.push(n._transform);n=n._transformed}t.reverse();const r=n[z];const i=x(void 0);return y(this,z,L(I,(e,n)=>{let a=R(r,e,n);if(a!==void 0&&!a.ok)return a;let o;if(a!==void 0)o=a.value;else if(n&T){o=void 0;a=i}else o=e;for(let e=0;e<t.length;e++){const r=t[e](o,n);if(r!==void 0){if(!r.ok)return r;o=r.value;a=r}}return a}),false)}_toTerminals(e){this._transformed._toTerminals(e)}};var ve=class extends V{constructor(e){super();this.name=`lazy`;this._recursing=false;this._definer=e}get type(){return y(this,`type`,this._definer(),true)}get[z](){const e=L(ae,(t,n)=>{const r=this.type[z];e.tag=r.tag;e.match=r.match;y(this,z,r,false);return R(r,t,n)});return e}_toTerminals(e){if(!this._recursing){this._recursing=true;try{this.type._toTerminals(e)}finally{this._recursing=false}}}};function X(e,t,n){const r=L(t,n);class i extends V{constructor(){super();this.name=e;this[z]=r}}const a=new i;return()=>a}const ye=X(`unknown`,E,()=>void 0);const Z=X(`string`,D,e=>typeof e===`string`?void 0:n);const Q=X(`number`,O,e=>typeof e===`number`?void 0:r);const be=X(`boolean`,k,e=>typeof e===`boolean`?void 0:a);const xe=X(`null`,re,e=>e===null?void 0:s);const Se=X(`undefined`,A,e=>e===void 0?void 0:o);const $=e=>{return new ce(e,void 0)};const Ce=e=>{return new ue([],e!==null&&e!==void 0?e:ye(),[])};$({number:Q(),negNumber:Q(),maxNumber:Q(),string:Z(),longString:Z(),boolean:be(),deeplyNested:$({foo:Z(),num:Q(),bool:be()}),items:Ce(Q())});