const e=e=>typeof e===`function`;const t=function(e,t){if(typeof e===`function`)return function(){if(e(arguments))return t.apply(this,arguments);return e=>t(e,...arguments)};switch(e){case 0:case 1:throw new RangeError(`Invalid arity ${e}`);case 2:return function(e,n){if(arguments.length>=2)return t(e,n);return function(n){return t(n,e)}};case 3:return function(e,n,r){if(arguments.length>=3)return t(e,n,r);return function(r){return t(r,e,n)}};case 4:return function(e,n,r,i){if(arguments.length>=4)return t(e,n,r,i);return function(i){return t(i,e,n,r)}};case 5:return function(e,n,r,i,a){if(arguments.length>=5)return t(e,n,r,i,a);return function(a){return t(a,e,n,r,i)}};default:return function(){if(arguments.length>=e)return t.apply(this,arguments);const n=arguments;return function(e){return t(e,...n)}}}};const n=e=>e;const r=e=>()=>e;const i=r(true);const a=r(false);const o=r(void 0);const s=o;function c(e,t,n,r,i,a,o,s,c){switch(arguments.length){case 1:return e;case 2:return t(e);case 3:return n(t(e));case 4:return r(n(t(e)));case 5:return i(r(n(t(e))));case 6:return a(i(r(n(t(e)))));case 7:return o(a(i(r(n(t(e))))));case 8:return s(o(a(i(r(n(t(e)))))));case 9:return c(s(o(a(i(r(n(t(e))))))));default:{let e=arguments[0];for(let t=1;t<arguments.length;t++)e=arguments[t](e);return e}}}const l=e=>(t,n)=>t===n||e(t,n);const u=(e,t)=>e===t;const d=()=>u;const f=d();const p=d();const m=t(2,(e,t)=>l((n,r)=>e(t(n),t(r))));const h=e=>{return l((t,n)=>{const r=Math.min(t.length,n.length);let i=0;for(const a of e){if(i>=r)break;if(!a(t[i],n[i]))return false;i++}return true})};const g=(...e)=>h(e);const ee=e=>l((t,n)=>{if(t.length!==n.length)return false;for(let r=0;r<t.length;r++){const i=e(t[r],n[r]);if(!i)return false}return true});const te=e=>{const t=Object.keys(e);return l((n,r)=>{for(const i of t)if(!e[i](n[i],r[i]))return false;return true})};const ne=e=>t(3,(t,n,r)=>e(t,e=>({...e,[n]:r(e)})));const re=e=>t(2,(t,n)=>e(t,e=>({[n]:e})));const ie=(e,n)=>t(3,(t,r,i)=>n(t,t=>e(i(t),e=>({...t,[r]:e}))));const ae=`effect/GlobalValue`;let oe;const _=(e,t)=>{if(!oe){globalThis[ae]??=new Map;oe=globalThis[ae]}if(!oe.has(e))oe.set(e,t());return oe.get(e)};const se=e=>typeof e===`string`;const ce=e=>typeof e===`number`;const le=e=>typeof e===`boolean`;const ue=e=>typeof e===`bigint`;const de=e=>typeof e===`symbol`;const fe=e;const pe=e=>e===void 0;const me=e=>false;const he=e=>typeof e===`object`&&e!==null;const ge=e=>he(e)||fe(e);const v=t(2,(e,t)=>ge(e)&&t in e);const _e=t(2,(e,t)=>v(e,`_tag`)&&e[`_tag`]===t);const ve=e=>e===null||e===void 0;const ye=e=>e!==null&&e!==void 0;const be=e=>e instanceof Uint8Array;const xe=e=>e instanceof Date;const Se=e=>v(e,Symbol.iterator);const Ce=e=>he(e)&&!Array.isArray(e);const we=e=>v(e,`then`)&&fe(e.then);const Te=e=>e instanceof RegExp;const Ee=e=>`BUG: ${e} - please report an issue at https://github.com/Effect-TS/effect/issues`;const De=Symbol.for(`effect/Gen/GenKind`);var Oe=class{value;constructor(e){this.value=e}get _F(){return n}get _R(){return e=>e}get _O(){return e=>e}get _E(){return e=>e}[De]=De;[Symbol.iterator](){return new ke(this)}};var ke=class e{self;called=false;constructor(e){this.self=e}next(e){return this.called?{value:e,done:true}:(this.called=true,{value:this.self,done:false})}return(e){return{value:e,done:true}}throw(e){throw e}[Symbol.iterator](){return new e(this.self)}};const Ae=335903614;const je=4150755663;const Me=1481765933;const Ne=1284865837;const Pe=9007199254740992;const Fe=134217728;var Ie=class{_state;constructor(e,t,n,r){if(ve(t)&&ve(e)){t=Math.random()*4294967295>>>0;e=0}else if(ve(t)){t=e;e=0}if(ve(r)&&ve(n)){r=this._state?this._state[3]:je;n=this._state?this._state[2]:Ae}else if(ve(r)){r=n;n=0}this._state=new Int32Array([0,0,n>>>0,((r||0)|1)>>>0]);this._next();Re(this._state,this._state[0],this._state[1],e>>>0,t>>>0);this._next();return this}getState(){return[this._state[0],this._state[1],this._state[2],this._state[3]]}setState(e){this._state[0]=e[0];this._state[1]=e[1];this._state[2]=e[2];this._state[3]=e[3]|1}integer(e){return Math.round(this.number()*Number.MAX_SAFE_INTEGER)%e}number(){const e=(this._next()&67108863)*1;const t=(this._next()&134217727)*1;return(e*Fe+t)/Pe}_next(){const e=this._state[0]>>>0;const t=this._state[1]>>>0;Le(this._state,e,t,Me,Ne);Re(this._state,this._state[0],this._state[1],this._state[2],this._state[3]);let n=e>>>18;let r=(t>>>18|e<<14)>>>0;n=(n^e)>>>0;r=(r^t)>>>0;const i=(r>>>27|n<<5)>>>0;const a=e>>>27;const o=(-a>>>0&31)>>>0;return(i>>>a|i<<o)>>>0}};function Le(e,t,n,r,i){let a=(n>>>16)*(i&65535)>>>0;let o=(n&65535)*(i>>>16)>>>0;let s=(n&65535)*(i&65535)>>>0;let c=(n>>>16)*(i>>>16)+((o>>>16)+(a>>>16))>>>0;o=o<<16>>>0;s=s+o>>>0;if(s>>>0<o>>>0)c=c+1>>>0;a=a<<16>>>0;s=s+a>>>0;if(s>>>0<a>>>0)c=c+1>>>0;c=c+Math.imul(n,r)>>>0;c=c+Math.imul(t,i)>>>0;e[0]=c;e[1]=s}function Re(e,t,n,r,i){let a=t+r>>>0;const o=n+i>>>0;if(o>>>0<n>>>0)a=a+1|0;e[0]=a;e[1]=o}const ze=Symbol.for(`effect/Utils/YieldWrap`);var Be=class{#value;constructor(e){this.#value=e}[ze](){return this.#value}};function Ve(e){if(typeof e===`object`&&e!==null&&ze in e)return e[ze]();throw new Error(Ee(`yieldWrapGet`))}const He=_(`effect/Utils/isStructuralRegion`,()=>({enabled:false,tester:void 0}));const Ue={effect_internal_function:e=>{return e()}};const We={effect_internal_function:e=>{try{return e()}finally{}}};const Ge=Ue.effect_internal_function(()=>new Error().stack)?.includes(`effect_internal_function`)===true;const Ke=Ge?Ue.effect_internal_function:We.effect_internal_function;const qe=function*(){}.constructor;const Je=_(Symbol.for(`effect/Hash/randomHashCache`),()=>new WeakMap);const y=Symbol.for(`effect/Hash`);const b=e=>{if(He.enabled===true)return 0;switch(typeof e){case`number`:return Qe(e);case`bigint`:return $e(e.toString(10));case`boolean`:return $e(String(e));case`symbol`:return $e(String(e));case`string`:return $e(e);case`undefined`:return $e(`undefined`);case`function`:case`object`:if(e===null)return $e(`null`);else if(e instanceof Date)return b(e.toISOString());else if(e instanceof URL)return b(e.href);else if(Ze(e))return e[y]();else return Ye(e);default:throw new Error(`BUG: unhandled typeof ${typeof e} - please report an issue at https://github.com/Effect-TS/effect/issues`)}};const Ye=e=>{if(!Je.has(e))Je.set(e,Qe(Math.floor(Math.random()*Number.MAX_SAFE_INTEGER)));return Je.get(e)};const x=e=>t=>t*53^e;const Xe=e=>e&3221225471|e>>>1&1073741824;const Ze=e=>v(e,y);const Qe=e=>{if(e!==e||e===1/0)return 0;let t=e|0;if(t!==e)t^=e*4294967295;while(e>4294967295)t^=e/=4294967295;return Xe(t)};const $e=e=>{let t=5381,n=e.length;while(n)t=t*33^e.charCodeAt(--n);return Xe(t)};const et=(e,t)=>{let n=12289;for(let r=0;r<t.length;r++)n^=c($e(t[r]),x(b(e[t[r]])));return Xe(n)};const tt=e=>et(e,Object.keys(e));const nt=e=>{let t=6151;for(let n=0;n<e.length;n++)t=c(t,x(b(e[n])));return Xe(t)};const S=function(){if(arguments.length===1){const e=arguments[0];return function(t){Object.defineProperty(e,y,{value(){return t},enumerable:false});return t}}const e=arguments[0];const t=arguments[1];Object.defineProperty(e,y,{value(){return t},enumerable:false});return t};const C=Symbol.for(`effect/Equal`);function w(){if(arguments.length===1)return e=>rt(e,arguments[0]);return rt(arguments[0],arguments[1])}function rt(e,t){if(e===t)return true;const n=typeof e;if(n!==typeof t)return false;if(n===`object`||n===`function`){if(e!==null&&t!==null){if(it(e)&&it(t))if(b(e)===b(t)&&e[C](t))return true;else return He.enabled&&He.tester?He.tester(e,t):false;else if(e instanceof Date&&t instanceof Date)return e.toISOString()===t.toISOString();else if(e instanceof URL&&t instanceof URL)return e.href===t.href}if(He.enabled){if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every((e,n)=>rt(e,t[n]));if(Object.getPrototypeOf(e)===Object.prototype&&Object.getPrototypeOf(e)===Object.prototype){const n=Object.keys(e);const r=Object.keys(t);if(n.length===r.length){for(const r of n)if(!(r in t&&rt(e[r],t[r])))return He.tester?He.tester(e,t):false;return true}}return He.tester?He.tester(e,t):false}}return He.enabled&&He.tester?He.tester(e,t):false}const it=e=>v(e,C);const at=()=>w;const T=Symbol.for(`nodejs.util.inspect.custom`);const E=e=>{try{if(v(e,`toJSON`)&&fe(e[`toJSON`])&&e[`toJSON`].length===0)return e.toJSON();else if(Array.isArray(e))return e.map(E)}catch{return{}}return mt(e)};const D=e=>JSON.stringify(e,null,2);const ot={toJSON(){return E(this)},[T](){return this.toJSON()},toString(){return D(this.toJSON())}};var st=class{[T](){return this.toJSON()}toString(){return D(this.toJSON())}};const ct=(e,t=2)=>{if(typeof e===`string`)return e;try{return typeof e===`object`?lt(e,t):String(e)}catch{return String(e)}};const lt=(e,t)=>{let n=[];const r=JSON.stringify(e,(e,t)=>typeof t===`object`&&t!==null?n.includes(t)?void 0:n.push(t)&&(ft.fiberRefs!==void 0&&dt(t)?t[ut](ft.fiberRefs):t):t,t);n=void 0;return r};const ut=Symbol.for(`effect/Inspectable/Redactable`);const dt=e=>typeof e===`object`&&e!==null&&ut in e;const ft=_(`effect/Inspectable/redactableState`,()=>({fiberRefs:void 0}));const pt=(e,t)=>{const n=ft.fiberRefs;ft.fiberRefs=e;try{return t()}finally{ft.fiberRefs=n}};const mt=e=>{if(dt(e)&&ft.fiberRefs!==void 0)return e[ut](ft.fiberRefs);return e};const O=(e,t)=>{switch(t.length){case 0:return e;case 1:return t[0](e);case 2:return t[1](t[0](e));case 3:return t[2](t[1](t[0](e)));case 4:return t[3](t[2](t[1](t[0](e))));case 5:return t[4](t[3](t[2](t[1](t[0](e)))));case 6:return t[5](t[4](t[3](t[2](t[1](t[0](e))))));case 7:return t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))));case 8:return t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e))))))));case 9:return t[8](t[7](t[6](t[5](t[4](t[3](t[2](t[1](t[0](e)))))))));default:{let n=e;for(let e=0,r=t.length;e<r;e++)n=t[e](n);return n}}};const ht=`Async`;const gt=`Commit`;const k=`Failure`;const _t=`OnFailure`;const vt=`OnSuccess`;const yt=`OnSuccessAndFailure`;const A=`Success`;const bt=`Sync`;const xt=`Tag`;const St=`UpdateRuntimeFlags`;const Ct=`While`;const wt=`Iterator`;const Tt=`WithRuntime`;const Et=`Yield`;const Dt=`RevertFlags`;let Ot=`3.17.2`;const kt=()=>Ot;const At=Symbol.for(`effect/Effect`);const jt=Symbol.for(`effect/Stream`);const Mt=Symbol.for(`effect/Sink`);const Nt=Symbol.for(`effect/Channel`);const Pt={_R:e=>e,_E:e=>e,_A:e=>e,_V:kt()};const Ft={_A:e=>e,_In:e=>e,_L:e=>e,_E:e=>e,_R:e=>e};const It={_Env:e=>e,_InErr:e=>e,_InElem:e=>e,_InDone:e=>e,_OutErr:e=>e,_OutElem:e=>e,_OutDone:e=>e};const Lt={[At]:Pt,[jt]:Pt,[Mt]:Ft,[Nt]:It,[C](e){return this===e},[y](){return S(this,Ye(this))},[Symbol.iterator](){return new ke(new Be(this))},pipe(){return O(this,arguments)}};const Rt={[y](){return S(this,tt(this))},[C](e){const t=Object.keys(this);const n=Object.keys(e);if(t.length!==n.length)return false;for(const n of t)if(!(n in e&&w(this[n],e[n])))return false;return true}};const zt={...Lt,_op:gt};const Bt={...zt,...Rt};const Vt=function(){function e(){}e.prototype=zt;return e}();const Ht=function(){function e(){}e.prototype=Bt;return e}();const Ut=Symbol.for(`effect/Option`);const Wt={...Lt,[Ut]:{_A:e=>e},[T](){return this.toJSON()},toString(){return D(this.toJSON())}};const Gt=Object.assign(Object.create(Wt),{_tag:`Some`,_op:`Some`,[C](e){return Jt(e)&&Xt(e)&&w(this.value,e.value)},[y](){return S(this,x(b(this._tag))(b(this.value)))},toJSON(){return{_id:`Option`,_tag:this._tag,value:E(this.value)}}});const Kt=b(`None`);const qt=Object.assign(Object.create(Wt),{_tag:`None`,_op:`None`,[C](e){return Jt(e)&&Yt(e)},[y](){return Kt},toJSON(){return{_id:`Option`,_tag:this._tag}}});const Jt=e=>v(e,Ut);const Yt=e=>e._tag===`None`;const Xt=e=>e._tag===`Some`;const Zt=Object.create(qt);const Qt=e=>{const t=Object.create(Gt);t.value=e;return t};const $t=Symbol.for(`effect/Either`);const en={...Lt,[$t]:{_R:e=>e},[T](){return this.toJSON()},toString(){return D(this.toJSON())}};const tn=Object.assign(Object.create(en),{_tag:`Right`,_op:`Right`,[C](e){return rn(e)&&on(e)&&w(this.right,e.right)},[y](){return x(b(this._tag))(b(this.right))},toJSON(){return{_id:`Either`,_tag:this._tag,right:E(this.right)}}});const nn=Object.assign(Object.create(en),{_tag:`Left`,_op:`Left`,[C](e){return rn(e)&&an(e)&&w(this.left,e.left)},[y](){return x(b(this._tag))(b(this.left))},toJSON(){return{_id:`Either`,_tag:this._tag,left:E(this.left)}}});const rn=e=>v(e,$t);const an=e=>e._tag===`Left`;const on=e=>e._tag===`Right`;const sn=e=>{const t=Object.create(nn);t.left=e;return t};const cn=e=>{const t=Object.create(tn);t.right=e;return t};const ln=e=>on(e)?Zt:Qt(e.left);const un=e=>an(e)?Zt:Qt(e.right);const dn=t(2,(e,t)=>Yt(e)?sn(t()):cn(e.value));const fn=$t;const j=cn;const M=sn;const pn=dn;const mn=e=>{if(fe(e))try{return j(e())}catch(e){return M(e)}else try{return j(e.try())}catch(t){return M(e.catch(t))}};const hn=rn;const gn=an;const _n=on;const vn=un;const yn=ln;const bn=t(2,(e,t)=>gn(e)?M(t(e.left)):j(e.right));const xn=t(2,(e,t)=>_n(e)?j(t(e.right)):M(e.left));const Sn=t(2,(e,{onLeft:t,onRight:n})=>gn(e)?t(e.left):n(e.right));const Cn=Sn({onLeft:n,onRight:n});const wn=t(2,(e,t)=>{if(_n(e))return e.right;throw t(e.left)});const Tn=e=>e.length>0;const En=e=>(t,n)=>t===n?0:e(t,n);const Dn=En((e,t)=>e<t?-1:1);const On=En((e,t)=>e<t?-1:1);const kn=t(2,(e,t)=>En((n,r)=>e(t(n),t(r))));const An=e=>{return En((t,n)=>{const r=Math.min(t.length,n.length);let i=0;for(const a of e){if(i>=r)break;const e=a(t[i],n[i]);if(e!==0)return e;i++}return 0})};const jn=(...e)=>An(e);const Mn=e=>En((t,n)=>{const r=t.length;const i=n.length;const a=Math.min(r,i);for(let r=0;r<a;r++){const i=e(t[r],n[r]);if(i!==0)return i}return Dn(r,i)});const Nn=e=>{const t=Object.keys(e);return En((n,r)=>{for(const i of t){const t=e[i](n[i],r[i]);if(t!==0)return t}return 0})};const Pn=e=>t(2,(t,n)=>e(t,n)===1);const N=()=>Zt;const P=Qt;const Fn=Jt;const In=Yt;const F=Xt;const Ln=t(2,(e,{onNone:t,onSome:n})=>In(e)?t():n(e.value));const Rn=un;const zn=ln;const Bn=t(2,(e,t)=>In(e)?t():e.value);const Vn=t(2,(e,t)=>In(e)?t():e);const Hn=t(2,(e,t)=>In(e)?P(t()):e);const Un=e=>e==null?N():P(e);const Wn=Bn(o);const Gn=e=>(...t)=>{try{return P(e(...t))}catch{return N()}};const Kn=t(2,(e,t)=>{if(F(e))return e.value;throw t()});const qn=Kn(()=>new Error(`getOrThrow called on a None`));const Jn=t(2,(e,t)=>In(e)?N():P(t(e.value)));const Yn=t(2,(e,t)=>In(e)?N():t(e.value));const Xn=e=>In(e)?[]:[e.value];const Zn=Yn;const Qn=e=>t(2,(t,n)=>In(t)?false:e(t.value,n));const $n=at();const er=Qn($n);const tr=t(2,(e,t)=>In(e)?false:t(e.value));const nr=e=>(t,n)=>{if(In(t))return n;else if(In(n))return t;return P(e(t.value,n.value))};const rr=(...e)=>e;const ir=g;const ar=jn;const or=t(2,(e,t)=>{let n=0;for(const r of e){const e=t(r,n);if(le(e)){if(e)return P(r)}else if(F(e))return e;n++}return N()});const sr=t(2,(e,t)=>{const n=[];for(const r of lr(e))n.push(t(r,e[r]));return n});const cr=sr((e,t)=>[e,t]);const lr=e=>Object.keys(e);const ur=e=>new Array(e);const dr=t(2,(e,t)=>{const n=Math.max(1,Math.floor(e));const r=new Array(n);for(let e=0;e<n;e++)r[e]=t(e);return r});const I=e=>Array.isArray(e)?e:Array.from(e);const fr=e=>Array.isArray(e)?e:[e];const pr=cr;const mr=Xn;const hr=t(2,(e,{onEmpty:t,onNonEmpty:n})=>Cr(e)?n(kr(e),Mr(e)):t());const gr=t(2,(e,t)=>[t,...e]);const _r=t(2,(e,t)=>[...e,t]);const vr=t(2,(e,t)=>I(e).concat(I(t)));const yr=Array.isArray;const br=e=>e.length===0;const xr=br;const Sr=Tn;const Cr=Tn;const wr=(e,t)=>e<0||e>=t.length;const Tr=(e,t)=>Math.floor(Math.min(Math.max(0,e),t.length));const Er=t(2,(e,t)=>{const n=Math.floor(t);return wr(n,e)?N():P(e[n])});const Dr=t(2,(e,t)=>{const n=Math.floor(t);if(wr(n,e))throw new Error(`Index ${n} out of bounds`);return e[n]});const Or=Er(0);const kr=Dr(0);const Ar=e=>Cr(e)?P(jr(e)):N();const jr=e=>e[e.length-1];const Mr=e=>e.slice(1);const Nr=(e,t)=>{let n=0;for(const r of e){if(!t(r,n))break;n++}return n};const Pr=t(2,(e,t)=>qr(e,Nr(e,t)));const Fr=t(2,(e,t)=>{const n=I(e);return n.slice(Tr(t,n),n.length)});const Ir=t(2,(e,t)=>{let n=0;for(const r of e){if(t(r,n))return P(n);n++}return N()});const Lr=t(2,(e,t)=>{const n=I(e);for(let e=n.length-1;e>=0;e--)if(t(n[e],e))return P(e);return N()});const Rr=or;const zr=t(2,(e,t)=>{const n=I(e);for(let e=n.length-1;e>=0;e--){const r=n[e];const i=t(r,e);if(le(i)){if(i)return P(r)}else if(F(i))return i}return N()});const Br=e=>Array.from(e).reverse();const Vr=t(2,(e,t)=>{const n=Array.from(e);n.sort(t);return n});const Hr=t(2,(e,t)=>Ur(e,t,rr));const Ur=t(3,(e,t,n)=>{const r=I(e);const i=I(t);if(Cr(r)&&Cr(i)){const e=[n(kr(r),kr(i))];const t=Math.min(r.length,i.length);for(let a=1;a<t;a++)e[a]=n(r[a],i[a]);return e}return[]});const Wr=e=>t(2,(t,n)=>{for(const r of t)if(e(n,r))return true;return false});const Gr=at();const Kr=Wr(Gr);const qr=t(2,(e,t)=>{const n=Array.from(e);const r=Math.floor(t);if(Cr(n)){if(r>=1)return Jr(n,r);return[[],n]}return[n,[]]});const Jr=t(2,(e,t)=>{const n=Math.max(1,Math.floor(t));return n>=e.length?[Yr(e),[]]:[gr(e.slice(1,n),kr(e)),e.slice(n)]});const Yr=e=>e.slice();const Xr=t(3,(e,t,n)=>{const r=I(e);const i=I(t);if(Cr(r)){if(Cr(i)){const e=di(n);return e(vr(r,i))}return r}return i});const Zr=t(2,(e,t)=>Xr(e,t,Gr));const Qr=()=>[];const $r=e=>[e];const ei=t(2,(e,t)=>e.map(t));const ti=t(2,(e,t)=>{if(xr(e))return[];const n=[];for(let r=0;r<e.length;r++){const i=t(e[r],r);for(let e=0;e<i.length;e++)n.push(i[e])}return n});const ni=ti(n);const ri=t(2,(e,t)=>{const n=I(e);const r=[];for(let e=0;e<n.length;e++){const i=t(n[e],e);if(F(i))r.push(i.value)}return r});const ii=t(2,(e,t)=>{const n=[];const r=[];const i=I(e);for(let e=0;e<i.length;e++){const a=t(i[e],e);if(gn(a))n.push(a.left);else r.push(a.right)}return[n,r]});const ai=ri(n);const oi=t(3,(e,t,n)=>I(e).reduce((e,t,r)=>n(e,t,r),t));const si=t(3,(e,t,n)=>I(e).reduceRight((e,t,r)=>n(e,t,r),t));const ci=(e,t)=>{const n=[];let r=e;let i;while(F(i=t(r))){const[e,t]=i.value;n.push(e);r=t}return n};const li=Mn;const ui=ee;const di=t(2,(e,t)=>{const n=I(e);if(Cr(n)){const e=[kr(n)];const r=Mr(n);for(const n of r)if(e.every(e=>!t(n,e)))e.push(n);return e}return[]});const fi=e=>di(e,at());const pi=t(2,(e,t)=>I(e).join(t));const mi=ce;const hi=f;const gi=Dn;const _i=Te;const vi=e=>e.replace(/[/\\^$*+?.()|[\]{}]/g,`\\$&`);const yi=(e,t)=>{switch(t._tag){case`StringKeyword`:case`TemplateLiteral`:return Object.keys(e);case`SymbolKeyword`:return Object.getOwnPropertySymbols(e);case`Refinement`:return yi(e,t.from)}};const bi=e=>Object.keys(e).concat(Object.getOwnPropertySymbols(e));const xi=e=>{let t=false;let n;return()=>{if(t)return n;n=e();t=true;return n}};const Si=e=>{try{return e.toISOString()}catch(t){return String(e)}};const Ci=e=>{if(se(e))return JSON.stringify(e);else if(ce(e)||e==null||le(e)||de(e))return String(e);else if(xe(e))return Si(e);else if(ue(e))return String(e)+`n`;else if(!yr(e)&&v(e,`toString`)&&fe(e[`toString`])&&e[`toString`]!==Object.prototype.toString)return e[`toString`]();try{JSON.stringify(e);if(yr(e))return`[${e.map(Ci).join(`,`)}]`;else return`{${bi(e).map(t=>`${se(t)?JSON.stringify(t):String(t)}:${Ci(e[t])}`).join(`,`)}}`}catch(t){return String(e)}};const wi=e=>typeof e===`string`?JSON.stringify(e):String(e);const Ti=e=>Array.isArray(e);const Ei=e=>!Array.isArray(e);const Di=e=>`[${wi(e)}]`;const Oi=e=>Ti(e)?e.map(Di).join(``):Di(e);const ki=(e,t,n,r)=>{let i=e;if(n&&Cr(n))i+=`\nat path: ${Oi(n)}`;if(t!==void 0)i+=`\ndetails: ${t}`;if(r)i+=`\nschema (${r._tag}): ${r}`;return i};const Ai=e=>ki(`Unsupported key schema`,void 0,void 0,e);const ji=e=>ki(`Unsupported literal`,`literal value: ${Ci(e)}`);const Mi=e=>ki(`Duplicate index signature`,`${e} index signature`);const Ni=ki(`Unsupported index signature parameter`,"An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");const Pi=ki(`Invalid element`,`A required element cannot follow an optional element. ts(1257)`);const Fi=e=>ki(`Duplicate property signature transformation`,`Duplicate key ${Ci(e)}`);const Ii=e=>ki(`Duplicate property signature`,`Duplicate key ${Ci(e)}`);const Li=Symbol.for(`@effect/schema/annotation/Type`);const Ri=Symbol.for(`@effect/schema/annotation/Message`);const zi=Symbol.for(`@effect/schema/annotation/MissingMessage`);const Bi=Symbol.for(`@effect/schema/annotation/Identifier`);const Vi=Symbol.for(`@effect/schema/annotation/Title`);const Hi=Symbol.for(`@effect/schema/annotation/Description`);const Ui=Symbol.for(`@effect/schema/annotation/Examples`);const Wi=Symbol.for(`@effect/schema/annotation/Default`);const Gi=Symbol.for(`@effect/schema/annotation/JSONSchema`);const Ki=Symbol.for(`@effect/schema/annotation/Documentation`);const qi=Symbol.for(`@effect/schema/annotation/Concurrency`);const Ji=Symbol.for(`@effect/schema/annotation/Batching`);const Yi=Symbol.for(`@effect/schema/annotation/ParseIssueTitle`);const Xi=Symbol.for(`@effect/schema/annotation/ParseOptions`);const Zi=Symbol.for(`@effect/schema/annotation/DecodingFallback`);const Qi=Symbol.for(`@effect/schema/annotation/Surrogate`);const $i=Symbol.for(`@effect/schema/annotation/StableFilter`);const ea=t(2,(e,t)=>Object.prototype.hasOwnProperty.call(e.annotations,t)?P(e.annotations[t]):N());const ta=ea(Ri);const na=ea(zi);const ra=ea(Vi);const ia=ea(Bi);const aa=ea(Hi);const oa=ea(qi);const sa=ea(Ji);const ca=ea(Yi);const la=ea(Xi);const ua=ea(Zi);const da=ea(Qi);const fa=ea($i);const pa=e=>tr(fa(e),e=>e===true);const ma=Symbol.for(`@effect/schema/annotation/JSONIdentifier`);const ha=ea(ma);var ga=class{typeParameters;decodeUnknown;encodeUnknown;annotations;_tag=`Declaration`;constructor(e,t,n,r={}){this.typeParameters=e;this.decodeUnknown=t;this.encodeUnknown=n;this.annotations=r}toString(){return Bn(Io(this),()=>`<declaration schema>`)}toJSON(){return{_tag:this._tag,typeParameters:this.typeParameters.map(e=>e.toJSON()),annotations:No(this.annotations)}}};const _a=e=>t=>t._tag===e;var va=class{literal;annotations;_tag=`Literal`;constructor(e,t={}){this.literal=e;this.annotations=t}toString(){return Bn(Io(this),()=>Ci(this.literal))}toJSON(){return{_tag:this._tag,literal:ue(this.literal)?String(this.literal):this.literal,annotations:No(this.annotations)}}};const ya=_a(`Literal`);var ba=class{symbol;annotations;_tag=`UniqueSymbol`;constructor(e,t={}){this.symbol=e;this.annotations=t}toString(){return Bn(Io(this),()=>Ci(this.symbol))}toJSON(){return{_tag:this._tag,symbol:String(this.symbol),annotations:No(this.annotations)}}};var xa=class{annotations;_tag=`UndefinedKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Sa=new xa({[Vi]:`undefined`});var Ca=class{annotations;_tag=`VoidKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const wa=new Ca({[Vi]:`void`});var Ta=class{annotations;_tag=`NeverKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ea=new Ta({[Vi]:`never`});var Da=class{annotations;_tag=`UnknownKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Oa=new Da({[Vi]:`unknown`});var ka=class{annotations;_tag=`AnyKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Aa=new ka({[Vi]:`any`});var ja=class{annotations;_tag=`StringKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ma=new ja({[Vi]:`string`,[Hi]:`a string`});const Na=_a(`StringKeyword`);var Pa=class{annotations;_tag=`NumberKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Fa=new Pa({[Vi]:`number`,[Hi]:`a number`});const Ia=_a(`NumberKeyword`);var La=class{annotations;_tag=`BooleanKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ra=new La({[Vi]:`boolean`,[Hi]:`a boolean`});var za=class{annotations;_tag=`BigIntKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ba=new za({[Vi]:`bigint`,[Hi]:`a bigint`});var Va=class{annotations;_tag=`SymbolKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ha=new Va({[Vi]:`symbol`,[Hi]:`a symbol`});const Ua=_a(`SymbolKeyword`);var Wa=class{annotations;_tag=`ObjectKeyword`;constructor(e={}){this.annotations=e}toString(){return Fo(this)}toJSON(){return{_tag:this._tag,annotations:No(this.annotations)}}};const Ga=new Wa({[Vi]:`object`,[Hi]:"an object in the TypeScript meaning, i.e. the `object` type"});var Ka=class{type;annotations;constructor(e,t={}){this.type=e;this.annotations=t}toJSON(){return{type:this.type.toJSON(),annotations:No(this.annotations)}}toString(){return String(this.type)}};var qa=class extends Ka{isOptional;constructor(e,t,n={}){super(e,n);this.isOptional=t}toJSON(){return{type:this.type.toJSON(),isOptional:this.isOptional,annotations:No(this.annotations)}}toString(){return String(this.type)+(this.isOptional?`?`:``)}};const Ja=e=>e.map(e=>e.type);var Ya=class{elements;rest;isReadonly;annotations;_tag=`TupleType`;constructor(e,t,n,r={}){this.elements=e;this.rest=t;this.isReadonly=n;this.annotations=r;let i=false;let a=false;for(const t of e)if(t.isOptional)i=true;else if(i){a=true;break}if(a||i&&t.length>1)throw new Error(Pi)}toString(){return Bn(Io(this),()=>Xa(this))}toJSON(){return{_tag:this._tag,elements:this.elements.map(e=>e.toJSON()),rest:this.rest.map(e=>e.toJSON()),isReadonly:this.isReadonly,annotations:No(this.annotations)}}};const Xa=e=>{const t=e.elements.map(String).join(`, `);return hr(e.rest,{onEmpty:()=>`readonly [${t}]`,onNonEmpty:(n,r)=>{const i=String(n);const a=i.includes(` | `)?`(${i})`:i;if(r.length>0){const n=r.map(String).join(`, `);if(e.elements.length>0)return`readonly [${t}, ...${a}[], ${n}]`;else return`readonly [...${a}[], ${n}]`}else if(e.elements.length>0)return`readonly [${t}, ...${a}[]]`;else return`ReadonlyArray<${i}>`}})};var Za=class extends qa{name;isReadonly;constructor(e,t,n,r,i){super(t,n,i);this.name=e;this.isReadonly=r}toString(){return(this.isReadonly?`readonly `:``)+String(this.name)+(this.isOptional?`?`:``)+`: `+this.type}toJSON(){return{name:String(this.name),type:this.type.toJSON(),isOptional:this.isOptional,isReadonly:this.isReadonly,annotations:No(this.annotations)}}};const Qa=e=>{switch(e._tag){case`StringKeyword`:case`SymbolKeyword`:case`TemplateLiteral`:return true;case`Refinement`:return Qa(e.from)}return false};var $a=class{type;isReadonly;parameter;constructor(e,t,n){this.type=t;this.isReadonly=n;if(Qa(e))this.parameter=e;else throw new Error(Ni)}toString(){return(this.isReadonly?`readonly `:``)+`[x: ${this.parameter}]: ${this.type}`}toJSON(){return{parameter:this.parameter.toJSON(),type:this.type.toJSON(),isReadonly:this.isReadonly}}};var eo=class{annotations;_tag=`TypeLiteral`;propertySignatures;indexSignatures;constructor(e,t,n={}){this.annotations=n;const r={};for(let t=0;t<e.length;t++){const n=e[t].name;if(Object.prototype.hasOwnProperty.call(r,n))throw new Error(Ii(n));r[n]=null}const i={string:false,symbol:false};for(let e=0;e<t.length;e++){const n=Po(t[e].parameter);if(Na(n)){if(i.string)throw new Error(Mi(`string`));i.string=true}else if(Ua(n)){if(i.symbol)throw new Error(Mi(`symbol`));i.symbol=true}}this.propertySignatures=e;this.indexSignatures=t}toString(){return Bn(Io(this),()=>no(this))}toJSON(){return{_tag:this._tag,propertySignatures:this.propertySignatures.map(e=>e.toJSON()),indexSignatures:this.indexSignatures.map(e=>e.toJSON()),annotations:No(this.annotations)}}};const to=e=>e.map(String).join(`; `);const no=e=>{if(e.propertySignatures.length>0){const t=e.propertySignatures.map(String).join(`; `);if(e.indexSignatures.length>0)return`{ ${t}; ${to(e.indexSignatures)} }`;else return`{ ${t} }`}else if(e.indexSignatures.length>0)return`{ ${to(e.indexSignatures)} }`;else return`{}`};const ro=Vr(kn(gi,e=>{switch(e._tag){case`AnyKeyword`:return 0;case`UnknownKeyword`:return 1;case`ObjectKeyword`:return 2;case`StringKeyword`:case`NumberKeyword`:case`BooleanKeyword`:case`BigIntKeyword`:case`SymbolKeyword`:return 3}return 4}));const io={string:`StringKeyword`,number:`NumberKeyword`,boolean:`BooleanKeyword`,bigint:`BigIntKeyword`};const ao=e=>ti(e,e=>lo(e)?ao(e.types):[e]);const oo=e=>{const t=ro(e);const n=[];const r={};const i=[];for(const e of t)switch(e._tag){case`NeverKeyword`:break;case`AnyKeyword`:return[Aa];case`UnknownKeyword`:return[Oa];case`ObjectKeyword`:case`UndefinedKeyword`:case`VoidKeyword`:case`StringKeyword`:case`NumberKeyword`:case`BooleanKeyword`:case`BigIntKeyword`:case`SymbolKeyword`:{if(!r[e._tag]){r[e._tag]=e;n.push(e)}break}case`Literal`:{const t=typeof e.literal;switch(t){case`string`:case`number`:case`bigint`:case`boolean`:{const a=io[t];if(!r[a]&&!i.includes(e.literal)){i.push(e.literal);n.push(e)}break}case`object`:{if(!i.includes(e.literal)){i.push(e.literal);n.push(e)}break}}break}case`UniqueSymbol`:{if(!r[`SymbolKeyword`]&&!i.includes(e.symbol)){i.push(e.symbol);n.push(e)}break}case`TupleType`:{if(!r[`ObjectKeyword`])n.push(e);break}case`TypeLiteral`:{if(e.propertySignatures.length===0&&e.indexSignatures.length===0){if(!r[`{}`]){r[`{}`]=e;n.push(e)}}else if(!r[`ObjectKeyword`])n.push(e);break}default:n.push(e)}return n};var so=class e{types;annotations;static make=(t,n)=>{return co(t)?new e(t,n):t.length===1?t[0]:Ea};static unify=(t,n)=>{return e.make(oo(ao(t)),n)};_tag=`Union`;constructor(e,t={}){this.types=e;this.annotations=t}toString(){return Bn(Io(this),()=>this.types.map(String).join(` | `))}toJSON(){return{_tag:this._tag,types:this.types.map(e=>e.toJSON()),annotations:No(this.annotations)}}};const co=e=>e.length>1;const lo=_a(`Union`);const uo=_(Symbol.for(`@effect/schema/AST/toJSONMemoMap`),()=>new WeakMap);var fo=class{f;annotations;_tag=`Suspend`;constructor(e,t={}){this.f=e;this.annotations=t;this.f=xi(e)}toString(){return Io(this).pipe(Vn(()=>Yn(Gn(this.f)(),e=>Io(e))),Bn(()=>`<suspended schema>`))}toJSON(){const e=this.f();let t=uo.get(e);if(t)return t;uo.set(e,{_tag:this._tag});t={_tag:this._tag,ast:e.toJSON(),annotations:No(this.annotations)};uo.set(e,t);return t}};var po=class{from;filter;annotations;_tag=`Refinement`;constructor(e,t,n={}){this.from=e;this.filter=t;this.annotations=n}toString(){return Bn(Io(this),()=>`{ ${this.from} | filter }`)}toJSON(){return{_tag:this._tag,from:this.from.toJSON(),annotations:No(this.annotations)}}};const mo=_a(`Refinement`);const ho={};var go=class{from;to;transformation;annotations;_tag=`Transformation`;constructor(e,t,n,r={}){this.from=e;this.to=t;this.transformation=n;this.annotations=r}toString(){return Bn(Io(this),()=>`(${String(this.from)} <-> ${String(this.to)})`)}toJSON(){return{_tag:this._tag,from:this.from.toJSON(),to:this.to.toJSON(),annotations:No(this.annotations)}}};const _o=_a(`Transformation`);var vo=class{decode;encode;_tag=`FinalTransformation`;constructor(e,t){this.decode=e;this.encode=t}};var yo=class{from;to;decode;encode;constructor(e,t,n,r){this.from=e;this.to=t;this.decode=n;this.encode=r}};var bo=class{propertySignatureTransformations;_tag=`TypeLiteralTransformation`;constructor(e){this.propertySignatureTransformations=e;const t={};const n={};for(const r of e){const e=r.from;if(t[e])throw new Error(Fi(e));t[e]=true;const i=r.to;if(n[i])throw new Error(Fi(i));n[i]=true}}};const xo=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e);n.annotations.value={...e.annotations,...t};return Object.create(Object.getPrototypeOf(e),n)};const So=`.*`;const Co=`[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?`;const wo=e=>{let t=`^${vi(e.head)}`;for(const n of e.spans){if(Na(n.type))t+=So;else if(Ia(n.type))t+=Co;t+=vi(n.literal)}t+=`$`;return new RegExp(t)};const To=(e,t)=>{const n=[];const r=[];const i=e=>{switch(e._tag){case`NeverKeyword`:break;case`StringKeyword`:case`SymbolKeyword`:case`TemplateLiteral`:case`Refinement`:r.push(new $a(e,t,true));break;case`Literal`:if(se(e.literal)||ce(e.literal))n.push(new Za(e.literal,t,false,true));else throw new Error(ji(e.literal));break;case`Enums`:{for(const[r,i]of e.enums)n.push(new Za(i,t,false,true));break}case`UniqueSymbol`:n.push(new Za(e.symbol,t,false,true));break;case`Union`:e.types.forEach(i);break;default:throw new Error(Ai(e))}};i(e);return{propertySignatures:n,indexSignatures:r}};const Eo=e=>{switch(e._tag){case`Declaration`:{const t=Ao(e.typeParameters,Eo);return t===e.typeParameters?e:new ga(t,e.decodeUnknown,e.encodeUnknown,e.annotations)}case`TupleType`:{const t=Ao(e.elements,e=>{const t=Eo(e.type);return t===e.type?e:new qa(t,e.isOptional)});const n=Ja(e.rest);const r=Ao(n,Eo);return t===e.elements&&r===n?e:new Ya(t,r.map(e=>new Ka(e)),e.isReadonly,e.annotations)}case`TypeLiteral`:{const t=Ao(e.propertySignatures,e=>{const t=Eo(e.type);return t===e.type?e:new Za(e.name,t,e.isOptional,e.isReadonly)});const n=Ao(e.indexSignatures,e=>{const t=Eo(e.type);return t===e.type?e:new $a(e.parameter,t,e.isReadonly)});return t===e.propertySignatures&&n===e.indexSignatures?e:new eo(t,n,e.annotations)}case`Union`:{const t=Ao(e.types,Eo);return t===e.types?e:so.make(t,e.annotations)}case`Suspend`:return new fo(()=>Eo(e.f()),e.annotations);case`Refinement`:{const t=Eo(e.from);return t===e.from?e:new po(t,e.filter,e.annotations)}case`Transformation`:return Eo(e.to)}return e};const Do=e=>t=>{const n={...t.annotations};for(const t of e)delete n[t];return n};const Oo=e=>Vn(ha(e),()=>ia(e));const ko=e=>Ln(Oo(e),{onNone:()=>void 0,onSome:e=>({[ma]:e})});function Ao(e,t){let n=false;const r=ur(e.length);for(let i=0;i<e.length;i++){const a=e[i];const o=t(a);if(o!==a)n=true;r[i]=o}return n?r:e}const jo=(e,t)=>{switch(e._tag){case`Declaration`:{const n=Ao(e.typeParameters,e=>jo(e,t));return n===e.typeParameters?e:new ga(n,e.decodeUnknown,e.encodeUnknown,e.annotations)}case`TupleType`:{const n=Ao(e.elements,e=>{const n=jo(e.type,t);return n===e.type?e:new qa(n,e.isOptional)});const r=Ja(e.rest);const i=Ao(r,e=>jo(e,t));return n===e.elements&&i===r?e:new Ya(n,i.map(e=>new Ka(e)),e.isReadonly,ko(e))}case`TypeLiteral`:{const n=Ao(e.propertySignatures,e=>{const n=jo(e.type,t);return n===e.type?e:new Za(e.name,n,e.isOptional,e.isReadonly)});const r=Ao(e.indexSignatures,e=>{const n=jo(e.type,t);return n===e.type?e:new $a(e.parameter,n,e.isReadonly)});return n===e.propertySignatures&&r===e.indexSignatures?e:new eo(n,r,ko(e))}case`Union`:{const n=Ao(e.types,e=>jo(e,t));return n===e.types?e:so.make(n,ko(e))}case`Suspend`:return new fo(()=>jo(e.f(),t),ko(e));case`Refinement`:{const n=jo(e.from,t);if(t){if(n===e.from)return e;if(!_o(e.from)&&pa(e))return new po(n,e.filter)}return n}case`Transformation`:return jo(e.from,t)}return e};const Mo=e=>jo(e,false);const No=e=>{const t={};for(const n of Object.getOwnPropertySymbols(e))t[String(n)]=e[n];return t};const Po=e=>{switch(e._tag){case`StringKeyword`:case`SymbolKeyword`:case`TemplateLiteral`:return e;case`Refinement`:return Po(e.from)}};const Fo=e=>Bn(Io(e),()=>e._tag);const Io=e=>{return ia(e).pipe(Vn(()=>ra(e)),Vn(()=>aa(e)))};const Lo=Symbol.for(`@effect/schema/TypeId/GreaterThan`);const Ro=Symbol.for(`@effect/schema/TypeId/GreaterThanOrEqualTo`);const zo=Symbol.for(`@effect/schema/TypeId/LessThan`);const Bo=Symbol.for(`@effect/schema/TypeId/LessThanOrEqualTo`);const Vo=Symbol.for(`@effect/schema/TypeId/Int`);const Ho=Symbol.for(`@effect/schema/TypeId/Between`);const Uo=Symbol.for(`@effect/schema/TypeId/GreaterThanBigint`);const Wo=Symbol.for(`@effect/schema/TypeId/GreaterThanOrEqualToBigint`);const Go=Symbol.for(`@effect/schema/TypeId/LessThanBigint`);const Ko=Symbol.for(`@effect/schema/TypeId/LessThanOrEqualToBigint`);const qo=Symbol.for(`@effect/schema/TypeId/BetweenBigint`);const Jo=Symbol.for(`@effect/schema/TypeId/MinLength`);const Yo=Symbol.for(`@effect/schema/TypeId/MaxLength`);const Xo=Symbol.for(`@effect/schema/TypeId/Length`);const Zo=Symbol.for(`@effect/schema/TypeId/MinItems`);const Qo=Symbol.for(`@effect/schema/TypeId/MaxItems`);const $o=Symbol.for(`@effect/schema/TypeId/ItemsCount`);const es=Symbol.for(`@effect/schema/ArbitraryHookId`);const ts=Symbol.for(`effect/Chunk`);function ns(e,t,n,r,i){for(let a=t;a<Math.min(e.length,t+i);a++)n[r+a-t]=e[a];return n}const rs=[];const os=e=>l((t,n)=>t.length===n.length&&vs(t).every((t,r)=>e(t,ws(n,r))));const ss=os(w);const cs={[ts]:{_A:e=>e},toString(){return D(this.toJSON())},toJSON(){return{_id:`Chunk`,values:vs(this).map(E)}},[T](){return this.toJSON()},[C](e){return us(e)&&ss(this,e)},[y](){return S(this,nt(vs(this)))},[Symbol.iterator](){switch(this.backing._tag){case`IArray`:return this.backing.array[Symbol.iterator]();case`IEmpty`:return rs[Symbol.iterator]();default:return vs(this)[Symbol.iterator]()}},pipe(){return O(this,arguments)}};const ls=e=>{const t=Object.create(cs);t.backing=e;switch(e._tag){case`IEmpty`:{t.length=0;t.depth=0;t.left=t;t.right=t;break}case`IConcat`:{t.length=e.left.length+e.right.length;t.depth=1+Math.max(e.left.depth,e.right.depth);t.left=e.left;t.right=e.right;break}case`IArray`:{t.length=e.array.length;t.depth=0;t.left=ds;t.right=ds;break}case`ISingleton`:{t.length=1;t.depth=0;t.left=ds;t.right=ds;break}case`ISlice`:{t.length=e.length;t.depth=e.chunk.depth+1;t.left=ds;t.right=ds;break}}return t};const us=e=>v(e,ts);const ds=ls({_tag:`IEmpty`});const fs=()=>ds;const ps=(...e)=>Cs(e);const ms=e=>ls({_tag:`ISingleton`,a:e});const hs=e=>us(e)?e:Ss(I(e));const gs=(e,t,n)=>{switch(e.backing._tag){case`IArray`:{ns(e.backing.array,0,t,n,e.length);break}case`IConcat`:{gs(e.left,t,n);gs(e.right,t,n+e.left.length);break}case`ISingleton`:{t[n]=e.backing.a;break}case`ISlice`:{let r=0;let i=n;while(r<e.length){t[i]=ws(e,r);r+=1;i+=1}break}}};const _s=e=>{switch(e.backing._tag){case`IEmpty`:return rs;case`IArray`:return e.backing.array;default:{const t=new Array(e.length);gs(e,t,0);e.backing={_tag:`IArray`,array:t};e.left=ds;e.right=ds;e.depth=0;return t}}};const vs=_s;const ys=e=>{switch(e.backing._tag){case`IEmpty`:case`ISingleton`:return e;case`IArray`:return ls({_tag:`IArray`,array:Br(e.backing.array)});case`IConcat`:return ls({_tag:`IConcat`,left:bs(e.backing.right),right:bs(e.backing.left)});case`ISlice`:return Ss(Br(vs(e)))}};const bs=ys;const xs=t(2,(e,t)=>t<0||t>=e.length?N():P(ws(e,t)));const Ss=e=>e.length===0?fs():e.length===1?ms(e[0]):ls({_tag:`IArray`,array:e});const Cs=e=>Ss(e);const ws=t(2,(e,t)=>{switch(e.backing._tag){case`IEmpty`:throw new Error(`Index out of bounds`);case`ISingleton`:{if(t!==0)throw new Error(`Index out of bounds`);return e.backing.a}case`IArray`:{if(t>=e.length||t<0)throw new Error(`Index out of bounds`);return e.backing.array[t]}case`IConcat`:return t<e.left.length?ws(e.left,t):ws(e.right,t-e.left.length);case`ISlice`:return ws(e.backing.chunk,t+e.backing.offset)}});const Ts=t(2,(e,t)=>Ds(e,ms(t)));const L=t(2,(e,t)=>Ds(ms(t),e));const Es=t(2,(e,t)=>{if(t<=0)return e;else if(t>=e.length)return ds;else switch(e.backing._tag){case`ISlice`:return ls({_tag:`ISlice`,chunk:e.backing.chunk,offset:e.backing.offset+t,length:e.backing.length-t});case`IConcat`:{if(t>e.left.length)return Es(e.right,t-e.left.length);return ls({_tag:`IConcat`,left:Es(e.left,t),right:e.right})}default:return ls({_tag:`ISlice`,chunk:e,offset:t,length:e.length-t})}});const Ds=t(2,(e,t)=>{if(e.backing._tag===`IEmpty`)return t;if(t.backing._tag===`IEmpty`)return e;const n=t.depth-e.depth;if(Math.abs(n)<=1)return ls({_tag:`IConcat`,left:e,right:t});else if(n<-1)if(e.left.depth>=e.right.depth){const n=Ds(e.right,t);return ls({_tag:`IConcat`,left:e.left,right:n})}else{const n=Ds(e.right.right,t);if(n.depth===e.depth-3){const t=ls({_tag:`IConcat`,left:e.right.left,right:n});return ls({_tag:`IConcat`,left:e.left,right:t})}else{const t=ls({_tag:`IConcat`,left:e.left,right:e.right.left});return ls({_tag:`IConcat`,left:t,right:n})}}else if(t.right.depth>=t.left.depth){const n=Ds(e,t.left);return ls({_tag:`IConcat`,left:n,right:t.right})}else{const n=Ds(e,t.left.left);if(n.depth===t.depth-3){const e=ls({_tag:`IConcat`,left:n,right:t.left.right});return ls({_tag:`IConcat`,left:e,right:t.right})}else{const e=ls({_tag:`IConcat`,left:t.left.right,right:t.right});return ls({_tag:`IConcat`,left:n,right:e})}}});const Os=e=>e.length===0;const ks=e=>e.length>0;const As=xs(0);const js=e=>ws(e,0);const R=js;const Ms=e=>Es(e,1);const Ns=Kr;const Ps=Wr;const Fs=Rr;const Is=Ir;const Ls=zr;const Rs=Lr;const zs=pi;const Bs=oi;const Vs=si;const Hs=5;const Us=Math.pow(2,Hs);const Ws=Us-1;const Gs=Us/2;const Ks=Us/4;function qs(e){e-=e>>1&1431655765;e=(e&858993459)+(e>>2&858993459);e=e+(e>>4)&252645135;e+=e>>8;e+=e>>16;return e&127}function Js(e,t){return t>>>e&Ws}function Ys(e){return 1<<e}function Xs(e,t){return qs(e&t-1)}const Zs=(e,t)=>({value:e,previous:t});function Qs(e,t,n,r){let i=r;if(!e){const e=r.length;i=new Array(e);for(let t=0;t<e;++t)i[t]=r[t]}i[t]=n;return i}function $s(e,t,n){const r=n.length-1;let i=0;let a=0;let o=n;if(e)i=a=t;else{o=new Array(r);while(i<t)o[a++]=n[i++]}++i;while(i<=r)o[a++]=n[i++];if(e)o.length=r;return o}function ec(e,t,n,r){const i=r.length;if(e){let e=i;while(e>=t)r[e--]=r[e];r[t]=n;return r}let a=0,o=0;const s=new Array(i+1);while(a<t)s[o++]=r[a++];s[t]=n;while(a<i)s[++o]=r[a++];return s}var tc=class e{_tag=`EmptyNode`;modify(t,n,r,i,a,o){const s=r(N());if(In(s))return new e;++o.value;return new ac(t,i,a,s)}};function nc(e){return _e(e,`EmptyNode`)}function rc(e){return nc(e)||e._tag===`LeafNode`||e._tag===`CollisionNode`}function ic(e,t){return nc(e)?false:t===e.edit}var ac=class e{edit;hash;key;value;_tag=`LeafNode`;constructor(e,t,n,r){this.edit=e;this.hash=t;this.key=n;this.value=r}modify(t,n,r,i,a,o){if(w(a,this.key)){const n=r(this.value);if(n===this.value)return this;else if(In(n)){--o.value;return new tc}if(ic(this,t)){this.value=n;return this}return new e(t,i,a,n)}const s=r(N());if(In(s))return this;++o.value;return fc(t,n,this.hash,this,i,new e(t,i,a,s))}};var oc=class e{edit;hash;children;_tag=`CollisionNode`;constructor(e,t,n){this.edit=e;this.hash=t;this.children=n}modify(t,n,r,i,a,o){if(i===this.hash){const n=ic(this,t);const i=this.updateCollisionList(n,t,this.hash,this.children,r,a,o);if(i===this.children)return this;return i.length>1?new e(t,this.hash,i):i[0]}const s=r(N());if(In(s))return this;++o.value;return fc(t,n,this.hash,this,i,new ac(t,i,a,s))}updateCollisionList(e,t,n,r,i,a,o){const s=r.length;for(let c=0;c<s;++c){const s=r[c];if(`key`in s&&w(a,s.key)){const l=s.value;const u=i(l);if(u===l)return r;if(In(u)){--o.value;return $s(e,c,r)}return Qs(e,c,new ac(t,n,a,u),r)}}const c=i(N());if(In(c))return r;++o.value;return Qs(e,s,new ac(t,n,a,c),r)}};var sc=class e{edit;mask;children;_tag=`IndexedNode`;constructor(e,t,n){this.edit=e;this.mask=t;this.children=n}modify(t,n,r,i,a,o){const s=this.mask;const c=this.children;const l=Js(n,i);const u=Ys(l);const d=Xs(s,u);const f=s&u;const p=ic(this,t);if(!f){const f=new tc().modify(t,n+Hs,r,i,a,o);if(!f)return this;return c.length>=Gs?uc(t,l,f,s,c):new e(t,s|u,ec(p,d,f,c))}const m=c[d];const h=m.modify(t,n+Hs,r,i,a,o);if(m===h)return this;let g=s;let ee;if(nc(h)){g&=~u;if(!g)return new tc;if(c.length<=2&&rc(c[d^1]))return c[d^1];ee=$s(p,d,c)}else ee=Qs(p,d,h,c);if(p){this.mask=g;this.children=ee;return this}return new e(t,g,ee)}};var cc=class e{edit;size;children;_tag=`ArrayNode`;constructor(e,t,n){this.edit=e;this.size=t;this.children=n}modify(t,n,r,i,a,o){let s=this.size;const c=this.children;const l=Js(n,i);const u=c[l];const d=(u||new tc).modify(t,n+Hs,r,i,a,o);if(u===d)return this;const f=ic(this,t);let p;if(nc(u)&&!nc(d)){++s;p=Qs(f,l,d,c)}else if(!nc(u)&&nc(d)){--s;if(s<=Ks)return lc(t,s,l,c);p=Qs(f,l,new tc,c)}else p=Qs(f,l,d,c);if(f){this.size=s;this.children=p;return this}return new e(t,s,p)}};function lc(e,t,n,r){const i=new Array(t-1);let a=0;let o=0;for(let e=0,t=r.length;e<t;++e)if(e!==n){const t=r[e];if(t&&!nc(t)){i[a++]=t;o|=1<<e}}return new sc(e,o,i)}function uc(e,t,n,r,i){const a=[];let o=r;let s=0;for(let e=0;o;++e){if(o&1)a[e]=i[s++];o>>>=1}a[t]=n;return new cc(e,s+1,a)}function dc(e,t,n,r,i,a){if(n===i)return new oc(e,n,[a,r]);const o=Js(t,n);const s=Js(t,i);if(o===s)return t=>new sc(e,Ys(o)|Ys(s),[t]);else{const t=o<s?[r,a]:[a,r];return new sc(e,Ys(o)|Ys(s),t)}}function fc(e,t,n,r,i,a){let o=void 0;let s=t;while(true){const t=dc(e,s,n,r,i,a);if(typeof t===`function`){o=Zs(t,o);s=s+Hs}else{let e=t;while(o!=null){e=o.value(e);o=o.previous}return e}}}const pc=`effect/HashMap`;const mc=Symbol.for(pc);const hc={[mc]:mc,[Symbol.iterator](){return new _c(this,(e,t)=>[e,t])},[y](){let e=b(pc);for(const t of this)e^=c(b(t[0]),x(b(t[1])));return S(this,e)},[C](e){if(Tc(e)){if(e._size!==this._size)return false;for(const t of this){const n=c(e,Oc(t[0],b(t[0])));if(In(n))return false;else if(!w(t[1],n.value))return false}return true}return false},toString(){return D(this.toJSON())},toJSON(){return{_id:`HashMap`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const gc=(e,t,n,r)=>{const i=Object.create(hc);i._editable=e;i._edit=t;i._root=n;i._size=r;return i};var _c=class e{map;f;v;constructor(e,t){this.map=e;this.f=t;this.v=yc(this.map._root,this.f,void 0)}next(){if(In(this.v))return{done:true,value:void 0};const e=this.v.value;this.v=vc(e.cont);return{done:false,value:e.value}}[Symbol.iterator](){return new e(this.map,this.f)}};const vc=e=>e?bc(e[0],e[1],e[2],e[3],e[4]):N();const yc=(e,t,n=void 0)=>{switch(e._tag){case`LeafNode`:{if(F(e.value))return P({value:t(e.key,e.value.value),cont:n});return vc(n)}case`CollisionNode`:case`ArrayNode`:case`IndexedNode`:{const r=e.children;return bc(r.length,r,0,t,n)}default:return vc(n)}};const bc=(e,t,n,r,i)=>{while(n<e){const a=t[n++];if(a&&!nc(a))return yc(a,r,[e,t,n,r,i])}return vc(i)};const xc=gc(false,0,new tc,0);const Sc=()=>xc;const Cc=(...e)=>wc(e);const wc=e=>{const t=Bc(Sc());for(const n of e)Nc(t,n[0],n[1]);return Vc(t)};const Tc=e=>v(e,mc);const Ec=e=>e&&nc(e._root);const Dc=t(2,(e,t)=>Oc(e,t,b(t)));const Oc=t(3,(e,t,n)=>{let r=e._root;let i=0;while(true)switch(r._tag){case`LeafNode`:return w(t,r.key)?r.value:N();case`CollisionNode`:{if(n===r.hash){const e=r.children;for(let n=0,r=e.length;n<r;++n){const r=e[n];if(`key`in r&&w(t,r.key))return r.value}}return N()}case`IndexedNode`:{const e=Js(i,n);const t=Ys(e);if(r.mask&t){r=r.children[Xs(r.mask,t)];i+=Hs;break}return N()}case`ArrayNode`:{r=r.children[Js(i,n)];if(r){i+=Hs;break}return N()}default:return N()}});const kc=t(2,(e,t)=>{const n=Oc(e,t,b(t));if(In(n))throw new Error(`Expected map to contain key`);return n.value});const Ac=t(2,(e,t)=>F(Oc(e,t,b(t))));const jc=t(3,(e,t,n)=>F(Oc(e,t,n)));const Mc=t(2,(e,t)=>F(nl(e,t)));const Nc=t(3,(e,t,n)=>Uc(e,t,()=>P(n)));const Pc=t(3,(e,t,n)=>{if(e._editable){e._root=t;e._size=n;return e}return t===e._root?e:gc(e._editable,e._edit,t,n)});const Fc=e=>new _c(e,e=>e);const Ic=e=>new _c(e,(e,t)=>t);const Lc=e=>new _c(e,(e,t)=>[e,t]);const Rc=e=>e._size;const zc=t(2,(e,t)=>{let n=0;for(const[r,i]of e)if(t(i,r))n++;return n});const Bc=e=>gc(true,e._edit+1,e._root,e._size);const Vc=e=>{e._editable=false;return e};const Hc=t(2,(e,t)=>{const n=Bc(e);t(n);return Vc(n)});const Uc=t(3,(e,t,n)=>Wc(e,t,b(t),n));const Wc=t(4,(e,t,n,r)=>{const i={value:e._size};const a=e._root.modify(e._editable?e._edit:NaN,0,r,n,t,i);return c(e,Pc(a,i.value))});const Gc=t(3,(e,t,n)=>Uc(e,t,Jn(n)));const Kc=t(2,(e,t)=>{const n=Bc(e);Zc(t,(e,t)=>Nc(n,t,e));return Vc(n)});const qc=t(2,(e,t)=>Uc(e,t,N));const Jc=t(2,(e,t)=>Hc(e,e=>{for(const n of t)qc(n)(e)}));const Yc=t(2,(e,t)=>Qc(e,Sc(),(e,n,r)=>Nc(e,r,t(n,r))));const Xc=t(2,(e,t)=>Qc(e,Sc(),(e,n,r)=>Hc(e,e=>Zc(t(n,r),(t,n)=>Nc(e,n,t)))));const Zc=t(2,(e,t)=>Qc(e,void 0,(e,n,r)=>t(n,r)));const Qc=t(3,(e,t,n)=>{const r=e._root;if(r._tag===`LeafNode`)return F(r.value)?n(t,r.value.value,r.key):t;if(r._tag===`EmptyNode`)return t;const i=[r.children];let a;while(a=i.pop())for(let e=0,r=a.length;e<r;){const r=a[e++];if(r&&!nc(r))if(r._tag===`LeafNode`){if(F(r.value))t=n(t,r.value.value,r.key)}else i.push(r.children)}return t});const $c=t(2,(e,t)=>Hc(Sc(),n=>{for(const[r,i]of e)if(t(i,r))Nc(n,r,i)}));const el=e=>tl(e,n);const tl=t(2,(e,t)=>Hc(Sc(),n=>{for(const[r,i]of e){const e=t(i,r);if(F(e))Nc(n,r,e.value)}}));const nl=t(2,(e,t)=>{for(const n of e)if(t(n[1],n[0]))return P(n);return N()});const rl=t(2,(e,t)=>{for(const n of e)if(t(n[1],n[0]))return true;return false});const il=t(2,(e,t)=>!rl(e,(e,n)=>!t(e,n)));const al=`effect/HashSet`;const ol=Symbol.for(al);const sl={[ol]:ol,[Symbol.iterator](){return Fc(this._keyMap)},[y](){return S(this,x(b(this._keyMap))(b(al)))},[C](e){if(ll(e))return Rc(this._keyMap)===Rc(e._keyMap)&&w(this._keyMap,e._keyMap);return false},toString(){return D(this.toJSON())},toJSON(){return{_id:`HashSet`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const cl=e=>{const t=Object.create(sl);t._keyMap=e;return t};const ll=e=>v(e,ol);const ul=cl(Sc());const dl=()=>ul;const fl=e=>{const t=bl(dl());for(const n of e)Cl(t,n);return xl(t)};const pl=(...e)=>{const t=bl(dl());for(const n of e)Cl(t,n);return xl(t)};const ml=t(2,(e,t)=>Ac(e._keyMap,t));const hl=t(2,(e,t)=>{let n=false;for(const r of e){n=t(r);if(n)break}return n});const gl=t(2,(e,t)=>!hl(e,e=>!t(e)));const _l=t(2,(e,t)=>gl(e,e=>ml(t,e)));const vl=e=>Fc(e._keyMap);const yl=e=>Rc(e._keyMap);const bl=e=>cl(Bc(e._keyMap));const xl=e=>{e._keyMap._editable=false;return e};const Sl=t(2,(e,t)=>{const n=bl(e);t(n);return xl(n)});const Cl=t(2,(e,t)=>e._keyMap._editable?(Nc(t,true)(e._keyMap),e):cl(Nc(t,true)(e._keyMap)));const wl=t(2,(e,t)=>e._keyMap._editable?(qc(t)(e._keyMap),e):cl(qc(t)(e._keyMap)));const Tl=t(2,(e,t)=>Sl(e,e=>{for(const n of t)wl(e,n)}));const El=t(2,(e,t)=>Sl(dl(),n=>{for(const r of t)if(ml(r)(e))Cl(r)(n)}));const Dl=t(2,(e,t)=>Sl(dl(),n=>{jl(e,e=>Cl(n,e));for(const e of t)Cl(n,e)}));const Ol=t(2,(e,t)=>ml(e,t)?wl(e,t):Cl(e,t));const kl=t(2,(e,t)=>Sl(dl(),n=>{jl(e,e=>{const r=t(e);if(!ml(n,r))Cl(n,r)})}));const Al=t(2,(e,t)=>Sl(dl(),n=>{jl(e,e=>{for(const r of t(e))if(!ml(n,r))Cl(n,r)})}));const jl=t(2,(e,t)=>Zc(e._keyMap,(e,n)=>t(n)));const Ml=t(3,(e,t,n)=>Qc(e._keyMap,t,(e,t,r)=>n(e,r)));const Nl=t(2,(e,t)=>{return Sl(dl(),n=>{const r=vl(e);let i;while(!(i=r.next()).done){const e=i.value;if(t(e))Cl(n,e)}})});const Pl=t(2,(e,t)=>{const n=vl(e);let r;const i=bl(dl());const a=bl(dl());while(!(r=n.next()).done){const e=r.value;if(t(e))Cl(i,e);else Cl(a,e)}return[xl(a),xl(i)]});const Fl=ol;const Il=ll;const Ll=dl;const Rl=fl;const zl=pl;const Bl=ml;const Vl=hl;const Hl=gl;const Ul=_l;const Wl=vl;const Gl=yl;const Kl=bl;const ql=xl;const Jl=Sl;const Yl=Cl;const Xl=wl;const Zl=Tl;const Ql=El;const $l=Dl;const eu=Ol;const tu=kl;const nu=Al;const ru=jl;const iu=Ml;const au=Nl;const ou=Pl;const su=`Die`;const cu=`Empty`;const lu=`Fail`;const uu=`Interrupt`;const du=`Parallel`;const fu=`Sequential`;const pu=`effect/Cause`;const mu=Symbol.for(pu);const hu={_E:e=>e};const gu={[mu]:hu,[y](){return c(b(pu),x(b(Uu(this))),S(this))},[C](e){return Cu(e)&&Hu(this,e)},pipe(){return O(this,arguments)},toJSON(){switch(this._tag){case`Empty`:return{_id:`Cause`,_tag:this._tag};case`Die`:return{_id:`Cause`,_tag:this._tag,defect:E(this.defect)};case`Interrupt`:return{_id:`Cause`,_tag:this._tag,fiberId:this.fiberId.toJSON()};case`Fail`:return{_id:`Cause`,_tag:this._tag,failure:E(this.error)};case`Sequential`:case`Parallel`:return{_id:`Cause`,_tag:this._tag,left:E(this.left),right:E(this.right)}}},toString(){return $u(this)},[T](){return this.toJSON()}};const _u=(()=>{const e=Object.create(gu);e._tag=cu;return e})();const vu=e=>{const t=Object.create(gu);t._tag=lu;t.error=e;return t};const yu=e=>{const t=Object.create(gu);t._tag=su;t.defect=e;return t};const bu=e=>{const t=Object.create(gu);t._tag=uu;t.fiberId=e;return t};const xu=(e,t)=>{const n=Object.create(gu);n._tag=du;n.left=e;n.right=t;return n};const Su=(e,t)=>{const n=Object.create(gu);n._tag=fu;n.left=e;n.right=t;return n};const Cu=e=>v(e,mu);const wu=e=>e._tag===cu;const Tu=e=>e._tag===su;const Eu=e=>{if(e._tag===cu)return true;return Zu(e,true,(e,t)=>{switch(t._tag){case cu:return P(e);case su:case lu:case uu:return P(false);default:return N()}})};const Du=e=>F(Pu(e));const Ou=e=>Qu(void 0,qu)(e);const ku=e=>bs(Zu(e,fs(),(e,t)=>t._tag===lu?P(c(e,L(t.error))):N()));const Au=e=>bs(Zu(e,fs(),(e,t)=>t._tag===su?P(c(e,L(t.defect))):N()));const ju=e=>Zu(e,Ll(),(e,t)=>t._tag===uu?P(c(e,Yl(t.fiberId))):N());const Mu=e=>Gu(e,e=>e._tag===lu?P(e.error):N());const Nu=e=>{const t=Mu(e);switch(t._tag){case`None`:return j(e);case`Some`:return M(t.value)}};const Pu=e=>Gu(e,e=>e._tag===uu?P(e.fiberId):N());const Fu=e=>Xu(e,{onEmpty:N(),onFail:()=>N(),onDie:e=>P(yu(e)),onInterrupt:()=>N(),onSequential:nr(Su),onParallel:nr(xu)});const Iu=e=>Xu(e,{onEmpty:N(),onFail:e=>P(yu(e)),onDie:e=>P(yu(e)),onInterrupt:()=>N(),onSequential:nr(Su),onParallel:nr(xu)});const Lu=e=>Xu(e,{onEmpty:_u,onFail:()=>_u,onDie:yu,onInterrupt:bu,onSequential:Su,onParallel:xu});const Ru=e=>Xu(e,{onEmpty:_u,onFail:yu,onDie:yu,onInterrupt:bu,onSequential:Su,onParallel:xu});const zu=t(2,(e,t)=>Bu(e,e=>vu(t(e))));const Bu=t(2,(e,t)=>Xu(e,{onEmpty:_u,onFail:e=>t(e),onDie:e=>yu(e),onInterrupt:e=>bu(e),onSequential:(e,t)=>Su(e,t),onParallel:(e,t)=>xu(e,t)}));const Vu=e=>Bu(e,n);const Hu=(e,t)=>{let n=ms(e);let r=ms(t);while(ks(n)&&ks(r)){const[e,t]=c(R(n),Zu([Ll(),fs()],([e,t],n)=>{const[r,i]=Ku(n);return P([c(e,$l(r)),c(t,Ds(i))])}));const[i,a]=c(R(r),Zu([Ll(),fs()],([e,t],n)=>{const[r,i]=Ku(n);return P([c(e,$l(r)),c(t,Ds(i))])}));if(!w(e,i))return false;n=t;r=a}return true};const Uu=e=>{return Wu(ms(e),fs())};const Wu=(e,t)=>{while(1){const[n,r]=c(e,oi([Ll(),fs()],([e,t],n)=>{const[r,i]=Ku(n);return[c(e,$l(r)),c(t,Ds(i))]}));const i=Gl(n)>0?c(t,L(n)):t;if(Os(r))return bs(i);e=r;t=i}throw new Error(Ee(`Cause.flattenCauseLoop`))};const Gu=t(2,(e,t)=>{const n=[e];while(n.length>0){const e=n.pop();const r=t(e);switch(r._tag){case`None`:{switch(e._tag){case fu:case du:{n.push(e.right);n.push(e.left);break}}break}case`Some`:return r}}return N()});const Ku=e=>{let t=e;const n=[];let r=Ll();let i=fs();while(t!==void 0)switch(t._tag){case cu:{if(n.length===0)return[r,i];t=n.pop();break}case lu:{r=Yl(r,ps(t._tag,t.error));if(n.length===0)return[r,i];t=n.pop();break}case su:{r=Yl(r,ps(t._tag,t.defect));if(n.length===0)return[r,i];t=n.pop();break}case uu:{r=Yl(r,ps(t._tag,t.fiberId));if(n.length===0)return[r,i];t=n.pop();break}case fu:{switch(t.left._tag){case cu:{t=t.right;break}case fu:{t=Su(t.left.left,Su(t.left.right,t.right));break}case du:{t=xu(Su(t.left.left,t.right),Su(t.left.right,t.right));break}default:{i=L(i,t.right);t=t.left;break}}break}case du:{n.push(t.right);t=t.left;break}}throw new Error(Ee(`Cause.evaluateCauseLoop`))};const qu={emptyCase:i,failCase:a,dieCase:a,interruptCase:i,sequentialCase:(e,t,n)=>t&&n,parallelCase:(e,t,n)=>t&&n};const Ju=`SequentialCase`;const Yu=`ParallelCase`;const Xu=t(2,(e,{onDie:t,onEmpty:n,onFail:r,onInterrupt:i,onParallel:a,onSequential:o})=>{return Qu(e,void 0,{emptyCase:()=>n,failCase:(e,t)=>r(t),dieCase:(e,n)=>t(n),interruptCase:(e,t)=>i(t),sequentialCase:(e,t,n)=>o(t,n),parallelCase:(e,t,n)=>a(t,n)})});const Zu=t(3,(e,t,n)=>{let r=t;let i=e;const a=[];while(i!==void 0){const e=n(r,i);r=F(e)?e.value:r;switch(i._tag){case fu:{a.push(i.right);i=i.left;break}case du:{a.push(i.right);i=i.left;break}default:{i=void 0;break}}if(i===void 0&&a.length>0)i=a.pop()}return r});const Qu=t(3,(e,t,n)=>{const r=[e];const i=[];while(r.length>0){const e=r.pop();switch(e._tag){case cu:{i.push(j(n.emptyCase(t)));break}case lu:{i.push(j(n.failCase(t,e.error)));break}case su:{i.push(j(n.dieCase(t,e.defect)));break}case uu:{i.push(j(n.interruptCase(t,e.fiberId)));break}case fu:{r.push(e.right);r.push(e.left);i.push(M({_tag:Ju}));break}case du:{r.push(e.right);r.push(e.left);i.push(M({_tag:Yu}));break}}}const a=[];while(i.length>0){const e=i.pop();switch(e._tag){case`Left`:{switch(e.left._tag){case Ju:{const e=a.pop();const r=a.pop();const i=n.sequentialCase(t,e,r);a.push(i);break}case Yu:{const e=a.pop();const r=a.pop();const i=n.parallelCase(t,e,r);a.push(i);break}}break}case`Right`:{a.push(e.right);break}}}if(a.length===0)throw new Error(`BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues`);return a.pop()});const $u=(e,t)=>{if(Ou(e))return`All fibers interrupted without errors.`;return sd(e).map(function(e){if(t?.renderErrorCause!==true||e.cause===void 0)return e.stack;return`${e.stack} {\n${ed(e.cause,`  `)}\n}`}).join(`
`)};const ed=(e,t)=>{const n=e.stack.split(`
`);let r=`${t}[cause]: ${n[0]}`;for(let e=1,i=n.length;e<i;e++)r+=`\n${t}${n[e]}`;if(e.cause)r+=` {\n${ed(e.cause,`${t}  `)}\n${t}}`;return r};var td=class e extends globalThis.Error{span=void 0;constructor(t){const n=typeof t===`object`&&t!==null;const r=Error.stackTraceLimit;Error.stackTraceLimit=1;super(nd(t),n&&`cause`in t&&typeof t.cause!==`undefined`?{cause:new e(t.cause)}:void 0);if(this.message===``)this.message=`An error has occurred`;Error.stackTraceLimit=r;this.name=t instanceof Error?t.name:`Error`;if(n){if(od in t)this.span=t[od];Object.keys(t).forEach(e=>{if(!(e in this))this[e]=t[e]})}this.stack=ad(`${this.name}: ${this.message}`,t instanceof Error&&t.stack?t.stack:``,this.span)}};const nd=e=>{if(typeof e===`string`)return e;if(typeof e===`object`&&e!==null&&e instanceof Error)return e.message;try{if(v(e,`toString`)&&fe(e[`toString`])&&e[`toString`]!==Object.prototype.toString&&e[`toString`]!==globalThis.Array.prototype.toString)return e[`toString`]()}catch{}return lt(e)};const rd=/\((.*)\)/g;const id=_(`effect/Tracer/spanToTrace`,()=>new WeakMap);const ad=(e,t,n)=>{const r=[e];const i=t.startsWith(e)?t.slice(e.length).split(`
`):t.split(`
`);for(let e=1;e<i.length;e++){if(i[e].includes(` at new BaseEffectError`)||i[e].includes(` at new YieldableError`)){e++;continue}if(i[e].includes(`Generator.next`))break;if(i[e].includes(`effect_internal_function`))break;r.push(i[e].replace(/at .*effect_instruction_i.*\((.*)\)/,`at $1`).replace(/EffectPrimitive\.\w+/,`<anonymous>`))}if(n){let e=n;let t=0;while(e&&e._tag===`Span`&&t<10){const n=id.get(e);if(typeof n===`function`){const t=n();if(typeof t===`string`){const n=t.matchAll(rd);let i=false;for(const[,t]of n){i=true;r.push(`    at ${e.name} (${t})`)}if(!i)r.push(`    at ${e.name} (${t.replace(/^at /,``)})`)}else r.push(`    at ${e.name}`)}else r.push(`    at ${e.name}`);e=Wn(e.parent);t++}}return r.join(`
`)};const od=Symbol.for(`effect/SpanAnnotation`);const sd=e=>Qu(e,void 0,{emptyCase:()=>[],dieCase:(e,t)=>{return[new td(t)]},failCase:(e,t)=>{return[new td(t)]},interruptCase:()=>[],parallelCase:(e,t,n)=>[...t,...n],sequentialCase:(e,t,n)=>[...t,...n]});const cd=Symbol.for(`effect/Context/Tag`);const ld=Symbol.for(`effect/Context/Reference`);const ud=`effect/STM`;const dd=Symbol.for(ud);const fd={...Lt,_op:`Tag`,[dd]:Pt,[cd]:{_Service:e=>e,_Identifier:e=>e},toString(){return D(this.toJSON())},toJSON(){return{_id:`Tag`,key:this.key,stack:this.stack}},[T](){return this.toJSON()},of(e){return e},context(e){return Ed(this,e)}};const pd={...fd,[ld]:ld};const md=e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=2;const n=new Error;Error.stackTraceLimit=t;const r=Object.create(fd);Object.defineProperty(r,`stack`,{get(){return n.stack}});r.key=e;return r};const hd=e=>()=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=2;const n=new Error;Error.stackTraceLimit=t;function r(){}Object.setPrototypeOf(r,fd);r.key=e;Object.defineProperty(r,`stack`,{get(){return n.stack}});return r};const gd=()=>(e,t)=>{const n=Error.stackTraceLimit;Error.stackTraceLimit=2;const r=new Error;Error.stackTraceLimit=n;function i(){}Object.setPrototypeOf(i,pd);i.key=e;i.defaultValue=t.defaultValue;Object.defineProperty(i,`stack`,{get(){return r.stack}});return i};const _d=Symbol.for(`effect/Context`);const vd={[_d]:{_Services:e=>e},[C](e){if(xd(e)){if(this.unsafeMap.size===e.unsafeMap.size){for(const t of this.unsafeMap.keys())if(!e.unsafeMap.has(t)||!w(this.unsafeMap.get(t),e.unsafeMap.get(t)))return false;return true}}return false},[y](){return S(this,Qe(this.unsafeMap.size))},pipe(){return O(this,arguments)},toString(){return D(this.toJSON())},toJSON(){return{_id:`Context`,services:Array.from(this.unsafeMap).map(E)}},[T](){return this.toJSON()}};const yd=e=>{const t=Object.create(vd);t.unsafeMap=e;return t};const bd=e=>{const t=new Error(`Service not found${e.key?`: ${String(e.key)}`:``}`);if(e.stack){const n=e.stack.split(`
`);if(n.length>2){const e=n[2].match(/at (.*)/);if(e)t.message=t.message+` (defined at ${e[1]})`}}if(t.stack){const e=t.stack.split(`
`);e.splice(1,3);t.stack=e.join(`
`)}return t};const xd=e=>v(e,_d);const Sd=e=>v(e,cd);const Cd=e=>v(e,ld);const wd=yd(new Map);const Td=()=>wd;const Ed=(e,t)=>yd(new Map([[e.key,t]]));const Dd=t(3,(e,t,n)=>{const r=new Map(e.unsafeMap);r.set(t.key,n);return yd(r)});const Od=_(`effect/Context/defaultValueCache`,()=>new Map);const kd=e=>{if(Od.has(e.key))return Od.get(e.key);const t=e.defaultValue();Od.set(e.key,t);return t};const Ad=(e,t)=>{return e.unsafeMap.has(t.key)?e.unsafeMap.get(t.key):kd(t)};const jd=t(2,(e,t)=>{if(!e.unsafeMap.has(t.key)){if(ld in t)return kd(t);throw bd(t)}return e.unsafeMap.get(t.key)});const Md=jd;const Nd=t(3,(e,t,n)=>{if(!e.unsafeMap.has(t.key))return Cd(t)?kd(t):n();return e.unsafeMap.get(t.key)});const Pd=t(2,(e,t)=>{if(!e.unsafeMap.has(t.key))return Cd(t)?Qt(kd(t)):Zt;return Qt(e.unsafeMap.get(t.key))});const Fd=t(2,(e,t)=>{const n=new Map(e.unsafeMap);for(const[e,r]of t.unsafeMap)n.set(e,r);return yd(n)});const Id=(...e)=>{const t=new Map;for(const n of e)for(const[e,r]of n.unsafeMap)t.set(e,r);return yd(t)};const Ld=(...e)=>t=>{const n=new Set(e.map(e=>e.key));const r=new Map;for(const[e,i]of t.unsafeMap.entries())if(n.has(e))r.set(e,i);return yd(r)};const Rd=(...e)=>t=>{const n=new Map(t.unsafeMap);for(const t of e)n.delete(t.key);return yd(n)};const zd=cd;const Bd=ld;const Vd=md;const Hd=_d;const Ud=yd;const Wd=xd;const Gd=Sd;const Kd=Cd;const qd=Td;const Jd=Ed;const Yd=Dd;const Xd=Md;const Zd=Nd;const Qd=jd;const $d=Pd;const ef=Fd;const tf=Id;const nf=Ld;const rf=Rd;const af=hd;const sf=gd;const cf=Symbol.for(`effect/Duration`);const lf=BigInt(0);const uf=BigInt(24);const df=BigInt(60);const ff=BigInt(1e3);const pf=BigInt(1e6);const mf=BigInt(1e9);const hf=/^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;const gf=e=>{if(xf(e))return e;else if(ce(e))return Df(e);else if(ue(e))return Tf(e);else if(Array.isArray(e)&&e.length===2&&e.every(ce)){if(e[0]===-1/0||e[1]===-1/0||Number.isNaN(e[0])||Number.isNaN(e[1]))return Cf;if(e[0]===1/0||e[1]===1/0)return wf;return Tf(BigInt(Math.round(e[0]*1e9))+BigInt(Math.round(e[1])))}else if(se(e)){const t=hf.exec(e);if(t){const[e,n,r]=t;const i=Number(n);switch(r){case`nano`:case`nanos`:return Tf(BigInt(n));case`micro`:case`micros`:return Ef(BigInt(n));case`milli`:case`millis`:return Df(i);case`second`:case`seconds`:return Of(i);case`minute`:case`minutes`:return kf(i);case`hour`:case`hours`:return Af(i);case`day`:case`days`:return jf(i);case`week`:case`weeks`:return Mf(i)}}}throw new Error(`Invalid DurationInput`)};const _f={_tag:`Millis`,millis:0};const vf={_tag:`Infinity`};const yf={[cf]:cf,[y](){return S(this,tt(this.value))},[C](e){return xf(e)&&Vf(this,e)},toString(){return`Duration(${Uf(this)})`},toJSON(){switch(this.value._tag){case`Millis`:return{_id:`Duration`,_tag:`Millis`,millis:this.value.millis};case`Nanos`:return{_id:`Duration`,_tag:`Nanos`,hrtime:Ff(this)};case`Infinity`:return{_id:`Duration`,_tag:`Infinity`}}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const bf=e=>{const t=Object.create(yf);if(ce(e))if(isNaN(e)||e<=0)t.value=_f;else if(!Number.isFinite(e))t.value=vf;else if(!Number.isInteger(e))t.value={_tag:`Nanos`,nanos:BigInt(Math.round(e*1e6))};else t.value={_tag:`Millis`,millis:e};else if(e<=lf)t.value=_f;else t.value={_tag:`Nanos`,nanos:e};return t};const xf=e=>v(e,cf);const Sf=e=>{switch(e.value._tag){case`Millis`:return e.value.millis===0;case`Nanos`:return e.value.nanos===lf;case`Infinity`:return false}};const Cf=bf(0);const wf=bf(1/0);const Tf=e=>bf(e);const Ef=e=>bf(e*ff);const Df=e=>bf(e);const Of=e=>bf(e*1e3);const kf=e=>bf(e*6e4);const Af=e=>bf(e*36e5);const jf=e=>bf(e*864e5);const Mf=e=>bf(e*6048e5);const Nf=e=>If(e,{onMillis:e=>e,onNanos:e=>Number(e)/1e6});const Pf=e=>{const t=gf(e);switch(t.value._tag){case`Infinity`:throw new Error(`Cannot convert infinite duration to nanos`);case`Nanos`:return t.value.nanos;case`Millis`:return BigInt(Math.round(t.value.millis*1e6))}};const Ff=e=>{const t=gf(e);switch(t.value._tag){case`Infinity`:return[1/0,0];case`Nanos`:return[Number(t.value.nanos/mf),Number(t.value.nanos%mf)];case`Millis`:return[Math.floor(t.value.millis/1e3),Math.round(t.value.millis%1e3*1e6)]}};const If=t(2,(e,t)=>{const n=gf(e);switch(n.value._tag){case`Nanos`:return t.onNanos(n.value.nanos);case`Infinity`:return t.onMillis(1/0);case`Millis`:return t.onMillis(n.value.millis)}});const Lf=t(3,(e,t,n)=>{const r=gf(e);const i=gf(t);if(r.value._tag===`Infinity`||i.value._tag===`Infinity`)return n.onMillis(Nf(r),Nf(i));else if(r.value._tag===`Nanos`||i.value._tag===`Nanos`){const e=r.value._tag===`Nanos`?r.value.nanos:BigInt(Math.round(r.value.millis*1e6));const t=i.value._tag===`Nanos`?i.value.nanos:BigInt(Math.round(i.value.millis*1e6));return n.onNanos(e,t)}return n.onMillis(r.value.millis,i.value.millis)});const Rf=(e,t)=>Lf(e,t,{onMillis:(e,t)=>e===t,onNanos:(e,t)=>e===t});const zf=t(2,(e,t)=>Lf(e,t,{onMillis:(e,t)=>e<=t,onNanos:(e,t)=>e<=t}));const Bf=t(2,(e,t)=>Lf(e,t,{onMillis:(e,t)=>e>=t,onNanos:(e,t)=>e>=t}));const Vf=t(2,(e,t)=>Rf(gf(e),gf(t)));const Hf=e=>{const t=gf(e);if(t.value._tag===`Infinity`)return{days:1/0,hours:1/0,minutes:1/0,seconds:1/0,millis:1/0,nanos:1/0};const n=Pf(t);const r=n/pf;const i=r/ff;const a=i/df;const o=a/df;const s=o/uf;return{days:Number(s),hours:Number(o%uf),minutes:Number(a%df),seconds:Number(i%df),millis:Number(r%ff),nanos:Number(n%pf)}};const Uf=e=>{const t=gf(e);if(t.value._tag===`Infinity`)return`Infinity`;if(Sf(t))return`0`;const n=Hf(t);const r=[];if(n.days!==0)r.push(`${n.days}d`);if(n.hours!==0)r.push(`${n.hours}h`);if(n.minutes!==0)r.push(`${n.minutes}m`);if(n.seconds!==0)r.push(`${n.seconds}s`);if(n.millis!==0)r.push(`${n.millis}ms`);if(n.nanos!==0)r.push(`${n.nanos}ns`);return r.join(` `)};const Wf=Symbol.for(`effect/MutableRef`);const Gf={[Wf]:Wf,toString(){return D(this.toJSON())},toJSON(){return{_id:`MutableRef`,current:E(this.current)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const Kf=e=>{const t=Object.create(Gf);t.current=e;return t};const qf=t(3,(e,t,n)=>{if(w(t,e.current)){e.current=n;return true}return false});const Jf=e=>e.current;const Yf=t(2,(e,t)=>{e.current=t;return e});const Xf=`effect/FiberId`;const Zf=Symbol.for(Xf);const Qf=`None`;const $f=`Runtime`;const ep=`Composite`;const tp=$e(`${Xf}-${Qf}`);var np=class{[Zf]=Zf;_tag=Qf;id=-1;startTimeMillis=-1;[y](){return tp}[C](e){return cp(e)&&e._tag===Qf}toString(){return D(this.toJSON())}toJSON(){return{_id:`FiberId`,_tag:this._tag}}[T](){return this.toJSON()}};var rp=class{id;startTimeMillis;[Zf]=Zf;_tag=$f;constructor(e,t){this.id=e;this.startTimeMillis=t}[y](){return S(this,$e(`${Xf}-${this._tag}-${this.id}-${this.startTimeMillis}`))}[C](e){return cp(e)&&e._tag===$f&&this.id===e.id&&this.startTimeMillis===e.startTimeMillis}toString(){return D(this.toJSON())}toJSON(){return{_id:`FiberId`,_tag:this._tag,id:this.id,startTimeMillis:this.startTimeMillis}}[T](){return this.toJSON()}};var ip=class{left;right;[Zf]=Zf;_tag=ep;constructor(e,t){this.left=e;this.right=t}_hash;[y](){return c($e(`${Xf}-${this._tag}`),x(b(this.left)),x(b(this.right)),S(this))}[C](e){return cp(e)&&e._tag===ep&&w(this.left,e.left)&&w(this.right,e.right)}toString(){return D(this.toJSON())}toJSON(){return{_id:`FiberId`,_tag:this._tag,left:E(this.left),right:E(this.right)}}[T](){return this.toJSON()}};const ap=new np;const op=(e,t)=>{return new rp(e,t)};const sp=(e,t)=>{return new ip(e,t)};const cp=e=>v(e,Zf);const lp=e=>{return e._tag===Qf||c(bp(e),Hl(e=>lp(e)))};const up=e=>{return e._tag===$f};const dp=e=>{return e._tag===ep};const fp=t(2,(e,t)=>{if(e._tag===Qf)return t;if(t._tag===Qf)return e;return new ip(e,t)});const pp=e=>{return c(e,iu(ap,(e,t)=>fp(t)(e)))};const mp=t(2,(e,t)=>lp(e)?t:e);const hp=e=>{switch(e._tag){case Qf:return Ll();case $f:return zl(e.id);case ep:return c(hp(e.left),$l(hp(e.right)))}};const gp=_(Symbol.for(`effect/Fiber/Id/_fiberCounter`),()=>Kf(0));const _p=(e,t)=>{return new rp(e,t)};const vp=e=>{const t=Array.from(hp(e)).map(e=>`#${e}`).join(`,`);return t};const yp=e=>{const t=bp(e);if(Gl(t)===0)return N();let n=true;let r;for(const e of t)if(n){r=e;n=false}else r=c(r,fp(e));return P(r)};const bp=e=>{switch(e._tag){case Qf:return Ll();case $f:return zl(e);case ep:return c(bp(e.left),$l(bp(e.right)))}};const xp=()=>{const e=Jf(gp);c(gp,Yf(e+1));return new rp(e,Date.now())};const Sp=Zf;const Cp=ap;const wp=op;const Tp=sp;const Ep=cp;const Dp=lp;const Op=up;const kp=dp;const Ap=fp;const jp=pp;const Mp=mp;const Np=hp;const Pp=_p;const Fp=vp;const Ip=yp;const Lp=bp;const Rp=xp;function zp(e){return cl(e)}const Bp=mc;const Vp=Tc;const Hp=Sc;const Up=Cc;const Wp=wc;const Gp=Ec;const Kp=Dc;const qp=Oc;const Jp=kc;const Yp=Ac;const Xp=jc;const Zp=Mc;const Qp=Nc;const $p=Fc;const em=zp;const tm=Ic;const nm=Lc;const rm=Rc;const im=zc;const am=Bc;const om=Vc;const sm=Hc;const cm=Uc;const lm=Wc;const um=Gc;const dm=Kc;const fm=qc;const pm=Jc;const mm=Yc;const hm=Xc;const gm=Zc;const _m=Qc;const vm=$c;const ym=el;const bm=tl;const xm=nl;const Sm=rl;const Cm=il;const wm=Symbol.for(`effect/List`);const Tm=e=>I(e);const Em=e=>m(ui(e),Tm);const Dm=Em(w);const Om={[wm]:wm,_tag:`Cons`,toString(){return D(this.toJSON())},toJSON(){return{_id:`List`,_tag:`Cons`,values:Tm(this).map(E)}},[T](){return this.toJSON()},[C](e){return Nm(e)&&this._tag===e._tag&&Dm(this,e)},[y](){return S(this,nt(Tm(this)))},[Symbol.iterator](){let e=false;let t=this;return{next(){if(e)return this.return();if(t._tag===`Nil`){e=true;return this.return()}const n=t.head;t=t.tail;return{done:e,value:n}},return(t){if(!e)e=true;return{done:true,value:t}}}},pipe(){return O(this,arguments)}};const km=(e,t)=>{const n=Object.create(Om);n.head=e;n.tail=t;return n};const Am=$e(`Nil`);const jm={[wm]:wm,_tag:`Nil`,toString(){return D(this.toJSON())},toJSON(){return{_id:`List`,_tag:`Nil`}},[T](){return this.toJSON()},[y](){return Am},[C](e){return Nm(e)&&this._tag===e._tag},[Symbol.iterator](){return{next(){return{done:true,value:void 0}}}},pipe(){return O(this,arguments)}};const Mm=Object.create(jm);const Nm=e=>v(e,wm);const Pm=e=>e._tag===`Nil`;const Fm=e=>e._tag===`Cons`;const Im=()=>Mm;const Lm=(e,t)=>km(e,t);const Rm=Im;const zm=e=>km(e,Mm);const Bm=t(2,(e,t)=>Hm(t,e));const Vm=t(2,(e,t)=>Lm(t,e));const Hm=t(2,(e,t)=>{if(Pm(e))return t;else if(Pm(t))return e;else{const n=km(t.head,e);let r=n;let i=t.tail;while(!Pm(i)){const t=km(i.head,e);r.tail=t;r=t;i=i.tail}return n}});const Um=t(3,(e,t,n)=>{let r=t;let i=e;while(!Pm(i)){r=n(r,i.head);i=i.tail}return r});const Wm=e=>{let t=Rm();let n=e;while(!Pm(n)){t=Vm(t,n.head);n=n.tail}return t};const Gm=Object.assign(Object.create(Array.prototype),{[y](){return S(this,nt(this))},[C](e){if(Array.isArray(e)&&this.length===e.length)return this.every((t,n)=>w(t,e[n]));else return false}});const Km=function(){function e(e){if(e)Object.assign(this,e)}e.prototype=Rt;return e}();const qm=e=>Object.assign(Object.create(Rt),e);const Jm=Symbol.for(`effect/DifferChunkPatch`);function Ym(e){return e}const Xm={...Km.prototype,[Jm]:{_Value:Ym,_Patch:Ym}};const Zm=Object.assign(Object.create(Xm),{_tag:`Empty`});const Qm=Object.create(Zm);const $m=()=>Qm;const eh=Object.assign(Object.create(Xm),{_tag:`AndThen`});const th=(e,t)=>{const n=Object.create(eh);n.first=e;n.second=t;return n};const nh=Object.assign(Object.create(Xm),{_tag:`Append`});const rh=e=>{const t=Object.create(nh);t.values=e;return t};const ih=Object.assign(Object.create(Xm),{_tag:`Slice`});const ah=(e,t)=>{const n=Object.create(ih);n.from=e;n.until=t;return n};const oh=Object.assign(Object.create(Xm),{_tag:`Update`});const sh=(e,t)=>{const n=Object.create(oh);n.index=e;n.patch=t;return n};const ch=e=>{let t=0;let n=$m();while(t<e.oldValue.length&&t<e.newValue.length){const r=ws(t)(e.oldValue);const i=ws(t)(e.newValue);const a=e.differ.diff(r,i);if(!w(a,e.differ.empty))n=c(n,lh(sh(t,a)));t=t+1}if(t<e.oldValue.length)n=c(n,lh(ah(0,t)));if(t<e.newValue.length)n=c(n,lh(rh(Es(t)(e.newValue))));return n};const lh=t(2,(e,t)=>th(e,t));const uh=t(3,(e,t,n)=>{if(e._tag===`Empty`)return t;let r=t;let i=ms(e);while(ks(i)){const e=R(i);const t=Ms(i);switch(e._tag){case`Empty`:{i=t;break}case`AndThen`:{i=L(e.first)(L(e.second)(t));break}case`Append`:{r=Ds(e.values)(r);i=t;break}case`Slice`:{const n=vs(r);r=Ss(n.slice(e.from,e.until));i=t;break}case`Update`:{const a=vs(r);a[e.index]=n.patch(e.patch,a[e.index]);r=Ss(a);i=t;break}}}return r});const dh=Symbol.for(`effect/DifferContextPatch`);function fh(e){return e}const ph={...Km.prototype,[dh]:{_Value:fh,_Patch:fh}};const mh=Object.assign(Object.create(ph),{_tag:`Empty`});const hh=Object.create(mh);const gh=()=>hh;const _h=Object.assign(Object.create(ph),{_tag:`AndThen`});const vh=(e,t)=>{const n=Object.create(_h);n.first=e;n.second=t;return n};const yh=Object.assign(Object.create(ph),{_tag:`AddService`});const bh=(e,t)=>{const n=Object.create(yh);n.key=e;n.service=t;return n};const xh=Object.assign(Object.create(ph),{_tag:`RemoveService`});const Sh=e=>{const t=Object.create(xh);t.key=e;return t};const Ch=Object.assign(Object.create(ph),{_tag:`UpdateService`});const wh=(e,t)=>{const n=Object.create(Ch);n.key=e;n.update=t;return n};const Th=(e,t)=>{const n=new Map(e.unsafeMap);let r=gh();for(const[e,i]of t.unsafeMap.entries())if(n.has(e)){const t=n.get(e);n.delete(e);if(!w(t,i))r=Eh(wh(e,()=>i))(r)}else{n.delete(e);r=Eh(bh(e,i))(r)}for(const[e]of n.entries())r=Eh(Sh(e))(r);return r};const Eh=t(2,(e,t)=>vh(e,t));const Dh=t(2,(e,t)=>{if(e._tag===`Empty`)return t;let n=false;let r=ms(e);const i=new Map(t.unsafeMap);while(ks(r)){const e=R(r);const t=Ms(r);switch(e._tag){case`Empty`:{r=t;break}case`AddService`:{i.set(e.key,e.service);r=t;break}case`AndThen`:{r=L(L(t,e.second),e.first);break}case`RemoveService`:{i.delete(e.key);r=t;break}case`UpdateService`:{i.set(e.key,e.update(i.get(e.key)));n=true;r=t;break}}}if(!n)return yd(i);const a=new Map;for(const[e]of t.unsafeMap)if(i.has(e)){a.set(e,i.get(e));i.delete(e)}for(const[e,t]of i)a.set(e,t);return yd(a)});const Oh=Symbol.for(`effect/DifferHashMapPatch`);function kh(e){return e}const Ah={...Km.prototype,[Oh]:{_Value:kh,_Key:kh,_Patch:kh}};const jh=Object.assign(Object.create(Ah),{_tag:`Empty`});const Mh=Object.create(jh);const Nh=()=>Mh;const Ph=Object.assign(Object.create(Ah),{_tag:`AndThen`});const Fh=(e,t)=>{const n=Object.create(Ph);n.first=e;n.second=t;return n};const Ih=Object.assign(Object.create(Ah),{_tag:`Add`});const Lh=(e,t)=>{const n=Object.create(Ih);n.key=e;n.value=t;return n};const Rh=Object.assign(Object.create(Ah),{_tag:`Remove`});const zh=e=>{const t=Object.create(Rh);t.key=e;return t};const Bh=Object.assign(Object.create(Ah),{_tag:`Update`});const Vh=(e,t)=>{const n=Object.create(Bh);n.key=e;n.patch=t;return n};const Hh=e=>{const[t,n]=_m([e.oldValue,Nh()],([t,n],r,i)=>{const a=Kp(i)(t);switch(a._tag){case`Some`:{const o=e.differ.diff(a.value,r);if(w(o,e.differ.empty))return[fm(i)(t),n];return[fm(i)(t),Uh(Vh(i,o))(n)]}case`None`:return[t,Uh(Lh(i,r))(n)]}})(e.newValue);return _m(n,(e,t,n)=>Uh(zh(n))(e))(t)};const Uh=t(2,(e,t)=>Fh(e,t));const Wh=t(3,(e,t,n)=>{if(e._tag===`Empty`)return t;let r=t;let i=ms(e);while(ks(i)){const e=R(i);const t=Ms(i);switch(e._tag){case`Empty`:{i=t;break}case`AndThen`:{i=L(e.first)(L(e.second)(t));break}case`Add`:{r=Qp(e.key,e.value)(r);i=t;break}case`Remove`:{r=fm(e.key)(r);i=t;break}case`Update`:{const a=Kp(e.key)(r);if(a._tag===`Some`)r=Qp(e.key,n.patch(e.patch,a.value))(r);i=t;break}}}return r});const Gh=Symbol.for(`effect/DifferHashSetPatch`);function Kh(e){return e}const qh={...Km.prototype,[Gh]:{_Value:Kh,_Key:Kh,_Patch:Kh}};const Jh=Object.assign(Object.create(qh),{_tag:`Empty`});const Yh=Object.create(Jh);const Xh=()=>Yh;const Zh=Object.assign(Object.create(qh),{_tag:`AndThen`});const Qh=(e,t)=>{const n=Object.create(Zh);n.first=e;n.second=t;return n};const $h=Object.assign(Object.create(qh),{_tag:`Add`});const eg=e=>{const t=Object.create($h);t.value=e;return t};const tg=Object.assign(Object.create(qh),{_tag:`Remove`});const ng=e=>{const t=Object.create(tg);t.value=e;return t};const rg=(e,t)=>{const[n,r]=iu([e,Xh()],([e,t],n)=>{if(Bl(n)(e))return[Xl(n)(e),t];return[e,ig(eg(n))(t)]})(t);return iu(r,(e,t)=>ig(ng(t))(e))(n)};const ig=t(2,(e,t)=>Qh(e,t));const ag=t(2,(e,t)=>{if(e._tag===`Empty`)return t;let n=t;let r=ms(e);while(ks(r)){const e=R(r);const t=Ms(r);switch(e._tag){case`Empty`:{r=t;break}case`AndThen`:{r=L(e.first)(L(e.second)(t));break}case`Add`:{n=Yl(e.value)(n);r=t;break}case`Remove`:{n=Xl(e.value)(n);r=t}}}return n});const og=Symbol.for(`effect/DifferOrPatch`);function sg(e){return e}const cg={...Km.prototype,[og]:{_Value:sg,_Key:sg,_Patch:sg}};const lg=Object.assign(Object.create(cg),{_tag:`Empty`});const ug=Object.create(lg);const dg=()=>ug;const fg=Object.assign(Object.create(cg),{_tag:`AndThen`});const pg=(e,t)=>{const n=Object.create(fg);n.first=e;n.second=t;return n};const mg=Object.assign(Object.create(cg),{_tag:`SetLeft`});const hg=e=>{const t=Object.create(mg);t.value=e;return t};const gg=Object.assign(Object.create(cg),{_tag:`SetRight`});const _g=e=>{const t=Object.create(gg);t.value=e;return t};const vg=Object.assign(Object.create(cg),{_tag:`UpdateLeft`});const yg=e=>{const t=Object.create(vg);t.patch=e;return t};const bg=Object.assign(Object.create(cg),{_tag:`UpdateRight`});const xg=e=>{const t=Object.create(bg);t.patch=e;return t};const Sg=e=>{switch(e.oldValue._tag){case`Left`:switch(e.newValue._tag){case`Left`:{const t=e.left.diff(e.oldValue.left,e.newValue.left);if(w(t,e.left.empty))return dg();return yg(t)}case`Right`:return _g(e.newValue.right)}case`Right`:switch(e.newValue._tag){case`Left`:return hg(e.newValue.left);case`Right`:{const t=e.right.diff(e.oldValue.right,e.newValue.right);if(w(t,e.right.empty))return dg();return xg(t)}}}};const Cg=t(2,(e,t)=>pg(e,t));const wg=t(2,(e,{left:t,oldValue:n,right:r})=>{if(e._tag===`Empty`)return n;let i=ms(e);let a=n;while(ks(i)){const e=R(i);const n=Ms(i);switch(e._tag){case`Empty`:{i=n;break}case`AndThen`:{i=L(e.first)(L(e.second)(n));break}case`UpdateLeft`:{if(a._tag===`Left`)a=M(t.patch(e.patch,a.left));i=n;break}case`UpdateRight`:{if(a._tag===`Right`)a=j(r.patch(e.patch,a.right));i=n;break}case`SetLeft`:{a=M(e.value);i=n;break}case`SetRight`:{a=j(e.value);i=n;break}}}return a});const Tg=Symbol.for(`effect/DifferReadonlyArrayPatch`);function Eg(e){return e}const Dg={...Km.prototype,[Tg]:{_Value:Eg,_Patch:Eg}};const Og=Object.assign(Object.create(Dg),{_tag:`Empty`});const kg=Object.create(Og);const Ag=()=>kg;const jg=Object.assign(Object.create(Dg),{_tag:`AndThen`});const Mg=(e,t)=>{const n=Object.create(jg);n.first=e;n.second=t;return n};const Ng=Object.assign(Object.create(Dg),{_tag:`Append`});const Pg=e=>{const t=Object.create(Ng);t.values=e;return t};const Fg=Object.assign(Object.create(Dg),{_tag:`Slice`});const Ig=(e,t)=>{const n=Object.create(Fg);n.from=e;n.until=t;return n};const Lg=Object.assign(Object.create(Dg),{_tag:`Update`});const Rg=(e,t)=>{const n=Object.create(Lg);n.index=e;n.patch=t;return n};const zg=e=>{let t=0;let n=Ag();while(t<e.oldValue.length&&t<e.newValue.length){const r=e.oldValue[t];const i=e.newValue[t];const a=e.differ.diff(r,i);if(!w(a,e.differ.empty))n=Bg(n,Rg(t,a));t=t+1}if(t<e.oldValue.length)n=Bg(n,Ig(0,t));if(t<e.newValue.length)n=Bg(n,Pg(Fr(t)(e.newValue)));return n};const Bg=t(2,(e,t)=>Mg(e,t));const Vg=t(3,(e,t,n)=>{if(e._tag===`Empty`)return t;let r=t.slice();let i=$r(e);while(Sr(i)){const e=kr(i);const t=Mr(i);switch(e._tag){case`Empty`:{i=t;break}case`AndThen`:{t.unshift(e.first,e.second);i=t;break}case`Append`:{for(const t of e.values)r.push(t);i=t;break}case`Slice`:{r=r.slice(e.from,e.until);i=t;break}case`Update`:{r[e.index]=n.patch(e.patch,r[e.index]);i=t;break}}}return r});const Hg=Symbol.for(`effect/Differ`);const Ug={[Hg]:{_P:n,_V:n},pipe(){return O(this,arguments)}};const Wg=e=>{const t=Object.create(Ug);t.empty=e.empty;t.diff=e.diff;t.combine=e.combine;t.patch=e.patch;return t};const Gg=()=>Wg({empty:gh(),combine:(e,t)=>Eh(t)(e),diff:(e,t)=>Th(e,t),patch:(e,t)=>Dh(t)(e)});const Kg=e=>Wg({empty:$m(),combine:(e,t)=>lh(t)(e),diff:(t,n)=>ch({oldValue:t,newValue:n,differ:e}),patch:(t,n)=>uh(n,e)(t)});const qg=e=>Wg({empty:Nh(),combine:(e,t)=>Uh(t)(e),diff:(t,n)=>Hh({oldValue:t,newValue:n,differ:e}),patch:(t,n)=>Wh(n,e)(t)});const Jg=()=>Wg({empty:Xh(),combine:(e,t)=>ig(t)(e),diff:(e,t)=>rg(e,t),patch:(e,t)=>ag(t)(e)});const Yg=t(2,(e,t)=>Wg({empty:dg(),combine:(e,t)=>Cg(e,t),diff:(n,r)=>Sg({oldValue:n,newValue:r,left:e,right:t}),patch:(n,r)=>wg(n,{oldValue:r,left:e,right:t})}));const Xg=e=>Wg({empty:Ag(),combine:(e,t)=>Bg(e,t),diff:(t,n)=>zg({oldValue:t,newValue:n,differ:e}),patch:(t,n)=>Vg(t,n,e)});const Zg=t(2,(e,{toNew:t,toOld:n})=>Wg({empty:e.empty,combine:(t,n)=>e.combine(t,n),diff:(t,r)=>e.diff(n(t),n(r)),patch:(r,i)=>t(e.patch(r,n(i)))}));const Qg=()=>$g((e,t)=>t);const $g=e=>Wg({empty:n,combine:(e,t)=>{if(e===n)return t;if(t===n)return e;return n=>t(e(n))},diff:(e,t)=>{if(w(e,t))return n;return r(t)},patch:(t,n)=>e(n,t(n))});const e_=t(2,(e,t)=>Wg({empty:[e.empty,t.empty],combine:(n,r)=>[e.combine(n[0],r[0]),t.combine(n[1],r[1])],diff:(n,r)=>[e.diff(n[0],r[0]),t.diff(n[1],r[1])],patch:(n,r)=>[e.patch(n[0],r[0]),t.patch(n[1],r[1])]}));const t_=255;const n_=8;const r_=e=>e&t_;const i_=e=>e>>n_&t_;const a_=(e,t)=>(e&t_)+((t&e&t_)<<n_);const o_=a_(0,0);const s_=e=>a_(e,e);const c_=e=>a_(e,0);const l_=e=>e===0;const u_=t(2,(e,t)=>(r_(e)&t)!==0);const d_=t(2,(e,t)=>(i_(e)&t)!==0);const f_=t(2,(e,t)=>(r_(e)&t)!==0&&(i_(e)&t)===0);const p_=t(2,(e,t)=>a_(r_(e)&~t,i_(e)));const m_=t(2,(e,t)=>a_(r_(e)|r_(t),i_(e)&i_(t)));const h_=t(2,(e,t)=>a_(r_(e)|r_(t),i_(e)|i_(t)));const g_=t(2,(e,t)=>e|t);const __=e=>a_(i_(e),v_(r_(e)));const v_=e=>~e>>>0&t_;const y_=0;const b_=1;const x_=2;const S_=4;const C_=16;const w_=32;const T_=[y_,b_,x_,S_,C_,w_];const E_=e=>{switch(e){case w_:return`CooperativeYielding`;case C_:return`WindDown`;case S_:return`RuntimeMetrics`;case x_:return`OpSupervision`;case b_:return`Interruption`;case y_:return`None`}};const D_=e=>M_(e,w_);const O_=t(2,(e,t)=>e&~t);const k_=t(2,(e,t)=>e|t);const A_=e=>j_(e)&&!L_(e);const j_=e=>M_(e,b_);const M_=t(2,(e,t)=>(e&t)!==0);const N_=(...e)=>e.reduce((e,t)=>e|t,0);const P_=N_(y_);const F_=e=>M_(e,S_);const I_=e=>new Set(T_.filter(t=>M_(e,t)));const L_=e=>M_(e,C_);const R_=e=>I_(r_(e)&i_(e));const z_=e=>I_(r_(e)&~i_(e));const B_=t(2,(e,t)=>a_(e^t,t));const V_=t(2,(e,t)=>e&(v_(r_(t))|i_(t))|r_(t)&i_(t));const H_=e=>{const t=Array.from(R_(e)).map(e=>E_(e)).join(`, `);const n=Array.from(z_(e)).map(e=>E_(e)).join(`, `);return`RuntimeFlagsPatch(enabled = (${t}), disabled = (${n}))`};const U_=Wg({empty:o_,diff:(e,t)=>B_(e,t),combine:(e,t)=>g_(t)(e),patch:(e,t)=>V_(t,e)});const W_=o_;const G_=a_;const K_=s_;const q_=c_;const J_=l_;const Y_=u_;const X_=d_;const Z_=f_;const Q_=u_;const $_=g_;const ev=m_;const tv=h_;const nv=p_;const rv=__;const iv=R_;const av=z_;const ov=H_;const sv={_tag:`Empty`};const cv=(e,t)=>({_tag:`Par`,left:e,right:t});const lv=(e,t)=>({_tag:`Seq`,left:e,right:t});const uv=(e,t)=>({_tag:`Single`,dataSource:e,blockedRequest:t});const dv=e=>{let t=zm(e);let n=Rm();while(1){const[e,r]=Um(t,[Sv(),Rm()],([e,t],n)=>{const[r,i]=fv(n);return[wv(e,r),Bm(t,i)]});n=pv(n,e);if(Pm(r))return Wm(n);t=r}throw new Error(`BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues`)};const fv=e=>{let t=e;let n=Sv();let r=Rm();let i=Rm();while(1)switch(t._tag){case`Empty`:{if(Pm(r))return[n,i];t=r.head;r=r.tail;break}case`Par`:{r=Lm(t.right,r);t=t.left;break}case`Seq`:{const e=t.left;const n=t.right;switch(e._tag){case`Empty`:{t=n;break}case`Par`:{const r=e.left;const i=e.right;t=cv(lv(r,n),lv(i,n));break}case`Seq`:{const r=e.left;const i=e.right;t=lv(r,lv(i,n));break}case`Single`:{t=e;i=Lm(n,i);break}}break}case`Single`:{n=Cv(n,t);if(Pm(r))return[n,i];t=r.head;r=r.tail;break}}throw new Error(`BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues`)};const pv=(e,t)=>{if(Pm(e))return zm(Dv(t));if(Tv(t))return e;const n=Nv(e.head);const r=Ev(t);if(n.length===1&&r.length===1&&w(n[0],r[0]))return Lm(Mv(e.head,Dv(t)),e.tail);return Lm(Dv(t),e)};const mv=Symbol.for(`effect/RequestBlock/Entry`);var hv=class{request;result;listeners;ownerId;state;[mv]=gv;constructor(e,t,n,r,i){this.request=e;this.result=t;this.listeners=n;this.ownerId=r;this.state=i}};const gv={_R:e=>e};const _v=e=>v(e,mv);const vv=e=>new hv(e.request,e.result,e.listeners,e.ownerId,e.state);const yv=Symbol.for(`effect/RequestBlock/RequestBlockParallel`);const bv={_R:e=>e};var xv=class{map;[yv]=bv;constructor(e){this.map=e}};const Sv=()=>new xv(Hp());const Cv=(e,t)=>new xv(cm(e.map,t.dataSource,e=>Hn(Jn(e,Ts(t.blockedRequest)),()=>ms(t.blockedRequest))));const wv=(e,t)=>new xv(_m(e.map,t.map,(e,t,n)=>Qp(e,n,Ln(Kp(e,n),{onNone:()=>t,onSome:e=>Ds(t,e)}))));const Tv=e=>Gp(e.map);const Ev=e=>Array.from($p(e.map));const Dv=e=>jv(mm(e.map,e=>ms(e)));const Ov=Symbol.for(`effect/RequestBlock/RequestBlockSequential`);const kv={_R:e=>e};var Av=class{map;[Ov]=kv;constructor(e){this.map=e}};const jv=e=>new Av(e);const Mv=(e,t)=>new Av(_m(t.map,e.map,(e,t,n)=>Qp(e,n,Ln(Kp(e,n),{onNone:()=>fs(),onSome:e=>Ds(e,t)}))));const Nv=e=>Array.from($p(e.map));const Pv=e=>Array.from(e.map);const Fv=`Pending`;const Iv=`Done`;const Lv=`effect/Deferred`;const Rv=Symbol.for(Lv);const zv={_E:e=>e,_A:e=>e};const Bv=e=>{return{_tag:Fv,joiners:e}};const Vv=e=>{return{_tag:Iv,effect:e}};var Hv=class e{self;called=false;constructor(e){this.self=e}next(e){return this.called?{value:e,done:true}:(this.called=true,{value:this.self,done:false})}return(e){return{value:e,done:true}}throw(e){throw e}[Symbol.iterator](){return new e(this.self)}};const Uv=(e,t)=>{const n=new qv(`Blocked`);n.effect_instruction_i0=e;n.effect_instruction_i1=t;return n};const Wv=e=>{const t=new qv(`RunBlocked`);t.effect_instruction_i0=e;return t};const Gv=Symbol.for(`effect/Effect`);var Kv=class{patch;op;_op=Dt;constructor(e,t){this.patch=e;this.op=t}};var qv=class{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[Gv]=Pt;constructor(e){this._op=e}[C](e){return this===e}[y](){return S(this,Ye(this))}pipe(){return O(this,arguments)}toJSON(){return{_id:`Effect`,_op:this._op,effect_instruction_i0:E(this.effect_instruction_i0),effect_instruction_i1:E(this.effect_instruction_i1),effect_instruction_i2:E(this.effect_instruction_i2)}}toString(){return D(this.toJSON())}[T](){return this.toJSON()}[Symbol.iterator](){return new Hv(new Be(this))}};var Jv=class{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[Gv]=Pt;constructor(e){this._op=e;this._tag=e}[C](e){return Ix(e)&&e._op===`Failure`&&w(this.effect_instruction_i0,e.effect_instruction_i0)}[y](){return c($e(this._tag),x(b(this.effect_instruction_i0)),S(this))}get cause(){return this.effect_instruction_i0}pipe(){return O(this,arguments)}toJSON(){return{_id:`Exit`,_tag:this._op,cause:this.cause.toJSON()}}toString(){return D(this.toJSON())}[T](){return this.toJSON()}[Symbol.iterator](){return new Hv(new Be(this))}};var Yv=class{_op;effect_instruction_i0=void 0;effect_instruction_i1=void 0;effect_instruction_i2=void 0;trace=void 0;[Gv]=Pt;constructor(e){this._op=e;this._tag=e}[C](e){return Ix(e)&&e._op===`Success`&&w(this.effect_instruction_i0,e.effect_instruction_i0)}[y](){return c($e(this._tag),x(b(this.effect_instruction_i0)),S(this))}get value(){return this.effect_instruction_i0}pipe(){return O(this,arguments)}toJSON(){return{_id:`Exit`,_tag:this._op,value:E(this.value)}}toString(){return D(this.toJSON())}[T](){return this.toJSON()}[Symbol.iterator](){return new Hv(new Be(this))}};const z=e=>v(e,Gv);const B=e=>{const t=new qv(Tt);t.effect_instruction_i0=e;return t};const Xv=t(3,(e,t,n)=>Jy(r=>U(e,e=>U(my(K(()=>r(t(e)))),t=>{return K(()=>n(e,t)).pipe(wy({onFailure:e=>{switch(t._tag){case k:return H(Su(t.effect_instruction_i0,e));case A:return H(e)}},onSuccess:()=>t}))}))));const Zv=t(2,(e,t)=>U(e,()=>G(t)));const Qv=e=>Zv(e,void 0);const $v=function(){const e=new qv(gt);switch(arguments.length){case 2:{e.effect_instruction_i0=arguments[0];e.commit=arguments[1];break}case 3:{e.effect_instruction_i0=arguments[0];e.effect_instruction_i1=arguments[1];e.commit=arguments[2];break}case 4:{e.effect_instruction_i0=arguments[0];e.effect_instruction_i1=arguments[1];e.effect_instruction_i2=arguments[2];e.commit=arguments[3];break}default:throw new Error(Ee(`you're not supposed to end up here`))}return e};const ey=(e,t=Cp)=>{const n=new qv(ht);let r=void 0;n.effect_instruction_i0=t=>{r=e(t)};n.effect_instruction_i1=t;return Ry(n,e=>z(r)?r:J)};const ty=(e,t=Cp)=>K(()=>ey(e,t));const ny=(e,t=Cp)=>{return $v(e,function(){let e=void 0;let n=void 0;function r(t){if(e)e(t);else if(n===void 0)n=t}const i=new qv(ht);i.effect_instruction_i0=t=>{e=t;if(n)t(n)};i.effect_instruction_i1=t;let a=void 0;let o=void 0;if(this.effect_instruction_i0.length!==1){o=new AbortController;a=Ke(()=>this.effect_instruction_i0(r,o.signal))}else a=Ke(()=>this.effect_instruction_i0(r));return a||o?Ry(i,e=>{if(o)o.abort();return a??J}):i})};const ry=t(2,(e,t)=>{const n=new qv(_t);n.effect_instruction_i0=e;n.effect_instruction_i1=t;return n});const iy=t(2,(e,t)=>Ty(e,{onFailure:t,onSuccess:G}));const ay=t(3,(e,t,n)=>ry(e,e=>{const r=Nu(e);switch(r._tag){case`Left`:return t(r.left)?n(r.left):H(e);case`Right`:return H(r.right)}}));const oy=t(2,(e,t)=>ry(e,e=>{const n=Nu(e);switch(n._tag){case`Left`:return c(t(n.left),Bn(()=>H(e)));case`Right`:return H(n.right)}}));const sy=e=>B((t,n)=>e(j_(n.runtimeFlags)));const cy=Symbol.for(`effect/OriginalAnnotation`);const ly=(e,t)=>{if(F(t))return new Proxy(e,{has(e,t){return t===od||t===cy||t in e},get(n,r){if(r===od)return t.value;if(r===cy)return e;return n[r]}});return e};const uy=e=>ge(e)&&!(od in e)?B(t=>H(yu(ly(e,GS(t))))):H(yu(e));const dy=e=>gy(()=>yu(new vx(e)));const fy=e=>U(q(e),uy);const py=e=>Ty(e,{onFailure:e=>G(M(e)),onSuccess:e=>G(j(e))});const my=e=>Cy(e,{onFailure:X,onSuccess:Z});const V=e=>ge(e)&&!(od in e)?B(t=>H(vu(ly(e,GS(t))))):H(vu(e));const hy=e=>U(q(e),V);const H=e=>{const t=new Jv(k);t.effect_instruction_i0=e;return t};const gy=e=>U(q(e),H);const _y=B(e=>G(e.id()));const vy=e=>B(t=>e(t.id()));const U=t(2,(e,t)=>{const n=new qv(vt);n.effect_instruction_i0=e;n.effect_instruction_i1=t;return n});const yy=t(2,(e,t)=>U(e,e=>{const n=typeof t===`function`?t(e):t;if(z(n))return n;else if(we(n))return ey(e=>{n.then(t=>e(G(t)),t=>e(V(new Fx(t,`An unknown error occurred in Effect.andThen`))))});return G(n)}));const by=e=>{const t=new qv(`OnStep`);t.effect_instruction_i0=e;return t};const xy=e=>U(e,n);const Sy=e=>Ty(e,{onFailure:G,onSuccess:V});const Cy=t(2,(e,t)=>wy(e,{onFailure:e=>G(t.onFailure(e)),onSuccess:e=>G(t.onSuccess(e))}));const wy=t(2,(e,t)=>{const n=new qv(yt);n.effect_instruction_i0=e;n.effect_instruction_i1=t.onFailure;n.effect_instruction_i2=t.onSuccess;return n});const Ty=t(2,(e,t)=>wy(e,{onFailure:e=>{const n=Au(e);if(n.length>0)return H(Ru(e));const r=ku(e);if(r.length>0)return t.onFailure(js(r));return H(e)},onSuccess:t.onSuccess}));const Ey=t(2,(e,t)=>K(()=>{const n=I(e);const r=ur(n.length);let i=0;return Zv(Zy({while:()=>i<n.length,body:()=>t(n[i],i),step:e=>{r[i++]=e}}),r)}));const Dy=t(2,(e,t)=>K(()=>{const n=I(e);let r=0;return Zy({while:()=>r<n.length,body:()=>t(n[r],r),step:()=>{r++}})}));const Oy=t(e=>typeof e[0]===`boolean`||z(e[0]),(e,t)=>z(e)?U(e,e=>e?t.onTrue():t.onFalse()):e?t.onTrue():t.onFalse());const ky=U(_y,e=>Ay(e));const Ay=e=>H(bu(e));const jy=e=>{const t=new qv(St);t.effect_instruction_i0=K_(b_);t.effect_instruction_i1=()=>e;return t};const My=e=>$v(e,function(){const e=new qv(St);e.effect_instruction_i0=K_(b_);e.effect_instruction_i1=e=>j_(e)?Ke(()=>this.effect_instruction_i0(jy)):Ke(()=>this.effect_instruction_i0(qy));return e});const Ny=t(2,(e,t)=>Jy(n=>U(my(n(e)),e=>SS(t,e))));const W=t(2,(e,t)=>U(e,e=>q(()=>t(e))));const Py=t(2,(e,t)=>Ty(e,{onFailure:e=>hy(()=>t.onFailure(e)),onSuccess:e=>q(()=>t.onSuccess(e))}));const Fy=t(2,(e,t)=>wy(e,{onFailure:e=>{const n=Nu(e);switch(n._tag){case`Left`:return hy(()=>t(n.left));case`Right`:return H(n.right)}},onSuccess:G}));const Iy=t(2,(e,t)=>Ly(e,e=>Rx(e)?J:t(e.effect_instruction_i0)));const Ly=t(2,(e,t)=>Jy(n=>wy(n(e),{onFailure:e=>{const n=X(e);return wy(t(n),{onFailure:t=>X(Su(e,t)),onSuccess:()=>n})},onSuccess:e=>{const n=Z(e);return Y(t(n),n)}})));const Ry=t(2,(e,t)=>Ly(e,aS({onFailure:e=>Ou(e)?Qv(t(ju(e))):J,onSuccess:()=>J})));const zy=t(2,(e,t)=>Ky(e,t,G));const By=e=>Vy(e,n);const Vy=t(2,(e,t)=>Ty(e,{onFailure:e=>uy(t(e)),onSuccess:G}));const Hy=ii;const Uy=B((e,t)=>G(t.runtimeFlags));const G=e=>{const t=new Yv(A);t.effect_instruction_i0=e;return t};const K=e=>{const t=new qv(gt);t.commit=e;return t};const q=e=>{const t=new qv(bt);t.effect_instruction_i0=e;return t};const Wy=t(e=>e.length===3||e.length===2&&!(ge(e[1])&&`onlyEffect`in e[1]),(e,t)=>U(e,e=>{const n=typeof t===`function`?t(e):t;if(z(n))return Zv(n,e);else if(we(n))return ey(t=>{n.then(n=>t(G(e)),e=>t(V(new Fx(e,`An unknown error occurred in Effect.tap`))))});return G(e)}));const Gy=e=>B(t=>{const n=t.getFiberRef(rx);const r=c(n,Bn(()=>t.scope()));return e(Pb(rx,P(r)))});const Ky=t(3,(e,t,n)=>wy(e,{onFailure:e=>{const n=Au(e);if(n.length>0)return H(qn(Iu(e)));return t()},onSuccess:n}));const qy=e=>{const t=new qv(St);t.effect_instruction_i0=q_(b_);t.effect_instruction_i1=()=>e;return t};const Jy=e=>$v(e,function(){const e=new qv(St);e.effect_instruction_i0=q_(b_);e.effect_instruction_i1=e=>j_(e)?Ke(()=>this.effect_instruction_i0(jy)):Ke(()=>this.effect_instruction_i0(qy));return e});const J=G(void 0);const Yy=e=>{const t=new qv(St);t.effect_instruction_i0=e;t.effect_instruction_i1=void 0;return t};const Xy=t(2,(e,t)=>U(t,t=>{if(t)return c(e,W(P));return G(N())}));const Zy=e=>{const t=new qv(Ct);t.effect_instruction_i0=e.while;t.effect_instruction_i1=e.body;t.effect_instruction_i2=e.step;return t};const Qy=e=>K(()=>{const t=new qv(wt);t.effect_instruction_i0=e();return t});const $y=function(){const e=arguments.length===1?arguments[0]:arguments[1].bind(arguments[0]);return Qy(()=>e(c))};const eb=(e,...t)=>Object.defineProperty(t.length===0?function(...t){return Qy(()=>e.apply(this,t))}:function(...n){let r=Qy(()=>e.apply(this,n));for(const e of t)r=e(r,...n);return r},`length`,{value:e.length,configurable:true});const tb=t(2,(e,t)=>Pb(e,Xb,t));const nb=t(2,(e,t)=>Pb(e,Zb,t));const rb=t(2,(e,t)=>{const n=new qv(St);n.effect_instruction_i0=t;n.effect_instruction_i1=()=>e;return n});const ib=t(2,(e,t)=>Pb(e,ax,t));const ab=t(2,(e,t)=>Pb(e,ox,t));const ob=e=>{const t=new qv(Et);return typeof e?.priority!==`undefined`?Jb(t,e.priority):t};const sb=t(2,(e,t)=>U(e,e=>W(t,t=>[e,t])));const cb=t(2,(e,t)=>U(e,e=>Zv(t,e)));const Y=t(2,(e,t)=>U(e,()=>t));const lb=t(3,(e,t,n)=>U(e,e=>W(t,t=>n(e,t))));const ub=ty(()=>{const e=setInterval(()=>{},2**31-1);return q(()=>clearInterval(e))});const db=e=>U(_y,t=>c(e,fb(t)));const fb=t(2,(e,t)=>U(e.interruptAsFork(t),()=>e.await));const pb={_tag:`All`,syslog:0,label:`ALL`,ordinal:Number.MIN_SAFE_INTEGER,pipe(){return O(this,arguments)}};const mb={_tag:`Fatal`,syslog:2,label:`FATAL`,ordinal:5e4,pipe(){return O(this,arguments)}};const hb={_tag:`Error`,syslog:3,label:`ERROR`,ordinal:4e4,pipe(){return O(this,arguments)}};const gb={_tag:`Warning`,syslog:4,label:`WARN`,ordinal:3e4,pipe(){return O(this,arguments)}};const _b={_tag:`Info`,syslog:6,label:`INFO`,ordinal:2e4,pipe(){return O(this,arguments)}};const vb={_tag:`Debug`,syslog:7,label:`DEBUG`,ordinal:1e4,pipe(){return O(this,arguments)}};const yb={_tag:`Trace`,syslog:7,label:`TRACE`,ordinal:0,pipe(){return O(this,arguments)}};const bb={_tag:`None`,syslog:7,label:`OFF`,ordinal:Number.MAX_SAFE_INTEGER,pipe(){return O(this,arguments)}};const xb=[pb,yb,vb,_b,gb,hb,mb,bb];const Sb=`effect/FiberRef`;const Cb=Symbol.for(Sb);const wb={_A:e=>e};const Tb=e=>B(t=>Z(t.getFiberRef(e)));const Eb=t(2,(e,t)=>U(Tb(e),t));const Db=t(2,(e,t)=>Ob(e,()=>[void 0,t]));const Ob=t(2,(e,t)=>B(n=>{const[r,i]=t(n.getFiberRef(e));n.setFiberRef(e,i);return G(r)}));const kb=`effect/RequestResolver`;const Ab=Symbol.for(kb);const jb={_A:e=>e,_R:e=>e};var Mb=class e{runAll;target;[Ab]=jb;constructor(e,t){this.runAll=e;this.target=t}[y](){return S(this,this.target?b(this.target):Ye(this))}[C](e){return this.target?Nb(e)&&w(this.target,e.target):this===e}identified(...t){return new e(this.runAll,hs(t))}pipe(){return O(this,arguments)}};const Nb=e=>v(e,Ab);const Pb=t(3,(e,t,n)=>Xv(cb(Tb(t),Db(t,n)),()=>e,e=>Db(t,e)));const Fb=t(3,(e,t,n)=>Eb(t,r=>Pb(e,t,n(r))));const Ib=(e,t)=>Bb(e,{differ:Qg(),fork:t?.fork??n,join:t?.join});const Lb=e=>{const t=Jg();return Bb(e,{differ:t,fork:t.empty})};const Rb=e=>{const t=Xg(Qg());return Bb(e,{differ:t,fork:t.empty})};const zb=e=>{const t=Gg();return Bb(e,{differ:t,fork:t.empty})};const Bb=(e,t)=>{const n={...zt,[Cb]:wb,initial:e,commit(){return Tb(this)},diff:(e,n)=>t.differ.diff(e,n),combine:(e,n)=>t.differ.combine(e,n),patch:e=>n=>t.differ.patch(e,n),fork:t.fork,join:t.join??((e,t)=>t)};return n};const Vb=e=>Bb(e,{differ:U_,fork:U_.empty});const Hb=_(Symbol.for(`effect/FiberRef/currentContext`),()=>zb(qd()));const Ub=_(Symbol.for(`effect/FiberRef/currentSchedulingPriority`),()=>Ib(0));const Wb=_(Symbol.for(`effect/FiberRef/currentMaxOpsBeforeYield`),()=>Ib(2048));const Gb=_(Symbol.for(`effect/FiberRef/currentLogAnnotation`),()=>Ib(Hp()));const Kb=_(Symbol.for(`effect/FiberRef/currentLogLevel`),()=>Ib(_b));const qb=_(Symbol.for(`effect/FiberRef/currentLogSpan`),()=>Ib(Rm()));const Jb=t(2,(e,t)=>Pb(e,Ub,t));const Yb=t(2,(e,t)=>Pb(e,Wb,t));const Xb=_(Symbol.for(`effect/FiberRef/currentConcurrency`),()=>Ib(`unbounded`));const Zb=_(Symbol.for(`effect/FiberRef/currentRequestBatching`),()=>Ib(true));const Qb=_(Symbol.for(`effect/FiberRef/currentUnhandledErrorLogLevel`),()=>Ib(P(vb)));const $b=_(Symbol.for(`effect/FiberRef/versionMismatchErrorLogLevel`),()=>Ib(P(gb)));const ex=t(2,(e,t)=>Pb(e,Qb,t));const tx=_(Symbol.for(`effect/FiberRef/currentMetricLabels`),()=>Rb(Qr()));const nx=Tb(tx);const rx=_(Symbol.for(`effect/FiberRef/currentForkScopeOverride`),()=>Ib(N(),{fork:()=>N(),join:(e,t)=>e}));const ix=_(Symbol.for(`effect/FiberRef/currentInterruptedCause`),()=>Ib(_u,{fork:()=>_u,join:(e,t)=>e}));const ax=_(Symbol.for(`effect/FiberRef/currentTracerEnabled`),()=>Ib(true));const ox=_(Symbol.for(`effect/FiberRef/currentTracerTiming`),()=>Ib(true));const sx=_(Symbol.for(`effect/FiberRef/currentTracerSpanAnnotations`),()=>Ib(Hp()));const cx=_(Symbol.for(`effect/FiberRef/currentTracerSpanLinks`),()=>Ib(fs()));const lx=Symbol.for(`effect/Scope`);const ux=Symbol.for(`effect/CloseableScope`);const dx=(e,t)=>e.addFinalizer(()=>Qv(t));const fx=(e,t)=>e.addFinalizer(t);const px=(e,t)=>e.close(t);const mx=(e,t)=>e.fork(t);const hx=function(){class e extends globalThis.Error{commit(){return V(this)}toJSON(){const e={...this};if(this.message)e.message=this.message;if(this.cause)e.cause=this.cause;return e}[T](){if(this.toString!==globalThis.Error.prototype.toString)return this.stack?`${this.toString()}\n${this.stack.split(`
`).slice(1).join(`
`)}`:this.toString();else if(`Bun`in globalThis)return $u(vu(this),{renderErrorCause:true});return this}}Object.assign(e.prototype,Bt);return e}();const gx=(e,t)=>{class n extends hx{_tag=t}Object.assign(n.prototype,e);n.prototype.name=t;return n};const _x=Symbol.for(`effect/Cause/errors/RuntimeException`);const vx=gx({[_x]:_x},`RuntimeException`);const yx=Symbol.for(`effect/Cause/errors/InterruptedException`);const bx=gx({[yx]:yx},`InterruptedException`);const xx=e=>v(e,yx);const Sx=Symbol.for(`effect/Cause/errors/IllegalArgument`);const Cx=gx({[Sx]:Sx},`IllegalArgumentException`);const wx=Symbol.for(`effect/Cause/errors/NoSuchElement`);const Tx=gx({[wx]:wx},`NoSuchElementException`);const Ex=e=>v(e,wx);const Dx=Symbol.for(`effect/Cause/errors/InvalidPubSubCapacityException`);const Ox=gx({[Dx]:Dx},`InvalidPubSubCapacityException`);const kx=Symbol.for(`effect/Cause/errors/ExceededCapacityException`);const Ax=gx({[kx]:kx},`ExceededCapacityException`);const jx=Symbol.for(`effect/Cause/errors/Timeout`);const Mx=gx({[jx]:jx},`TimeoutException`);const Nx=e=>new Mx(`Operation timed out after '${Uf(e)}'`);const Px=Symbol.for(`effect/Cause/errors/UnknownException`);const Fx=function(){class e extends hx{_tag=`UnknownException`;error;constructor(e,t){super(t??`An unknown error occurred`,{cause:e});this.error=e}}Object.assign(e.prototype,{[Px]:Px,name:`UnknownException`});return e}();const Ix=e=>z(e)&&`_tag`in e&&(e._tag===`Success`||e._tag===`Failure`);const Lx=e=>e._tag===`Failure`;const Rx=e=>e._tag===`Success`;const zx=e=>{switch(e._tag){case k:return Du(e.effect_instruction_i0);case A:return false}};const Bx=t(2,(e,t)=>{switch(e._tag){case k:return X(e.effect_instruction_i0);case A:return Z(t)}});const Vx=e=>Bx(e,void 0);const Hx=e=>{switch(e._tag){case k:return P(e.effect_instruction_i0);case A:return N()}};const Ux=(e,t)=>hS(e,t?.parallel?xu:Su);const Wx=e=>X(yu(e));const Gx=t(2,(e,t)=>{switch(e._tag){case k:return false;case A:return t(e.effect_instruction_i0)}});const Kx=e=>X(vu(e));const X=e=>{const t=new Jv(k);t.effect_instruction_i0=e;return t};const qx=t(2,(e,t)=>{switch(e._tag){case k:return X(e.effect_instruction_i0);case A:return t(e.effect_instruction_i0)}});const Jx=t(2,(e,t)=>{switch(e._tag){case k:return G(X(e.effect_instruction_i0));case A:return t(e.effect_instruction_i0)}});const Yx=e=>c(e,qx(n));const Xx=t(2,(e,t)=>{switch(e._tag){case k:return G(X(e.effect_instruction_i0));case A:return my(t(e.effect_instruction_i0))}});const Zx=e=>{switch(e._tag){case`Left`:return Kx(e.left);case`Right`:return Z(e.right)}};const Qx=e=>{switch(e._tag){case`None`:return Kx(void 0);case`Some`:return Z(e.value)}};const $x=t(2,(e,t)=>{switch(e._tag){case k:return t(e.effect_instruction_i0);case A:return e.effect_instruction_i0}});const eS=e=>X(bu(e));const tS=t(2,(e,t)=>{switch(e._tag){case k:return X(e.effect_instruction_i0);case A:return Z(t(e.effect_instruction_i0))}});const nS=t(2,(e,{onFailure:t,onSuccess:n})=>{switch(e._tag){case k:return X(c(e.effect_instruction_i0,zu(t)));case A:return Z(n(e.effect_instruction_i0))}});const rS=t(2,(e,t)=>{switch(e._tag){case k:return X(c(e.effect_instruction_i0,zu(t)));case A:return Z(e.effect_instruction_i0)}});const iS=t(2,(e,t)=>{switch(e._tag){case k:return X(t(e.effect_instruction_i0));case A:return Z(e.effect_instruction_i0)}});const aS=t(2,(e,{onFailure:t,onSuccess:n})=>{switch(e._tag){case k:return t(e.effect_instruction_i0);case A:return n(e.effect_instruction_i0)}});const oS=t(2,(e,{onFailure:t,onSuccess:n})=>{switch(e._tag){case k:return t(e.effect_instruction_i0);case A:return n(e.effect_instruction_i0)}});const Z=e=>{const t=new Yv(A);t.effect_instruction_i0=e;return t};const sS=Z(void 0);const cS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>[e,t],onFailure:Su}));const lS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>e,onFailure:Su}));const uS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>t,onFailure:Su}));const dS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>[e,t],onFailure:xu}));const fS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>e,onFailure:xu}));const pS=t(2,(e,t)=>mS(e,t,{onSuccess:(e,t)=>t,onFailure:xu}));const mS=t(3,(e,t,{onFailure:n,onSuccess:r})=>{switch(e._tag){case k:switch(t._tag){case A:return X(e.effect_instruction_i0);case k:return X(n(e.effect_instruction_i0,t.effect_instruction_i0))}case A:switch(t._tag){case A:return Z(r(e.effect_instruction_i0,t.effect_instruction_i0));case k:return X(t.effect_instruction_i0)}}});const hS=(e,t)=>{const n=hs(e);if(!ks(n))return N();return c(Ms(n),oi(c(R(n),tS(ms)),(e,n)=>c(e,mS(n,{onSuccess:(e,t)=>c(e,L(t)),onFailure:t}))),tS(bs),tS(e=>vs(e)),P)};const gS=e=>{const t={...zt,[Rv]:zv,state:Kf(Bv([])),commit(){return yS(this)},blockingOn:e};return t};const _S=()=>U(_y,e=>vS(e));const vS=e=>q(()=>gS(e));const yS=e=>ty(t=>{const n=Jf(e.state);switch(n._tag){case Iv:return t(n.effect);case Fv:{n.joiners.push(t);return IS(e,t)}}},e.blockingOn);const bS=t(2,(e,t)=>Ny(t,e));const xS=t(2,(e,t)=>q(()=>{const n=Jf(e.state);switch(n._tag){case Iv:return false;case Fv:{Yf(e.state,Vv(t));for(let e=0,r=n.joiners.length;e<r;e++)n.joiners[e](t);return true}}}));const SS=t(2,(e,t)=>xS(e,t));const CS=t(2,(e,t)=>xS(e,V(t)));const wS=t(2,(e,t)=>xS(e,hy(t)));const TS=t(2,(e,t)=>xS(e,H(t)));const ES=t(2,(e,t)=>xS(e,gy(t)));const DS=t(2,(e,t)=>xS(e,uy(t)));const OS=t(2,(e,t)=>xS(e,fy(t)));const kS=e=>U(_y,t=>xS(e,Ay(t)));const AS=t(2,(e,t)=>xS(e,Ay(t)));const jS=e=>q(()=>Jf(e.state)._tag===Iv);const MS=e=>q(()=>{const t=Jf(e.state);switch(t._tag){case Iv:return P(t.effect);case Fv:return N()}});const NS=t(2,(e,t)=>xS(e,G(t)));const PS=t(2,(e,t)=>xS(e,q(t)));const FS=(e,t)=>{const n=Jf(e.state);if(n._tag===Fv){Yf(e.state,Vv(t));for(let e=0,r=n.joiners.length;e<r;e++)n.joiners[e](t)}};const IS=(e,t)=>q(()=>{const n=Jf(e.state);if(n._tag===Fv){const e=n.joiners.indexOf(t);if(e>=0)n.joiners.splice(e,1)}});const LS=B(e=>Z(e.currentContext));const RS=()=>LS;const zS=e=>U(RS(),e);const BS=t(2,(e,t)=>Pb(Hb,t)(e));const VS=t(2,(e,t)=>Fb(Hb,e=>ef(e,t))(e));const HS=t(2,(e,t)=>zS(n=>BS(e,t(n))));const US=t(2,(e,t)=>U(e,e=>U(t.predicate(e),n=>n?G(e):t.orElse(e))));const WS=t(2,(e,t)=>US(e,{predicate:t.predicate,orElse:e=>V(t.orFailWith(e))}));const GS=e=>{const t=e.currentSpan;return t!==void 0&&t._tag===`Span`?P(t):N()};const KS={_tag:`Span`,spanId:`noop`,traceId:`noop`,sampled:false,status:{_tag:`Ended`,startTime:BigInt(0),endTime:BigInt(0),exit:sS},attributes:new Map,links:[],kind:`internal`,attribute(){},event(){},end(){},addLinks(){}};const qS=e=>Object.assign(Object.create(KS),e);const JS=`effect/Clock`;const YS=Symbol.for(JS);const XS=Vd(`effect/Clock`);const ZS=2**31-1;const QS={unsafeSchedule(e,t){const n=Nf(t);if(n>ZS)return a;let r=false;const i=setTimeout(()=>{r=true;e()},n);return()=>{clearTimeout(i);return!r}}};const $S=function(){const e=BigInt(1e6);if(typeof performance===`undefined`)return()=>BigInt(Date.now())*e;let t;return()=>{if(t===void 0)t=BigInt(Date.now())*e-BigInt(Math.round(performance.now()*1e6));return t+BigInt(Math.round(performance.now()*1e6))}}();const eC=function(){const e=typeof process===`object`&&`hrtime`in process&&typeof process.hrtime.bigint===`function`?process.hrtime:void 0;if(!e)return $S;const t=$S()-e.bigint();return()=>t+e.bigint()}();var tC=class{[YS]=YS;unsafeCurrentTimeMillis(){return Date.now()}unsafeCurrentTimeNanos(){return eC()}currentTimeMillis=q(()=>this.unsafeCurrentTimeMillis());currentTimeNanos=q(()=>this.unsafeCurrentTimeNanos());scheduler(){return G(QS)}sleep(e){return ny(t=>{const n=QS.unsafeSchedule(()=>t(J),e);return Qv(q(n))})}};const nC=()=>new tC;const rC=`And`;const iC=`Or`;const aC=`InvalidData`;const oC=`MissingData`;const sC=`SourceUnavailable`;const cC=`Unsupported`;const lC=`effect/ConfigError`;const uC=Symbol.for(lC);const dC={_tag:`ConfigError`,[uC]:uC};const fC=(e,t)=>{const n=Object.create(dC);n._op=rC;n.left=e;n.right=t;Object.defineProperty(n,`toString`,{enumerable:false,value(){return`${this.left} and ${this.right}`}});Object.defineProperty(n,`message`,{enumerable:false,get(){return this.toString()}});return n};const pC=(e,t)=>{const n=Object.create(dC);n._op=iC;n.left=e;n.right=t;Object.defineProperty(n,`toString`,{enumerable:false,value(){return`${this.left} or ${this.right}`}});Object.defineProperty(n,`message`,{enumerable:false,get(){return this.toString()}});return n};const mC=(e,t,n={pathDelim:`.`})=>{const r=Object.create(dC);r._op=aC;r.path=e;r.message=t;Object.defineProperty(r,`toString`,{enumerable:false,value(){const e=c(this.path,pi(n.pathDelim));return`(Invalid data at ${e}: "${this.message}")`}});return r};const hC=(e,t,n={pathDelim:`.`})=>{const r=Object.create(dC);r._op=oC;r.path=e;r.message=t;Object.defineProperty(r,`toString`,{enumerable:false,value(){const e=c(this.path,pi(n.pathDelim));return`(Missing data at ${e}: "${this.message}")`}});return r};const gC=(e,t,n,r={pathDelim:`.`})=>{const i=Object.create(dC);i._op=sC;i.path=e;i.message=t;i.cause=n;Object.defineProperty(i,`toString`,{enumerable:false,value(){const e=c(this.path,pi(r.pathDelim));return`(Source unavailable at ${e}: "${this.message}")`}});return i};const _C=(e,t,n={pathDelim:`.`})=>{const r=Object.create(dC);r._op=cC;r.path=e;r.message=t;Object.defineProperty(r,`toString`,{enumerable:false,value(){const e=c(this.path,pi(n.pathDelim));return`(Unsupported operation at ${e}: "${this.message}")`}});return r};const vC=t(2,(e,t)=>{switch(e._op){case rC:return fC(vC(e.left,t),vC(e.right,t));case iC:return pC(vC(e.left,t),vC(e.right,t));case aC:return mC([...t,...e.path],e.message);case oC:return hC([...t,...e.path],e.message);case sC:return gC([...t,...e.path],e.message,e.cause);case cC:return _C([...t,...e.path],e.message)}});const yC={_tag:`Empty`};const bC=t(2,(e,t)=>{let n=zm(t);let r=e;while(Fm(n)){const e=n.head;switch(e._tag){case`Empty`:{n=n.tail;break}case`AndThen`:{n=Lm(e.first,Lm(e.second,n.tail));break}case`MapName`:{r=ei(r,e.f);n=n.tail;break}case`Nested`:{r=gr(r,e.name);n=n.tail;break}case`Unnested`:{const t=c(Or(r),er(e.name));if(t){r=Mr(r);n=n.tail}else return M(hC(r,`Expected ${e.name} to be in path in ConfigProvider#unnested`));break}}}return j(r)});const xC=`Constant`;const SC=`Fail`;const CC=`Fallback`;const wC=`Described`;const TC=`Lazy`;const EC=`MapOrFail`;const DC=`Nested`;const OC=`Primitive`;const kC=`Sequence`;const AC=`HashMap`;const jC=`ZipWith`;const MC=(e,t)=>[...e,...t];const NC=`effect/ConfigProvider`;const PC=Symbol.for(NC);const FC=Vd(`effect/ConfigProvider`);const IC=`effect/ConfigProviderFlat`;const LC=Symbol.for(IC);const RC=e=>({[PC]:PC,pipe(){return O(this,arguments)},...e});const zC=e=>({[LC]:LC,patch:e.patch,load:(t,n,r=true)=>e.load(t,n,r),enumerateChildren:e.enumerateChildren});const BC=e=>RC({load:t=>U(WC(e,Qr(),t,false),e=>Ln(Or(e),{onNone:()=>V(hC(Qr(),`Expected a single value having structure: ${t}`)),onSome:G})),flattened:e});const VC=e=>{const{pathDelim:t,seqDelim:n}=Object.assign({},{pathDelim:`_`,seqDelim:`,`},e);const r=e=>c(e,pi(t));const i=e=>e.split(t);const a=()=>typeof process!==`undefined`&&`env`in process&&typeof process.env===`object`?process.env:{};const o=(e,t,i=true)=>{const o=r(e);const s=a();const l=o in s?P(s[o]):N();return c(l,Fy(()=>hC(e,`Expected ${o} to exist in the process context`)),U(r=>qC(r,e,t,n,i)))};const s=e=>q(()=>{const t=a();const n=Object.keys(t);const r=n.map(e=>i(e.toUpperCase()));const o=r.filter(t=>{for(let n=0;n<e.length;n++){const r=c(e,Dr(n));const i=t[n];if(i===void 0||r!==i)return false}return true}).flatMap(t=>t.slice(e.length,e.length+1));return Rl(o)});return BC(zC({load:o,enumerateChildren:s,patch:yC}))};const HC=(e,t,n,r)=>{const i=ci(n.length,t=>t>=r.length?N():P([e(t),t+1]));const a=ci(r.length,e=>e>=n.length?N():P([t(e),e+1]));const o=MC(n,i);const s=MC(r,a);return[o,s]};const UC=(e,t)=>{let n=t;if(n._tag===`Nested`){const t=e.slice();while(n._tag===`Nested`){t.push(n.name);n=n.config}return t}return e};const WC=(e,t,n,r)=>{const i=n;switch(i._tag){case xC:return G($r(i.value));case wC:return K(()=>WC(e,t,i.config,r));case SC:return V(hC(t,i.message));case CC:return c(K(()=>WC(e,t,i.first,r)),iy(n=>{if(i.condition(n))return c(WC(e,t,i.second,r),iy(e=>V(pC(n,e))));return V(n)}));case TC:return K(()=>WC(e,t,i.config(),r));case EC:return K(()=>c(WC(e,t,i.original,r),U(Ey(e=>c(i.mapOrFail(e),Fy(vC(UC(t,i.original))))))));case DC:return K(()=>WC(e,MC(t,$r(i.name)),i.config,r));case OC:return c(bC(t,e.patch),U(t=>c(e.load(t,i,r),U(e=>{if(e.length===0){const e=c(Ar(t),Bn(()=>`<n/a>`));return V(hC([],`Expected ${i.description} with name ${e}`))}return G(e)}))));case kC:return c(bC(t,e.patch),U(n=>c(e.enumerateChildren(n),U(YC),U(n=>{if(n.length===0)return K(()=>W(WC(e,t,i.config,true),$r));return c(Ey(n,n=>WC(e,_r(t,`[${n}]`),i.config,true)),W(e=>{const t=ni(e);if(t.length===0)return $r(Qr());return $r(t)}))}))));case AC:return K(()=>c(bC(t,e.patch),U(t=>c(e.enumerateChildren(t),U(n=>{return c(n,Ey(n=>WC(e,MC(t,$r(n)),i.valueConfig,r)),W(e=>{if(e.length===0)return $r(Hp());return c(JC(e),ei(e=>Wp(Hr(I(n),e))))}))})))));case jC:return K(()=>c(WC(e,t,i.left,r),py,U(n=>c(WC(e,t,i.right,r),py,U(e=>{if(gn(n)&&gn(e))return V(fC(n.left,e.left));if(gn(n)&&_n(e))return V(n.left);if(_n(n)&&gn(e))return V(e.left);if(_n(n)&&_n(e)){const r=c(t,pi(`.`));const a=GC(t,r);const[o,s]=HC(a,a,c(n.right,ei(j)),c(e.right,ei(j)));return c(o,Hr(s),Ey(([e,t])=>c(sb(e,t),W(([e,t])=>i.zip(e,t)))))}throw new Error(`BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues`)})))))}};const GC=(e,t)=>n=>M(hC(e,`The element at index ${n} in a sequence at path "${t}" was missing`));const KC=(e,t)=>{const n=e.split(new RegExp(`\\s*${vi(t)}\\s*`));return n};const qC=(e,t,n,r,i)=>{if(!i)return c(n.parse(e),Py({onFailure:vC(t),onSuccess:$r}));return c(KC(e,r),Ey(e=>n.parse(e.trim())),Fy(vC(t)))};const JC=e=>{return Object.keys(e[0]).map(t=>e.map(e=>e[t]))};const YC=e=>c(Ey(e,ZC),Py({onFailure:()=>Qr(),onSuccess:Vr(gi)}),py,W(Cn));const XC=/^(\[(\d+)\])$/;const ZC=e=>{const t=e.match(XC);if(t!==null){const e=t[2];return c(e!==void 0&&e.length>0?P(e):N(),Yn(QC))}return N()};const QC=e=>{const t=Number.parseInt(e);return Number.isNaN(t)?N():P(t)};const $C=Symbol.for(`effect/Console`);const ew=Vd(`effect/Console`);const tw={[$C]:$C,assert(e,...t){return q(()=>{console.assert(e,...t)})},clear:q(()=>{console.clear()}),count(e){return q(()=>{console.count(e)})},countReset(e){return q(()=>{console.countReset(e)})},debug(...e){return q(()=>{console.debug(...e)})},dir(e,t){return q(()=>{console.dir(e,t)})},dirxml(...e){return q(()=>{console.dirxml(...e)})},error(...e){return q(()=>{console.error(...e)})},group(e){return e?.collapsed?q(()=>console.groupCollapsed(e?.label)):q(()=>console.group(e?.label))},groupEnd:q(()=>{console.groupEnd()}),info(...e){return q(()=>{console.info(...e)})},log(...e){return q(()=>{console.log(...e)})},table(e,t){return q(()=>{console.table(e,t)})},time(e){return q(()=>console.time(e))},timeEnd(e){return q(()=>console.timeEnd(e))},timeLog(e,...t){return q(()=>{console.timeLog(e,...t)})},trace(...e){return q(()=>{console.trace(...e)})},warn(...e){return q(()=>{console.warn(...e)})},unsafe:console};const nw=`effect/Random`;const rw=Symbol.for(nw);const iw=Vd(`effect/Random`);var aw=class{seed;[rw]=rw;PRNG;constructor(e){this.seed=e;this.PRNG=new Ie(e)}get next(){return q(()=>this.PRNG.number())}get nextBoolean(){return W(this.next,e=>e>.5)}get nextInt(){return q(()=>this.PRNG.integer(Number.MAX_SAFE_INTEGER))}nextRange(e,t){return W(this.next,n=>(t-e)*n+e)}nextIntBetween(e,t){return q(()=>this.PRNG.integer(t-e)+e)}shuffle(e){return ow(e,e=>this.nextIntBetween(0,e))}};const ow=(e,t)=>{return K(()=>c(q(()=>Array.from(e)),U(e=>{const n=[];for(let t=e.length;t>=2;t=t-1)n.push(t);return c(n,Dy(n=>c(t(n),W(t=>sw(e,n-1,t)))),Zv(hs(e)))})))};const sw=(e,t,n)=>{const r=e[t];e[t]=e[n];e[n]=r;return e};const cw=e=>new aw(b(e));var lw=class{values;[rw]=rw;index=0;constructor(e){this.values=e;if(e.length===0)throw new Error(`Requires at least one value`)}getNextValue(){const e=this.values[this.index];this.index=(this.index+1)%this.values.length;return e}get next(){return q(()=>{const e=this.getNextValue();if(typeof e===`number`)return Math.max(0,Math.min(1,e));return b(e)/2147483647})}get nextBoolean(){return q(()=>{const e=this.getNextValue();if(typeof e===`boolean`)return e;return b(e)%2===0})}get nextInt(){return q(()=>{const e=this.getNextValue();if(typeof e===`number`&&Number.isFinite(e))return Math.round(e);return Math.abs(b(e))})}nextRange(e,t){return W(this.next,n=>(t-e)*n+e)}nextIntBetween(e,t){return q(()=>{const n=this.getNextValue();if(typeof n===`number`&&Number.isFinite(n))return Math.max(e,Math.min(t-1,Math.round(n)));const r=Math.abs(b(n));return e+r%(t-e)})}shuffle(e){return ow(e,e=>this.nextIntBetween(0,e))}};const uw=Symbol.for(`effect/Tracer`);const dw=e=>({[uw]:uw,...e});const fw=Vd(`effect/Tracer`);const pw=Vd(`effect/ParentSpan`);const mw=function(){const e=`abcdef0123456789`;const t=16;return function(n){let r=``;for(let i=0;i<n;i++)r+=e.charAt(Math.floor(Math.random()*t));return r}}();var hw=class{name;parent;context;startTime;kind;_tag=`Span`;spanId;traceId=`native`;sampled=true;status;attributes;events=[];links;constructor(e,t,n,r,i,a){this.name=e;this.parent=t;this.context=n;this.startTime=i;this.kind=a;this.status={_tag:`Started`,startTime:i};this.attributes=new Map;this.traceId=t._tag===`Some`?t.value.traceId:mw(32);this.spanId=mw(16);this.links=Array.from(r)}end(e,t){this.status={_tag:`Ended`,endTime:e,exit:t,startTime:this.status.startTime}}attribute(e,t){this.attributes.set(e,t)}event(e,t,n){this.events.push([e,t,n??{}])}addLinks(e){this.links.push(...e)}};const gw=dw({span:(e,t,n,r,i,a)=>new hw(e,t,n,r,i,a),context:e=>e()});const _w=e=>({_tag:`ExternalSpan`,spanId:e.spanId,traceId:e.traceId,sampled:e.sampled??true,context:e.context??qd()});const vw=e=>{if(e?.captureStackTrace===false)return e;else if(e?.captureStackTrace!==void 0&&typeof e.captureStackTrace!==`boolean`)return e;const t=Error.stackTraceLimit;Error.stackTraceLimit=3;const n=new Error;Error.stackTraceLimit=t;let r=false;return{...e,captureStackTrace:()=>{if(r!==false)return r;if(n.stack!==void 0){const e=n.stack.split(`
`);if(e[3]!==void 0){r=e[3].trim();return r}}}}};const yw=sf()(`effect/Tracer/DisablePropagation`,{defaultValue:a});const bw=c(qd(),Yd(XS,nC()),Yd(ew,tw),Yd(iw,cw(Math.random())),Yd(FC,VC()),Yd(fw,gw));const xw=_(Symbol.for(`effect/DefaultServices/currentServices`),()=>zb(bw));const Sw=e=>{const t=gf(e);return ww(e=>e.sleep(t))};const Cw=e=>B(t=>e(t.currentDefaultServices));const ww=e=>Cw(t=>e(t.unsafeMap.get(XS.key)));const Tw=ww(e=>e.currentTimeMillis);const Ew=ww(e=>e.currentTimeNanos);const Dw=t(2,(e,t)=>Fb(xw,Yd(XS,t))(e));const Ow=t(2,(e,t)=>Fb(xw,Yd(FC,t))(e));const kw=e=>Cw(t=>e(t.unsafeMap.get(FC.key)));const Aw=e=>Cw(t=>e(t.unsafeMap.get(iw.key)));const jw=t(2,(e,t)=>Fb(xw,Yd(iw,t))(e));const Mw=e=>Cw(t=>e(t.unsafeMap.get(fw.key)));const Nw=t(2,(e,t)=>Fb(xw,Yd(fw,t))(e));const Pw=le;const Fw=p;const Iw=On;const Lw=e=>!e;const Rw=Rv;const zw=_S;const Bw=vS;const Vw=yS;const Hw=bS;const Uw=xS;const Ww=SS;const Gw=CS;const Kw=wS;const qw=TS;const Jw=ES;const Yw=DS;const Xw=OS;const Zw=kS;const Qw=AS;const $w=jS;const eT=MS;const tT=NS;const nT=PS;const rT=gS;const iT=FS;const aT=At;const oT=jt;const sT=Mt;const cT=Nt;const lT=Lt;const uT=zt;const dT=Bt;const fT=Vt;const pT=Ht;var mT=class extends fT{};const hT=`Sequential`;const gT=`Parallel`;const _T=`ParallelN`;const vT={_tag:hT};const yT={_tag:gT};const bT=e=>({_tag:_T,parallelism:e});const xT=e=>e._tag===hT;const ST=e=>e._tag===gT;const CT=e=>e._tag===_T;const wT=t(2,(e,t)=>{switch(e._tag){case hT:return t.onSequential();case gT:return t.onParallel();case _T:return t.onParallelN(e.parallelism)}});const TT=vT;const ET=yT;const DT=bT;const OT=xT;const kT=ST;const AT=CT;const jT=wT;function MT(e){return new FT(e)}function NT(){return MT(new Map)}const PT=Symbol.for(`effect/FiberRefs`);var FT=class{locals;[PT]=PT;constructor(e){this.locals=e}pipe(){return O(this,arguments)}};const IT=(e,t,n,r=false)=>{const i=e;let a=t;let o=n;let s=r;let c=void 0;while(c===void 0)if(Cr(a)&&Cr(o)){const e=kr(a)[0];const t=Mr(a);const n=kr(o)[0];const r=kr(o)[1];const i=Mr(o);if(e.startTimeMillis<n.startTimeMillis){o=i;s=true}else if(e.startTimeMillis>n.startTimeMillis)a=t;else if(e.id<n.id){o=i;s=true}else if(e.id>n.id)a=t;else c=[r,s]}else c=[i.initial,true];return c};const LT=t(3,(e,t,n)=>{const r=new Map(e.locals);n.locals.forEach((e,n)=>{const i=e[0][1];if(!e[0][0][C](t)){if(!r.has(n)){if(w(i,n.initial))return;r.set(n,[[t,n.join(n.initial,i)]]);return}const a=r.get(n);const[o,s]=IT(n,a,e);if(s){const e=n.diff(o,i);const s=a[0][1];const c=n.join(s,n.patch(e)(s));if(!w(s,c)){let e;const i=a[0][0];if(i[C](t))e=[[i,c],...a.slice(1)];else e=[[t,c],...a];r.set(n,e)}}}});return new FT(r)});const RT=t(2,(e,t)=>{const n=new Map;zT(e,n,t);return new FT(n)});const zT=(e,t,n)=>{e.locals.forEach((e,r)=>{const i=e[0][1];const a=r.patch(r.fork)(i);if(w(i,a))t.set(r,e);else t.set(r,[[n,a],...e])})};const BT=e=>Rl(e.locals.keys());const VT=e=>Dy(BT(e),t=>Db(t,WT(e,t)));const HT=t(2,(e,t)=>{const n=new Map(e.locals);n.delete(t);return new FT(n)});const UT=t(2,(e,t)=>{if(!e.locals.has(t))return N();return P(kr(e.locals.get(t))[1])});const WT=t(2,(e,t)=>c(UT(e,t),Bn(()=>t.initial)));const GT=t(2,(e,{fiberId:t,fiberRef:n,value:r})=>{if(e.locals.size===0)return new FT(new Map([[n,[[t,r]]]]));const i=new Map(e.locals);KT(i,t,n,r);return new FT(i)});const KT=(e,t,n,r)=>{const i=e.get(n)??[];let a;if(Cr(i)){const[e,n]=kr(i);if(e[C](t))if(w(n,r))return;else a=[[t,r],...i.slice(1)];else a=[[t,r],...i]}else a=[[t,r]];e.set(n,a)};const qT=t(2,(e,{entries:t,forkAs:n})=>{if(e.locals.size===0)return new FT(new Map(t));const r=new Map(e.locals);if(n!==void 0)zT(e,r,n);t.forEach(([e,t])=>{if(t.length===1)KT(r,t[0][0],e,t[0][1]);else t.forEach(([t,n])=>{KT(r,t,e,n)})});return new FT(r)});const JT=PT;const YT=HT;const XT=BT;const ZT=RT;const QT=UT;const $T=WT;const eE=LT;const tE=VT;const nE=GT;const rE=qT;const iE=MT;const aE=NT;const oE=`Empty`;const sE=`Add`;const cE=`Remove`;const lE=`Update`;const uE=`AndThen`;const dE={_tag:oE};const fE=(e,t)=>{const n=new Map(e.locals);let r=dE;for(const[e,i]of t.locals.entries()){const t=kr(i)[1];const a=n.get(e);if(a!==void 0){const n=kr(a)[1];if(!w(n,t))r=pE({_tag:lE,fiberRef:e,patch:e.diff(n,t)})(r)}else r=pE({_tag:sE,fiberRef:e,value:t})(r);n.delete(e)}for(const[e]of n.entries())r=pE({_tag:cE,fiberRef:e})(r);return r};const pE=t(2,(e,t)=>({_tag:uE,first:e,second:t}));const mE=t(3,(e,t,n)=>{let r=n;let i=$r(e);while(Cr(i)){const e=kr(i);const n=Mr(i);switch(e._tag){case oE:{i=n;break}case sE:{r=GT(r,{fiberId:t,fiberRef:e.fiberRef,value:e.value});i=n;break}case cE:{r=HT(r,e.fiberRef);i=n;break}case lE:{const a=WT(r,e.fiberRef);r=GT(r,{fiberId:t,fiberRef:e.fiberRef,value:e.fiberRef.patch(e.patch)(a)});i=n;break}case uE:{i=gr(e.first)(gr(e.second)(n));break}}}return r});const hE=dE;const gE=fE;const _E=pE;const vE=mE;const yE=`effect/FiberStatus`;const bE=Symbol.for(yE);const xE=`Done`;const SE=`Running`;const CE=`Suspended`;const wE=$e(`${yE}-${xE}`);var TE=class{[bE]=bE;_tag=xE;[y](){return wE}[C](e){return jE(e)&&e._tag===xE}};var EE=class{runtimeFlags;[bE]=bE;_tag=SE;constructor(e){this.runtimeFlags=e}[y](){return c(b(yE),x(b(this._tag)),x(b(this.runtimeFlags)),S(this))}[C](e){return jE(e)&&e._tag===SE&&this.runtimeFlags===e.runtimeFlags}};var DE=class{runtimeFlags;blockingOn;[bE]=bE;_tag=CE;constructor(e,t){this.runtimeFlags=e;this.blockingOn=t}[y](){return c(b(yE),x(b(this._tag)),x(b(this.runtimeFlags)),x(b(this.blockingOn)),S(this))}[C](e){return jE(e)&&e._tag===CE&&this.runtimeFlags===e.runtimeFlags&&w(this.blockingOn,e.blockingOn)}};const OE=new TE;const kE=e=>new EE(e);const AE=(e,t)=>new DE(e,t);const jE=e=>v(e,bE);const ME=e=>e._tag===xE;const NE=e=>e._tag===SE;const PE=e=>e._tag===CE;const FE=bE;const IE=OE;const LE=kE;const RE=AE;const zE=jE;const BE=ME;const VE=NE;const HE=PE;const UE=pb;const WE=mb;const GE=hb;const KE=gb;const qE=_b;const JE=vb;const YE=yb;const XE=bb;const ZE=xb;const QE=c(gi,kn(e=>e.ordinal));const $E=Pn(QE);const eD=e=>{switch(e){case`All`:return UE;case`Debug`:return JE;case`Error`:return GE;case`Fatal`:return WE;case`Info`:return qE;case`Trace`:return YE;case`None`:return XE;case`Warning`:return KE}};const tD=Symbol.for(`effect/Micro`);const nD=Symbol.for(`effect/Micro/MicroExit`);const rD=Symbol.for(`effect/Micro/MicroCause`);const iD={_E:n};var aD=class extends globalThis.Error{_tag;traces;[rD];constructor(e,t,n){const r=`MicroCause.${e}`;let i;let a;let o;if(t instanceof globalThis.Error){i=`(${r}) ${t.name}`;a=t.message;const e=a.split(`
`).length;o=t.stack?`(${r}) ${t.stack.split(`
`).slice(0,e+3).join(`
`)}`:`${i}: ${a}`}else{i=r;a=ct(t,0);o=`${i}: ${a}`}if(n.length>0)o+=`\n    ${n.join(`
    `)}`;super(a);this._tag=e;this.traces=n;this[rD]=iD;this.name=i;this.stack=o}pipe(){return O(this,arguments)}toString(){return this.stack}[T](){return this.stack}};var oD=class extends aD{defect;constructor(e,t=[]){super(`Die`,e,t);this.defect=e}};const sD=(e,t=[])=>new oD(e,t);var cD=class extends aD{constructor(e=[]){super(`Interrupt`,`interrupted`,e)}};const lD=(e=[])=>new cD(e);const uD=e=>e._tag===`Interrupt`;const dD=Symbol.for(`effect/Micro/MicroFiber`);const fD={_A:n,_E:n};var pD=class{context;interruptible;[dD];_stack=[];_observers=[];_exit;_children;currentOpCount=0;constructor(e,t=true){this.context=e;this.interruptible=t;this[dD]=fD}getRef(e){return Ad(this.context,e)}addObserver(e){if(this._exit){e(this._exit);return s}this._observers.push(e);return()=>{const t=this._observers.indexOf(e);if(t>=0)this._observers.splice(t,1)}}_interrupted=false;unsafeInterrupt(){if(this._exit)return;this._interrupted=true;if(this.interruptible)this.evaluate(qD)}unsafePoll(){return this._exit}evaluate(e){if(this._exit)return;else if(this._yielded!==void 0){const e=this._yielded;this._yielded=void 0;e()}const t=this.runLoop(e);if(t===xD)return;const n=mD.interruptChildren&&mD.interruptChildren(this);if(n!==void 0)return this.evaluate(VD(n,()=>t));this._exit=t;for(let e=0;e<this._observers.length;e++)this._observers[e](t);this._observers.length=0}runLoop(e){let t=false;let n=e;this.currentOpCount=0;try{while(true){this.currentOpCount++;if(!t&&this.getRef(rO).shouldYield(this)){t=true;const e=n;n=VD(ND,()=>e)}n=n[_D](this);if(n===xD){const e=this._yielded;if(nD in e){this._yielded=void 0;return e}return xD}}}catch(e){if(!v(n,_D))return JD(`MicroFiber.runLoop: Not a valid effect: ${String(n)}`);return JD(e)}}getCont(e){while(true){const t=this._stack.pop();if(!t)return void 0;const n=t[bD]&&t[bD](this);if(n)return{[e]:n};if(t[e])return t}}_yielded=void 0;yieldWith(e){this._yielded=e;return xD}children(){return this._children??=new Set}};const mD=_(`effect/Micro/fiberMiddleware`,()=>({interruptChildren:void 0}));const hD=e=>jD(()=>{for(const t of e)t.unsafeInterrupt();const t=e[Symbol.iterator]();const n=jD(()=>{let e=t.next();while(!e.done){if(e.value.unsafePoll()){e=t.next();continue}const r=e.value;return RD(e=>{r.addObserver(t=>{e(n)})})}return YD});return n});const gD=Symbol.for(`effect/Micro/identifier`);const Q=Symbol.for(`effect/Micro/args`);const _D=Symbol.for(`effect/Micro/evaluate`);const vD=Symbol.for(`effect/Micro/successCont`);const yD=Symbol.for(`effect/Micro/failureCont`);const bD=Symbol.for(`effect/Micro/ensureCont`);const xD=Symbol.for(`effect/Micro/Yield`);const SD={_A:n,_E:n,_R:n};const CD={...lT,_op:`Micro`,[tD]:SD,pipe(){return O(this,arguments)},[Symbol.iterator](){return new ke(new Be(this))},toJSON(){return{_id:`Micro`,op:this[gD],...Q in this?{args:this[Q]}:void 0}},toString(){return D(this)},[T](){return D(this)}};function wD(e){return JD(`Micro.evaluate: Not implemented`)}const TD=e=>({...CD,[gD]:e.op,[_D]:e.eval??wD,[vD]:e.contA,[yD]:e.contE,[bD]:e.ensure});const ED=e=>{const t=TD(e);return function(){const n=Object.create(t);n[Q]=e.single===false?arguments:arguments[0];return n}};const DD=e=>{const t={...TD(e),[nD]:nD,_tag:e.op,get[e.prop](){return this[Q]},toJSON(){return{_id:`MicroExit`,_tag:e.op,[e.prop]:this[Q]}},[C](t){return WD(t)&&t._tag===e.op&&w(this[Q],t[Q])},[y](){return S(this,x($e(e.op))(b(this[Q])))}};return function(e){const n=Object.create(t);n[Q]=e;n[vD]=void 0;n[yD]=void 0;n[bD]=void 0;return n}};const OD=DD({op:`Success`,prop:`value`,eval(e){const t=e.getCont(vD);return t?t[vD](this[Q],e):e.yieldWith(this)}});const kD=DD({op:`Failure`,prop:`cause`,eval(e){let t=e.getCont(yD);while(uD(this[Q])&&t&&e.interruptible)t=e.getCont(yD);return t?t[yD](this[Q],e):e.yieldWith(this)}});const AD=ED({op:`Sync`,eval(e){const t=this[Q]();const n=e.getCont(vD);return n?n[vD](t,e):e.yieldWith(GD(t))}});const jD=ED({op:`Suspend`,eval(e){return this[Q]()}});const MD=ED({op:`Yield`,eval(e){let t=false;e.getRef(rO).scheduleTask(()=>{if(t)return;e.evaluate(YD)},this[Q]??0);return e.yieldWith(()=>{t=true})}});const ND=MD(0);const PD=OD(void 0);const FD=ED({op:`WithMicroFiber`,eval(e){return this[Q](e)}});const ID=ED({op:`Async`,single:false,eval(e){const t=this[Q][0];let n=false;let r=false;const i=this[Q][1]?new AbortController:void 0;const a=t(t=>{if(n)return;n=true;if(r)e.evaluate(t);else r=t},i?.signal);if(r!==false)return r;r=true;e._yielded=()=>{n=true};if(i===void 0&&a===void 0)return xD;e._stack.push(LD(()=>{n=true;i?.abort();return a??YD}));return xD}});const LD=ED({op:`AsyncFinalizer`,ensure(e){if(e.interruptible){e.interruptible=false;e._stack.push(uO(true))}},contE(e,t){return uD(e)?VD(this[Q](),()=>kD(e)):kD(e)}});const RD=e=>ID(e,e.length>=2);const zD=t(2,(e,t)=>UD(e,e=>t));const BD=e=>oO(e,{onFailure:KD,onSuccess:GD});const VD=t(2,(e,t)=>{const n=Object.create(HD);n[Q]=e;n[vD]=t;return n});const HD=TD({op:`OnSuccess`,eval(e){e._stack.push(this);return this[Q]}});const UD=t(2,(e,t)=>VD(e,e=>OD(t(e))));const WD=e=>v(e,nD);const GD=OD;const KD=kD;const qD=KD(lD());const JD=e=>KD(sD(e));const YD=GD(void 0);const XD=e=>{for(const t of e)if(t._tag===`Failure`)return t;return YD};const ZD=`setImmediate`in globalThis?globalThis.setImmediate:e=>setTimeout(e,0);var QD=class{tasks=[];running=false;scheduleTask(e,t){this.tasks.push(e);if(!this.running){this.running=true;ZD(this.afterScheduled)}}afterScheduled=()=>{this.running=false;this.runTasks()};runTasks(){const e=this.tasks;this.tasks=[];for(let t=0,n=e.length;t<n;t++)e[t]()}shouldYield(e){return e.currentOpCount>=e.getRef(tO)}flush(){while(this.tasks.length>0)this.runTasks()}};const $D=t(2,(e,t)=>FD(n=>{const r=n.context;n.context=t(r);return lO(e,()=>{n.context=r;return PD})}));const eO=t(2,(e,t)=>$D(e,ef(t)));var tO=class extends sf()(`effect/Micro/currentMaxOpsBeforeYield`,{defaultValue:()=>2048}){};var nO=class extends sf()(`effect/Micro/currentConcurrency`,{defaultValue:()=>`unbounded`}){};var rO=class extends sf()(`effect/Micro/currentScheduler`,{defaultValue:()=>new QD}){};const iO=t(2,(e,t)=>{const n=Object.create(aO);n[Q]=e;n[vD]=t.onSuccess;n[yD]=t.onFailure;return n});const aO=TD({op:`OnSuccessAndFailure`,eval(e){e._stack.push(this);return this[Q]}});const oO=t(2,(e,t)=>iO(e,{onFailure:e=>AD(()=>t.onFailure(e)),onSuccess:e=>AD(()=>t.onSuccess(e))}));const sO=Symbol.for(`effect/Micro/MicroScope`);var cO=class e{[sO];state={_tag:`Open`,finalizers:new Set};constructor(){this[sO]=sO}unsafeAddFinalizer(e){if(this.state._tag===`Open`)this.state.finalizers.add(e)}addFinalizer(e){return jD(()=>{if(this.state._tag===`Open`){this.state.finalizers.add(e);return PD}return e(this.state.exit)})}unsafeRemoveFinalizer(e){if(this.state._tag===`Open`)this.state.finalizers.delete(e)}close(e){return jD(()=>{if(this.state._tag===`Open`){const t=Array.from(this.state.finalizers).reverse();this.state={_tag:`Closed`,exit:e};return VD(mO(t,t=>BD(t(e))),XD)}return PD})}get fork(){return AD(()=>{const t=new e;if(this.state._tag===`Closed`){t.state=this.state;return t}function n(e){return t.close(e)}this.state.finalizers.add(n);t.unsafeAddFinalizer(e=>AD(()=>this.unsafeRemoveFinalizer(n)));return t})}};const lO=t(2,(e,t)=>fO(n=>iO(n(e),{onFailure:e=>VD(t(KD(e)),()=>kD(e)),onSuccess:e=>VD(t(GD(e)),()=>OD(e))})));const uO=ED({op:`SetInterruptible`,ensure(e){e.interruptible=this[Q];if(e._interrupted&&e.interruptible)return()=>qD}});const dO=e=>FD(t=>{if(t.interruptible)return e;t.interruptible=true;t._stack.push(uO(false));if(t._interrupted)return qD;return e});const fO=e=>FD(t=>{if(!t.interruptible)return e(n);t.interruptible=false;t._stack.push(uO(true));return e(dO)});const pO=ED({op:`While`,contA(e,t){this[Q].step(e);if(this[Q].while()){t._stack.push(this);return this[Q].body()}return YD},eval(e){if(this[Q].while()){e._stack.push(this);return this[Q].body()}return YD}});const mO=(e,t,n)=>FD(r=>{const i=n?.concurrency===`inherit`?r.getRef(nO):n?.concurrency??1;const a=i===`unbounded`?Number.POSITIVE_INFINITY:Math.max(1,i);const o=I(e);let s=o.length;if(s===0)return n?.discard?PD:OD([]);const c=n?.discard?void 0:new Array(s);let l=0;if(a===1)return zD(pO({while:()=>l<o.length,body:()=>t(o[l],l),step:c?e=>c[l++]=e:e=>l++}),c);return RD(e=>{const n=new Set;let i=void 0;let u=0;let d=0;let f=false;let p=false;function m(){f=true;while(u<a&&l<s){const h=l;const g=o[h];l++;u++;try{const o=hO(r,t(g,h),true,true);n.add(o);o.addObserver(t=>{n.delete(o);if(p)return;else if(t._tag===`Failure`){if(i===void 0){i=t;s=l;n.forEach(e=>e.unsafeInterrupt())}}else if(c!==void 0)c[h]=t.value;d++;u--;if(d===s)e(i??OD(c));else if(!f&&u<a)m()})}catch(e){i=JD(e);s=l;n.forEach(e=>e.unsafeInterrupt())}}f=false}m();return jD(()=>{p=true;l=s;return hD(n)})})});const hO=(e,t,n=false,r=false)=>{const i=new pD(e.context,e.interruptible);if(!r){e.children().add(i);i.addObserver(()=>e.children().delete(i))}if(n)i.evaluate(t);else e.getRef(rO).scheduleTask(()=>i.evaluate(t),0);return i};const gO=(e,t)=>{const n=new pD(rO.context(t?.scheduler??new QD));n.evaluate(e);if(t?.signal)if(t.signal.aborted)n.unsafeInterrupt();else{const e=()=>n.unsafeInterrupt();t.signal.addEventListener(`abort`,e,{once:true});n.addObserver(()=>t.signal.removeEventListener(`abort`,e))}return n};const _O=Symbol.for(`effect/Readable`);const vO={[_O]:_O,pipe(){return O(this,arguments)}};const yO=Symbol.for(`effect/Ref`);const bO={_A:e=>e};var xO=class extends mT{ref;commit(){return this.get}[yO]=bO;[_O]=_O;constructor(e){super();this.ref=e;this.get=q(()=>Jf(this.ref))}get;modify(e){return q(()=>{const t=Jf(this.ref);const[n,r]=e(t);if(t!==r)Yf(r)(this.ref);return n})}};const SO=e=>new xO(Kf(e));const CO=e=>q(()=>SO(e));const wO=e=>e.get;const TO=t(2,(e,t)=>e.modify(()=>[void 0,t]));const EO=t(2,(e,t)=>e.modify(e=>[e,t]));const DO=t(2,(e,t)=>e.modify(e=>[e,t(e)]));const OO=t(2,(e,t)=>e.modify(e=>{const n=t(e);switch(n._tag){case`None`:return[e,e];case`Some`:return[e,n.value]}}));const kO=t(2,(e,t)=>e.modify(()=>[t,t]));const AO=t(2,(e,t)=>e.modify(t));const jO=t(3,(e,t,n)=>e.modify(e=>{const r=n(e);switch(r._tag){case`None`:return[t,e];case`Some`:return r.value}}));const MO=t(2,(e,t)=>e.modify(e=>[void 0,t(e)]));const NO=t(2,(e,t)=>e.modify(e=>{const n=t(e);return[n,n]}));const PO=t(2,(e,t)=>e.modify(e=>[void 0,Ln(t(e),{onNone:()=>e,onSome:e=>e})]));const FO=t(2,(e,t)=>e.modify(e=>{const n=t(e);switch(n._tag){case`None`:return[e,e];case`Some`:return[n.value,n.value]}}));const IO=yO;const LO=CO;const RO=wO;const zO=EO;const BO=DO;const VO=OO;const HO=AO;const UO=jO;const WO=TO;const GO=kO;const KO=MO;const qO=NO;const JO=PO;const YO=FO;const XO=SO;var ZO=class{buckets=[];scheduleTask(e,t){const n=this.buckets.length;let r=void 0;let i=0;for(;i<n;i++)if(this.buckets[i][0]<=t)r=this.buckets[i];else break;if(r&&r[0]===t)r[1].push(e);else if(i===n)this.buckets.push([t,[e]]);else this.buckets.splice(i,0,[t,[e]])}};var QO=class{maxNextTickBeforeTimer;running=false;tasks=new ZO;constructor(e){this.maxNextTickBeforeTimer=e}starveInternal(e){const t=this.tasks.buckets;this.tasks.buckets=[];for(const[e,n]of t)for(let e=0;e<n.length;e++)n[e]();if(this.tasks.buckets.length===0)this.running=false;else this.starve(e)}starve(e=0){if(e>=this.maxNextTickBeforeTimer)setTimeout(()=>this.starveInternal(0),0);else Promise.resolve(void 0).then(()=>this.starveInternal(e+1))}shouldYield(e){return e.currentOpCount>e.getFiberRef(Wb)?e.getFiberRef(Ub):false}scheduleTask(e,t){this.tasks.scheduleTask(e,t);if(!this.running){this.running=true;this.starve()}}};const $O=_(Symbol.for(`effect/Scheduler/defaultScheduler`),()=>new QO(2048));var ek=class{tasks=new ZO;deferred=false;scheduleTask(e,t){if(this.deferred)$O.scheduleTask(e,t);else this.tasks.scheduleTask(e,t)}shouldYield(e){return e.currentOpCount>e.getFiberRef(Wb)?e.getFiberRef(Ub):false}flush(){while(this.tasks.buckets.length>0){const e=this.tasks.buckets;this.tasks.buckets=[];for(const[t,n]of e)for(let e=0;e<n.length;e++)n[e]()}this.deferred=true}};const tk=_(Symbol.for(`effect/FiberRef/currentScheduler`),()=>Ib($O));const nk=t(2,(e,t)=>Pb(e,tk,t));const rk=_(Symbol.for(`effect/FiberRef/currentRequestMap`),()=>Ib(new Map));const ik=(e,t,n,r)=>{switch(e){case void 0:return t();case`unbounded`:return n();case`inherit`:return Eb(Xb,e=>e===`unbounded`?n():e>1?r(e):t());default:return e>1?r(e):t()}};const ak=(e,t,n)=>{switch(e){case void 0:return t();case`unbounded`:return n();case`inherit`:return Eb(Xb,e=>e===`unbounded`||e>1?n():t());default:return e>1?n():t()}};const ok=YS;const sk=nC;const ck=Sw;const lk=Tw;const uk=Ew;const dk=ww;const fk=XS;const pk=(e,t)=>({label:e,startTime:t});const mk=e=>e.replace(/[\s="]/g,`_`);const hk=e=>t=>{const n=mk(t.label);return`${n}=${e-t.startTime}ms`};const gk=pk;const _k=hk;const vk=uw;const yk=pw;const bk=fw;const xk=dw;const Sk=_w;const Ck=Mw;const wk=yw;const Tk=`effect/MetricLabel`;const Ek=Symbol.for(Tk);var Dk=class{key;value;[Ek]=Ek;_hash;constructor(e,t){this.key=e;this.value=t;this._hash=$e(Tk+this.key+this.value)}[y](){return this._hash}[C](e){return kk(e)&&this.key===e.key&&this.value===e.value}pipe(){return O(this,arguments)}};const Ok=(e,t)=>{return new Dk(e,t)};const kk=e=>v(e,Ek);const Ak=t(e=>z(e[0]),function(){const e=arguments;return Fb(e[0],Gb,typeof e[1]===`string`?Qp(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,n])=>Qp(e,t,n),t))});const jk=e=>W(e,P);const Mk=e=>Fy(e,P);const Nk=e=>{let t;let n=void 0;if(typeof e===`function`)t=e;else{t=e.try;n=e.catch}return K(()=>{try{return G(Ke(t))}catch(e){return V(n?Ke(()=>n(e)):new Fx(e,`An unknown error occurred in Effect.try`))}})};const Pk=t(3,(e,t,n)=>iy(e,e=>{if(v(e,t)&&e[t]===n.failure)return n.onFailure(e);return V(e)}));const Fk=t(2,(e,t)=>ry(e,e=>{const n=Gu(e,e=>Tu(e)?P(e):N());switch(n._tag){case`None`:return H(e);case`Some`:return t(n.value.defect)}}));const Ik=t(2,(e,t)=>wy(e,{onFailure:e=>{const n=t(e);switch(n._tag){case`None`:return H(e);case`Some`:return n.value}},onSuccess:G}));const Lk=t(2,(e,t)=>ry(e,e=>{const n=Gu(e,e=>Tu(e)?P(e):N());switch(n._tag){case`None`:return H(e);case`Some`:{const r=t(n.value.defect);return r._tag===`Some`?r.value:H(e)}}}));const Rk=t(e=>z(e[0]),(e,...t)=>{const n=t[t.length-1];let r;if(t.length===2)r=_e(t[0]);else r=e=>{const n=v(e,`_tag`)?e[`_tag`]:void 0;if(!n)return false;for(let e=0;e<t.length-1;e++)if(t[e]===n)return true;return false};return ay(e,r,n)});const zk=t(2,(e,t)=>{let n;return ay(e,e=>{n??=Object.keys(t);return v(e,`_tag`)&&se(e[`_tag`])&&n.includes(e[`_tag`])},e=>t[e[`_tag`]](e))});const Bk=e=>Cy(e,{onFailure:n,onSuccess:()=>_u});const Vk=dk;const Hk=Vk(G);const Uk=t(2,(e,t)=>Y(ck(t),e));const Wk=e=>B((t,n)=>e({id:t.id(),status:n,interruptors:ju(t.getFiberRef(ix))}));const Gk=Wk(e=>Gl(e.interruptors)>0?ky:J);const Kk=Wk(G);const qk=e=>dj(e,_A,fE);const Jk=e=>dj(e,sb(_A,Uy),([e,t],[n,r])=>[fE(e,n),B_(t,r)]);const Yk=G({});const Xk=ie(W,U);const Zk=re(W);const Qk=ne(W);const $k=t(2,(e,t)=>K(()=>{const n=e[Symbol.iterator]();const r=[];let i;let a=G(false);let o=0;while((i=n.next())&&!i.done){const e=i.value;const n=o++;a=U(a,i=>{if(i){r.push(e);return G(true)}return t(e,n)})}return W(a,()=>r)}));const eA=t(2,(e,t)=>K(()=>{const n=e[Symbol.iterator]();const r=[];let i;let a=G(true);let o=0;while((i=n.next())&&!i.done){const e=i.value;const n=o++;a=U(a,i=>W(i?t(e,n):G(false),t=>{if(!t)r.push(e);return t}))}return W(a,()=>r)}));const tA=e=>W(RS(),e);const nA=e=>zy(e,()=>U(ob(),()=>nA(e)));const rA=t(2,(e,t)=>W(Ey(e,n),ri(t)));const iA=t(3,(e,t,n)=>oA(e,t,e=>fy(()=>n(e))));const aA=t(3,(e,t,n)=>oA(e,t,()=>dy(n)));const oA=t(3,(e,t,n)=>U(e,e=>t(e)?G(e):n(e)));const sA=t(3,(e,t,n)=>K(()=>t(e)?G(e):V(n(e))));const cA=t(e=>z(e[0]),(e,t,n)=>oA(e,t,e=>n===void 0?V(new Tx):hy(()=>n(e))));const lA=t(2,(e,t)=>K(()=>{const n=e[Symbol.iterator]();const r=n.next();if(!r.done)return uA(n,0,t,r.value);return G(N())}));const uA=(e,t,n,r)=>U(n(r,t),i=>{if(i)return G(P(r));const a=e.next();if(!a.done)return uA(e,t+1,n,a.value);return G(N())});const dA=e=>K(()=>{const t=hs(e);if(!ks(t))return fy(()=>new Cx(`Received an empty collection of effects`));return c(Ms(t),oi(R(t),(e,t)=>zy(e,()=>t)))});const fA=t(2,(e,t)=>Sy(t(Sy(e))));const pA=t(2,(e,t)=>Ty(e,{onFailure:e=>G(t.onFailure(e)),onSuccess:e=>G(t.onSuccess(e))}));const mA=t(2,(e,t)=>K(()=>hA(e[Symbol.iterator](),0,t)));const hA=(e,t,n)=>{const r=e.next();return r.done?G(true):U(n(r.value,t),r=>r?hA(e,t+1,n):G(r))};const gA=e=>{const t=U(U(e,()=>ob()),()=>t);return t};const _A=B(e=>G(e.getFiberRefs()));const vA=e=>U(e,e=>{const t=e[Symbol.iterator]();const n=t.next();if(n.done)return V(new Tx);return G(n.value)});const yA=e=>pA(e,{onFailure:s,onSuccess:s});const bA=e=>wy(e,{onFailure:e=>OA(e,`An error was silently ignored because it is not anticipated to be useful`),onSuccess:()=>J});const xA=e=>jj((t,n)=>eE(n,t,e));const SA=e=>pA(e,{onFailure:i,onSuccess:a});const CA=e=>pA(e,{onFailure:a,onSuccess:i});const wA=(e,t)=>K(()=>{if(t.while(e))return U(t.body(e),e=>wA(e,t));return G(e)});const TA=e=>(...t)=>{const n=Un(e);let r=void 0;for(let e=0,n=t.length;e<n;e++){const n=t[e];if(Cu(n)){if(r!==void 0)r=Su(r,n);else r=n;t=[...t.slice(0,e),...t.slice(e+1)];e--}}if(r===void 0)r=_u;return B(e=>{e.log(t,r,n);return J})};const EA=TA();const DA=TA(YE);const OA=TA(JE);const kA=TA(qE);const AA=TA(KE);const jA=TA(GE);const MA=TA(WE);const NA=t(2,(e,t)=>U(lk,n=>Fb(e,qb,Vm(gk(t,n)))));const PA=Tb(Gb);const FA=(e,t)=>t.discard?LA(e,t.while,t.step,t.body):W(IA(e,t.while,t.step,t.body),I);const IA=(e,t,n,r)=>K(()=>t(e)?U(r(e),i=>W(IA(n(e),t,n,r),Vm(i))):q(()=>Rm()));const LA=(e,t,n,r)=>K(()=>t(e)?U(r(e),()=>LA(n(e),t,n,r)):J);const RA=t(3,(e,t,n)=>K(()=>{const r=e[Symbol.iterator]();const i=[];let a=G(t);let o;let s=0;while(!(o=r.next()).done){const e=s++;const t=o.value;a=U(a,r=>W(n(r,t,e),([e,t])=>{i.push(t);return e}))}return W(a,e=>[e,i])}));const zA=t(2,(e,t)=>wy(e,{onFailure:e=>gy(()=>t(e)),onSuccess:G}));const BA=e=>c(_S(),U(t=>c(Jk(e),Ny(t),WA,W(e=>Y(e,c(yS(t),U(([e,t])=>Zv(sb(YA(e[0]),Yy(e[1])),t))))))));const VA=e=>Ty(e,{onFailure:e=>G(e),onSuccess:G});const HA=e=>W(e,e=>!e);const UA=e=>U(e,e=>{switch(e._tag){case`None`:return J;case`Some`:return V(new Tx)}});const WA=e=>W(LO(true),t=>Qv(Xy(e,zO(t,false))));const GA=e=>Ty(e,{onFailure:()=>G(N()),onSuccess:e=>G(P(e))});const KA=t(2,(e,t)=>zy(e,()=>hy(t)));const qA=t(2,(e,t)=>zy(e,()=>q(t)));const JA=e=>wy(e,{onFailure:e=>{const t=I(ku(e));return t.length===0?H(e):V(t)},onSuccess:G});const YA=e=>jj((t,n)=>c(e,mE(t,n)));const XA=e=>e.length>=1?ny((t,n)=>{try{e(n).then(e=>t(Z(e)),e=>t(Wx(e)))}catch(e){t(Wx(e))}}):ny(t=>{try{e().then(e=>t(Z(e)),e=>t(Wx(e)))}catch(e){t(Wx(e))}});const ZA=t(3,(e,t,n)=>zS(r=>BS(e,Yd(r,t,n))));const QA=t(3,(e,t,n)=>zS(r=>U(n,n=>BS(e,c(r,Yd(t,n))))));const $A=Aw(G);const ej=t(3,(e,t,n)=>I(e).reduce((e,t,r)=>U(e,e=>n(e,t,r)),G(t)));const tj=t(3,(e,t,n)=>I(e).reduceRight((e,t,r)=>U(e,e=>n(t,e,r)),G(t)));const nj=t(3,(e,t,n)=>U(q(()=>e[Symbol.iterator]()),e=>rj(e,0,t,n.while,n.body)));const rj=(e,t,n,r,i)=>{const a=e.next();if(!a.done&&r(n))return U(i(n,a.value,t),n=>rj(e,t+1,n,r,i));return G(n)};const ij=t(2,(e,t)=>K(()=>aj(e,t)));const aj=(e,t)=>U(e,n=>t<=0?G(n):Y(ob(),aj(e,t-1)));const oj=e=>wy(e,{onFailure:V,onSuccess:G});const sj=e=>K(()=>tE(e));const cj=ck;const lj=G(N());const uj=e=>G(P(e));const dj=t(3,(e,t,n)=>U(t,r=>U(e,e=>W(t,t=>[n(r,t),e]))));const fj=t(e=>z(e[0]),function(){return pj(arguments[0],typeof arguments[1]===`string`?[Ok(arguments[1],arguments[2])]:Object.entries(arguments[1]).map(([e,t])=>Ok(e,t)))});const pj=t(2,(e,t)=>Fb(e,tx,e=>Zr(e,t)));const mj=t(2,(e,t)=>K(()=>{const n=e[Symbol.iterator]();const r=[];let i;let a=G(false);let o=0;while((i=n.next())&&!i.done){const e=i.value;const n=o++;a=U(a,i=>{if(i)return G(true);r.push(e);return t(e,n)})}return W(a,()=>r)}));const hj=t(2,(e,t)=>K(()=>{const n=e[Symbol.iterator]();const r=[];let i;let a=G(true);let o=0;while((i=n.next())&&!i.done){const e=i.value;const n=o++;a=U(a,i=>c(i?t(e,n):G(false),W(t=>{if(t)r.push(e);return t})))}return W(a,()=>r)}));const gj=t(2,(e,{onFailure:t,onSuccess:n})=>wy(e,{onFailure:e=>{const n=Nu(e);switch(n._tag){case`Left`:return Y(t(n.left),H(e));case`Right`:return H(e)}},onSuccess:e=>Zv(n(e),e)}));const _j=t(2,(e,t)=>ry(e,e=>Ln(Fu(e),{onNone:()=>H(e),onSome:n=>Y(t(n),H(e))})));const vj=t(2,(e,t)=>wy(e,{onFailure:e=>{const n=Nu(e);switch(n._tag){case`Left`:return Y(t(n.left),H(e));case`Right`:return H(e)}},onSuccess:G}));const yj=t(3,(e,t,n)=>vj(e,e=>{if(_e(e,t))return n(e);return J}));const bj=t(2,(e,t)=>wy(e,{onFailure:e=>Y(t(e),H(e)),onSuccess:G}));const xj=e=>Sj(e,uk);const Sj=t(2,(e,t)=>dj(e,t,(e,t)=>Tf(t-e)));const Cj=Ck;const wj=Cj(G);const Tj=e=>{let t;let n=void 0;if(typeof e===`function`)t=e;else{t=e.try;n=e.catch}const r=e=>n?hy(()=>n(e)):V(new Fx(e,`An unknown error occurred in Effect.tryPromise`));if(t.length>=1)return ny((e,n)=>{try{t(n).then(t=>e(Z(t)),t=>e(r(t)))}catch(t){e(r(t))}});return ny(e=>{try{t().then(t=>e(Z(t)),t=>e(r(t)))}catch(t){e(r(t))}})};const Ej=t(2,(e,t)=>U(e,e=>Nk({try:()=>t.try(e),catch:t.catch})));const Dj=t(2,(e,t)=>U(e,e=>Tj({try:t.try.length>=1?n=>t.try(e,n):()=>t.try(e),catch:t.catch})));const Oj=t(2,(e,t)=>K(()=>t()?lj:jk(e)));const kj=t(2,(e,t)=>U(t,t=>t?lj:jk(e)));const Aj=e=>zA(e,Vu);const jj=e=>B(t=>{t.setFiberRefs(e(t.id(),t.getFiberRefs()));return J});const Mj=t(3,(e,t,n)=>HS(e,e=>Yd(e,t,n(Qd(e,t)))));const Nj=t(2,(e,t)=>K(()=>t()?W(e,P):G(N())));const Pj=t(3,(e,t,n)=>U(Tb(t),t=>n(t)?W(e,e=>[t,P(e)]):G([t,N()])));const Fj=t(3,(e,t,n)=>U(RO(t),t=>n(t)?W(e,e=>[t,P(e)]):G([t,N()])));const Ij=t(2,(e,t)=>t(e));const Lj=(e,t)=>(...n)=>U(e,e=>t(e)(...n));const Rj=(e,t)=>(...n)=>W(e,e=>t(e)(...n));const zj=e=>new Proxy({},{get(t,n,r){return(...t)=>U(e,e=>e[n](...t))}});const Bj=e=>new Proxy({},{get(t,n,r){return U(e,e=>z(e[n])?e[n]:G(e[n]))}});const Vj=e=>({functions:zj(e),constants:Bj(e)});const Hj=e=>W(RS(),$d(e));const Uj=e=>U(RS(),$d(e));const Wj=function(){const e=arguments;return yA(U(Jj,t=>q(()=>{if(typeof e[0]===`string`)t.attribute(e[0],e[1]);else for(const n in e[0])t.attribute(n,e[0][n])})))};const Gj=function(){const e=arguments;const t=Array.isArray(e[0])?e[0]:[{_tag:`SpanLink`,span:e[0],attributes:e[1]??{}}];return yA(U(Jj,e=>q(()=>e.addLinks(t))))};const Kj=t(e=>z(e[0]),function(){const e=arguments;return Fb(e[0],sx,typeof e[1]===`string`?Qp(e[1],e[2]):t=>Object.entries(e[1]).reduce((e,[t,n])=>Qp(e,t,n),t))});const qj=Uj(pw);const Jj=U(RS(),e=>{const t=e.unsafeMap.get(pw.key);return t!==void 0&&t._tag===`Span`?G(t):V(new Tx)});const Yj=t(e=>z(e[0]),(e,t,n)=>Fb(e,cx,Ts({_tag:`SpanLink`,span:t,attributes:n??{}})));const Xj=BigInt(0);const Zj=Yn(e=>Xd(e.context,yw)?e._tag===`Span`?Zj(e.parent):N():P(e));const Qj=(e,t,n)=>{const r=!e.getFiberRef(ax)||n.context&&Xd(n.context,yw);const i=e.getFiberRef(Hb);const a=n.parent?P(n.parent):n.root?N():Zj($d(i,pw));let o;if(r)o=qS({name:t,parent:a,context:Yd(n.context??qd(),yw,true)});else{const r=e.getFiberRef(xw);const i=Xd(r,fw);const s=Xd(r,fk);const c=e.getFiberRef(ox);const l=e.getFiberRefs();const u=QT(l,sx);const d=QT(l,cx);const f=d._tag===`Some`?n.links!==void 0?[...vs(d.value),...n.links??[]]:vs(d.value):n.links??Qr();o=i.span(t,a,n.context??qd(),f,c?s.unsafeCurrentTimeNanos():Xj,n.kind??`internal`);if(u._tag===`Some`)gm(u.value,(e,t)=>o.attribute(t,e));if(n.attributes!==void 0)Object.entries(n.attributes).forEach(([e,t])=>o.attribute(e,t))}if(typeof n.captureStackTrace===`function`)id.set(o,n.captureStackTrace);return o};const $j=(e,t)=>{t=vw(t);return B(n=>G(Qj(n,e,t)))};const eM=Tb(sx);const tM=Tb(cx);const nM=(e,t,n,r)=>q(()=>{if(e.status._tag===`Ended`)return;if(Lx(t)&&id.has(e))e.attribute(`code.stacktrace`,id.get(e)());e.end(r?n.unsafeCurrentTimeNanos():Xj,t)});const rM=(e,...t)=>{const n=vw(t.length===1?void 0:t[0]);const r=t[t.length-1];return B(t=>{const i=Qj(t,e,n);const a=t.getFiberRef(ox);const o=Xd(t.getFiberRef(xw),XS);return Ly(r(i),e=>nM(i,e,o,a))})};const iM=t(2,(e,t)=>ZA(e,pw,t));const aM=function(){const e=typeof arguments[0]!==`string`;const t=e?arguments[1]:arguments[0];const n=vw(e?arguments[2]:arguments[1]);if(e){const e=arguments[0];return rM(t,n,t=>iM(e,t))}return e=>rM(t,n,t=>iM(e,t))};const oM=e=>function(){let t=e.captureStackTrace??false;if(e.captureStackTrace!==false){const e=Error.stackTraceLimit;Error.stackTraceLimit=2;const n=new Error;Error.stackTraceLimit=e;let r=false;t=()=>{if(r!==false)return r;if(n.stack){const e=n.stack.trim().split(`
`);r=e.slice(2).join(`
`).trim();return r}}}return K(()=>{const n=typeof e.options===`function`?e.options.apply(null,arguments):e.options;return aM(K(()=>Ke(()=>e.body.apply(this,arguments))),n.name,{...n,captureStackTrace:t})})};const sM=e=>e==null?V(new Tx):G(e);const cM=e=>iy(W(e,P),e=>Ex(e)?lj:V(e));const lM=Ix;const uM=Lx;const dM=Rx;const fM=zx;const pM=Bx;const mM=Vx;const hM=Hx;const gM=Ux;const _M=Wx;const vM=Gx;const yM=Kx;const bM=X;const xM=qx;const SM=Jx;const CM=Yx;const wM=Xx;const TM=Zx;const EM=Qx;const DM=$x;const OM=eS;const kM=tS;const AM=nS;const jM=rS;const MM=iS;const NM=aS;const PM=oS;const FM=Z;const IM=sS;const LM=cS;const RM=lS;const zM=uS;const BM=dS;const VM=fS;const HM=pS;const UM=mS;const WM=`InterruptSignal`;const GM=`Stateful`;const KM=`Resume`;const qM=`YieldNow`;const JM=e=>({_tag:WM,cause:e});const YM=e=>({_tag:GM,onFiber:e});const XM=e=>({_tag:KM,effect:e});const ZM=()=>({_tag:qM});const QM=`effect/FiberScope`;const $M=Symbol.for(QM);var eN=class{[$M]=$M;fiberId=Cp;roots=new Set;add(e,t){this.roots.add(t);t.addObserver(()=>{this.roots.delete(t)})}};var tN=class{fiberId;parent;[$M]=$M;constructor(e,t){this.fiberId=e;this.parent=t}add(e,t){this.parent.tell(YM(e=>{e.addChild(t);t.addObserver(()=>{e.removeChild(t)})}))}};const nN=e=>{return new tN(e.id(),e)};const rN=_(Symbol.for(`effect/FiberScope/Global`),()=>new eN);const iN=`effect/Fiber`;const aN=Symbol.for(iN);const oN={_E:e=>e,_A:e=>e};const sN={[aN]:oN,pipe(){return O(this,arguments)}};const cN=`effect/Fiber`;const lN=Symbol.for(cN);const uN=c(jn(gi,gi),kn(e=>[e.id().startTimeMillis,e.id().id]));const dN=e=>v(e,aN);const fN=e=>lN in e;const pN=e=>e.await;const mN=e=>e.children;const hN=e=>{const t={...zt,commit(){return DN(this)},...sN,id:()=>Cp,await:G(e),children:G([]),inheritAll:J,poll:G(P(e)),interruptAsFork:()=>J};return t};const gN=e=>W(e.status,t=>({id:e.id(),status:t}));const _N=e=>Ey(e,gN);const vN=e=>hN(yM(e));const yN=e=>hN(bM(e));const bN=e=>W(my(e),hN);const xN=e=>e.id();const SN=e=>e.inheritAll;const CN=e=>hN(OM(e));const wN=e=>U(_y,t=>c(e,TN(t)));const TN=t(2,(e,t)=>c(Dy(e,EN(t)),Y(c(e,Dy(pN)))));const EN=t(2,(e,t)=>e.interruptAsFork(t));const DN=e=>cb(xy(e.await),e.inheritAll);const ON=t(2,(e,t)=>kN(e,e=>q(()=>t(e))));const kN=t(2,(e,t)=>{const n={...zt,commit(){return DN(this)},...sN,id:()=>e.id(),await:U(e.await,wM(t)),children:e.children,inheritAll:e.inheritAll,poll:U(e.poll,e=>{switch(e._tag){case`None`:return G(N());case`Some`:return c(wM(e.value,t),W(P))}}),interruptAsFork:t=>e.interruptAsFork(t)};return n});const AN=t(2,(e,t)=>W(e.await,NM({onFailure:e=>yN(e),onSuccess:e=>t(e)})));const jN=t(2,(e,{onFiber:t,onRuntimeFiber:n})=>{if(fN(e))return n(e);return t(e)});const MN={...zt,commit(){return DN(this)},...sN,id:()=>Cp,await:ub,children:G([]),inheritAll:ub,poll:G(N()),interruptAsFork:()=>ub};const NN=MN;const PN=t(2,(e,t)=>({...zt,commit(){return DN(this)},...sN,id:()=>Mp(e.id(),t.id()),await:lb(e.await,t.await,(e,t)=>dM(e)?e:t),children:e.children,inheritAll:Y(t.inheritAll,e.inheritAll),poll:lb(e.poll,t.poll,(e,t)=>{switch(e._tag){case`None`:return N();case`Some`:return dM(e.value)?e:t}}),interruptAsFork:n=>c(fb(e,n),Y(c(t,fb(n))),Qv)}));const FN=t(2,(e,t)=>PN(ON(e,M),ON(t,j)));const IN=e=>e.poll;const LN=e=>{const t=e>0?Math.floor:Math.ceil;return{days:t(e/864e5),hours:t(e/36e5)%24,minutes:t(e/6e4)%60,seconds:t(e/1e3)%60,milliseconds:t(e)%1e3,microseconds:t(e*1e3)%1e3,nanoseconds:t(e*1e6)%1e3}};const RN=e=>{if(BE(e))return`Done`;if(VE(e))return`Running`;const t=A_(e.runtimeFlags)?`interruptible`:`uninterruptible`;return`Suspended(${t})`};const zN=e=>U(lk,t=>W(gN(e),e=>{const n=t-e.id.startTimeMillis;const{days:r,hours:i,milliseconds:a,minutes:o,seconds:s}=LN(n);const c=(r===0?``:`${r}d`)+(r===0&&i===0?``:`${i}h`)+(r===0&&i===0&&o===0?``:`${o}m`)+(r===0&&i===0&&o===0&&s===0?``:`${s}s`)+`${a}ms`;const l=HE(e.status)?(()=>{const t=Np(e.status.blockingOn);return Gl(t)>0?`waiting on `+Array.from(t).map(e=>`${e}`).join(`, `):``})():``;const u=RN(e.status);return`[Fiber](#${e.id.id}) (${c}) ${l}\n   Status: ${u}`}));const BN=()=>Array.from(rN.roots);const VN=q(BN);const HN=e=>e.status;const UN=e=>hN(FM(e));const WN=UN(void 0);const GN=`effect/FiberCurrent`;const KN=()=>Un(globalThis[GN]);const qN=`effect/Logger`;const JN=Symbol.for(qN);const YN={_Message:e=>e,_Output:e=>e};const XN=e=>({[JN]:YN,log:e,pipe(){return O(this,arguments)}});const ZN=t(2,(e,t)=>XN(n=>t(e.log(n))));const QN={[JN]:YN,log:s,pipe(){return O(this,arguments)}};const $N=/^[^\s"=]*$/;const eP=(e,t)=>({annotations:n,cause:r,date:i,fiberId:a,logLevel:o,message:s,spans:c})=>{const l=t=>t.match($N)?t:e(t);const u=(e,t)=>`${mk(e)}=${l(t)}`;const d=(e,t)=>` `+u(e,t);let f=u(`timestamp`,i.toISOString());f+=d(`level`,o.label);f+=d(`fiber`,vp(a));const p=fr(s);for(let e=0;e<p.length;e++)f+=d(`message`,ct(p[e],t));if(!wu(r))f+=d(`cause`,$u(r,{renderErrorCause:true}));for(const e of c)f+=` `+hk(i.getTime())(e);for(const[e,r]of n)f+=d(e,ct(r,t));return f};const tP=e=>`"${e.replace(/\\([\s\S])|(")/g,`\\$1$2`)}"`;const nP=XN(eP(tP));const rP=XN(({annotations:e,cause:t,date:n,fiberId:r,logLevel:i,message:a,spans:o})=>{const s=n.getTime();const c={};const l={};if(rm(e)>0)for(const[t,n]of e)c[t]=iP(n);if(Fm(o))for(const e of o)l[e.label]=s-e.startTime;const u=fr(a);return{message:u.length===1?iP(u[0]):u.map(iP),logLevel:i.label,timestamp:n.toISOString(),cause:Eu(t)?void 0:$u(t,{renderErrorCause:true}),annotations:c,spans:l,fiberId:vp(r)}});const iP=e=>{switch(typeof e){case`bigint`:case`function`:case`symbol`:return String(e);default:return E(e)}};const aP=ZN(rP,lt);const oP={bold:`1`,red:`31`,green:`32`,yellow:`33`,blue:`34`,cyan:`36`,white:`37`,gray:`90`,black:`30`,bgBrightRed:`101`};const sP={None:[],All:[],Trace:[oP.gray],Debug:[oP.blue],Info:[oP.green],Warning:[oP.yellow],Error:[oP.red],Fatal:[oP.bgBrightRed,oP.black]};const cP=typeof process===`object`&&process!==null&&typeof process.stdout===`object`&&process.stdout!==null;const lP=cP&&process.stdout.isTTY===true;const uP=cP||`Deno`in globalThis;const dP=`effect/MetricBoundaries`;const fP=Symbol.for(dP);var pP=class{values;[fP]=fP;constructor(e){this.values=e;this._hash=c($e(dP),x(nt(this.values)))}_hash;[y](){return this._hash}[C](e){return mP(e)&&w(this.values,e.values)}pipe(){return O(this,arguments)}};const mP=e=>v(e,fP);const hP=e=>{const t=c(e,vr(ms(Number.POSITIVE_INFINITY)),fi);return new pP(t)};const gP=e=>c(dr(e.count-1,t=>e.start*Math.pow(e.factor,t)),Ss,hP);const _P=`effect/MetricKeyType`;const vP=Symbol.for(_P);const yP=`effect/MetricKeyType/Counter`;const bP=Symbol.for(yP);const xP=`effect/MetricKeyType/Frequency`;const SP=Symbol.for(xP);const CP=`effect/MetricKeyType/Gauge`;const wP=Symbol.for(CP);const TP=`effect/MetricKeyType/Histogram`;const EP=Symbol.for(TP);const DP=`effect/MetricKeyType/Summary`;const OP=Symbol.for(DP);const kP={_In:e=>e,_Out:e=>e};var AP=class{incremental;bigint;[vP]=kP;[bP]=bP;constructor(e,t){this.incremental=e;this.bigint=t;this._hash=$e(yP)}_hash;[y](){return this._hash}[C](e){return zP(e)}pipe(){return O(this,arguments)}};const jP=$e(xP);var MP=class{preregisteredWords;[vP]=kP;[SP]=SP;constructor(e){this.preregisteredWords=e}[y](){return jP}[C](e){return BP(e)}pipe(){return O(this,arguments)}};const NP=$e(CP);var PP=class{bigint;[vP]=kP;[wP]=wP;constructor(e){this.bigint=e}[y](){return NP}[C](e){return VP(e)}pipe(){return O(this,arguments)}};var FP=class{boundaries;[vP]=kP;[EP]=EP;constructor(e){this.boundaries=e;this._hash=c($e(TP),x(b(this.boundaries)))}_hash;[y](){return this._hash}[C](e){return HP(e)&&w(this.boundaries,e.boundaries)}pipe(){return O(this,arguments)}};var IP=class{maxAge;maxSize;error;quantiles;[vP]=kP;[OP]=OP;constructor(e,t,n,r){this.maxAge=e;this.maxSize=t;this.error=n;this.quantiles=r;this._hash=c($e(DP),x(b(this.maxAge)),x(b(this.maxSize)),x(b(this.error)),x(nt(this.quantiles)))}_hash;[y](){return this._hash}[C](e){return UP(e)&&w(this.maxAge,e.maxAge)&&this.maxSize===e.maxSize&&this.error===e.error&&w(this.quantiles,e.quantiles)}pipe(){return O(this,arguments)}};const LP=e=>new AP(e?.incremental??false,e?.bigint??false);const RP=e=>{return new FP(e)};const zP=e=>v(e,bP);const BP=e=>v(e,SP);const VP=e=>v(e,wP);const HP=e=>v(e,EP);const UP=e=>v(e,OP);const WP=`effect/MetricKey`;const GP=Symbol.for(WP);const KP={_Type:e=>e};const qP=ui(w);var JP=class{name;keyType;description;tags;[GP]=KP;constructor(e,t,n,r=[]){this.name=e;this.keyType=t;this.description=n;this.tags=r;this._hash=c($e(this.name+this.description),x(b(this.keyType)),x(nt(this.tags)))}_hash;[y](){return this._hash}[C](e){return YP(e)&&this.name===e.name&&w(this.keyType,e.keyType)&&w(this.description,e.description)&&qP(this.tags,e.tags)}pipe(){return O(this,arguments)}};const YP=e=>v(e,GP);const XP=(e,t)=>new JP(e,LP(t),Un(t?.description));const ZP=(e,t,n)=>new JP(e,RP(t),Un(n));const QP=t(2,(e,t)=>t.length===0?e:new JP(e.name,e.keyType,e.description,Zr(e.tags,t)));const $P=Symbol.for(`effect/MutableHashMap`);const eF={[$P]:$P,[Symbol.iterator](){return new tF(this)},toString(){return D(this.toJSON())},toJSON(){return{_id:`MutableHashMap`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};var tF=class e{self;referentialIterator;bucketIterator;constructor(e){this.self=e;this.referentialIterator=e.referential[Symbol.iterator]()}next(){if(this.bucketIterator!==void 0)return this.bucketIterator.next();const e=this.referentialIterator.next();if(e.done){this.bucketIterator=new nF(this.self.buckets.values());return this.next()}return e}[Symbol.iterator](){return new e(this.self)}};var nF=class{backing;constructor(e){this.backing=e}currentBucket;next(){if(this.currentBucket===void 0){const e=this.backing.next();if(e.done)return e;this.currentBucket=e.value[Symbol.iterator]()}const e=this.currentBucket.next();if(e.done){this.currentBucket=void 0;return this.next()}return e}};const rF=()=>{const e=Object.create(eF);e.referential=new Map;e.buckets=new Map;e.bucketsSize=0;return e};const iF=t(2,(e,t)=>{if(it(t)===false)return e.referential.has(t)?P(e.referential.get(t)):N();const n=t[y]();const r=e.buckets.get(n);if(r===void 0)return N();return aF(e,r,t)});const aF=(e,t,n,r=false)=>{for(let i=0,a=t.length;i<a;i++)if(n[C](t[i][0])){const n=t[i][1];if(r){t.splice(i,1);e.bucketsSize--}return P(n)}return N()};const oF=t(2,(e,t)=>F(iF(e,t)));const sF=t(3,(e,t,n)=>{if(it(t)===false){e.referential.set(t,n);return e}const r=t[y]();const i=e.buckets.get(r);if(i===void 0){e.buckets.set(r,[[t,n]]);e.bucketsSize++;return e}cF(e,i,t);i.push([t,n]);e.bucketsSize++;return e});const cF=(e,t,n)=>{for(let r=0,i=t.length;r<i;r++)if(n[C](t[r][0])){t.splice(r,1);e.bucketsSize--;return}};const lF=t(2,(e,t)=>{if(it(t)===false){e.referential.delete(t);return e}const n=t[y]();const r=e.buckets.get(n);if(r===void 0)return e;cF(e,r,t);if(r.length===0)e.buckets.delete(n);return e});const uF=e=>{return e.referential.size+e.bucketsSize};const dF=`effect/MetricState`;const fF=Symbol.for(dF);const pF=`effect/MetricState/Counter`;const mF=Symbol.for(pF);const hF=`effect/MetricState/Frequency`;const gF=Symbol.for(hF);const _F=`effect/MetricState/Gauge`;const vF=Symbol.for(_F);const yF=`effect/MetricState/Histogram`;const bF=Symbol.for(yF);const xF=`effect/MetricState/Summary`;const SF=Symbol.for(xF);const CF={_A:e=>e};var wF=class{count;[fF]=CF;[mF]=mF;constructor(e){this.count=e}[y](){return c(b(pF),x(b(this.count)),S(this))}[C](e){return FF(e)&&this.count===e.count}pipe(){return O(this,arguments)}};const TF=ui(w);var EF=class{occurrences;[fF]=CF;[gF]=gF;constructor(e){this.occurrences=e}_hash;[y](){return c($e(hF),x(nt(I(this.occurrences.entries()))),S(this))}[C](e){return IF(e)&&TF(I(this.occurrences.entries()),I(e.occurrences.entries()))}pipe(){return O(this,arguments)}};var DF=class{value;[fF]=CF;[vF]=vF;constructor(e){this.value=e}[y](){return c(b(_F),x(b(this.value)),S(this))}[C](e){return LF(e)&&this.value===e.value}pipe(){return O(this,arguments)}};var OF=class{buckets;count;min;max;sum;[fF]=CF;[bF]=bF;constructor(e,t,n,r,i){this.buckets=e;this.count=t;this.min=n;this.max=r;this.sum=i}[y](){return c(b(yF),x(b(this.buckets)),x(b(this.count)),x(b(this.min)),x(b(this.max)),x(b(this.sum)),S(this))}[C](e){return RF(e)&&w(this.buckets,e.buckets)&&this.count===e.count&&this.min===e.min&&this.max===e.max&&this.sum===e.sum}pipe(){return O(this,arguments)}};var kF=class{error;quantiles;count;min;max;sum;[fF]=CF;[SF]=SF;constructor(e,t,n,r,i,a){this.error=e;this.quantiles=t;this.count=n;this.min=r;this.max=i;this.sum=a}[y](){return c(b(xF),x(b(this.error)),x(b(this.quantiles)),x(b(this.count)),x(b(this.min)),x(b(this.max)),x(b(this.sum)),S(this))}[C](e){return zF(e)&&this.error===e.error&&w(this.quantiles,e.quantiles)&&this.count===e.count&&this.min===e.min&&this.max===e.max&&this.sum===e.sum}pipe(){return O(this,arguments)}};const AF=e=>new wF(e);const jF=e=>{return new EF(e)};const MF=e=>new DF(e);const NF=e=>new OF(e.buckets,e.count,e.min,e.max,e.sum);const PF=e=>new kF(e.error,e.quantiles,e.count,e.min,e.max,e.sum);const FF=e=>v(e,mF);const IF=e=>v(e,gF);const LF=e=>v(e,vF);const RF=e=>v(e,bF);const zF=e=>v(e,SF);const BF=`effect/MetricHook`;const VF=Symbol.for(BF);const HF={_In:e=>e,_Out:e=>e};const UF=e=>({[VF]:HF,pipe(){return O(this,arguments)},...e});const WF=BigInt(0);const GF=e=>{let t=e.keyType.bigint?WF:0;const n=e.keyType.incremental?e.keyType.bigint?e=>e>=WF:e=>e>=0:e=>true;const r=e=>{if(n(e))t=t+e};return UF({get:()=>AF(t),update:r,modify:r})};const KF=e=>{const t=new Map;for(const n of e.keyType.preregisteredWords)t.set(n,0);const n=e=>{const n=t.get(e)??0;t.set(e,n+1)};return UF({get:()=>jF(t),update:n,modify:n})};const qF=(e,t)=>{let n=t;return UF({get:()=>MF(n),update:e=>{n=e},modify:e=>{n=n+e}})};const JF=e=>{const t=e.keyType.boundaries.values;const n=t.length;const r=new Uint32Array(n+1);const i=new Float32Array(n);let a=0;let o=0;let s=Number.MAX_VALUE;let l=Number.MIN_VALUE;c(t,Vr(gi),ei((e,t)=>{i[t]=e}));const u=e=>{let t=0;let c=n;while(t!==c){const n=Math.floor(t+(c-t)/2);const r=i[n];if(e<=r)c=n;else t=n;if(c===t+1)if(e<=i[t])c=t;else t=c}r[t]=r[t]+1;a=a+1;o=o+e;if(e<s)s=e;if(e>l)l=e};const d=()=>{const e=ur(n);let t=0;for(let a=0;a<n;a++){const n=i[a];const o=r[a];t=t+o;e[a]=[n,t]}return e};return UF({get:()=>NF({buckets:d(),count:a,min:s,max:l,sum:o}),update:u,modify:u})};const YF=e=>{const{error:t,maxAge:n,maxSize:r,quantiles:i}=e.keyType;const a=c(i,Vr(gi));const o=ur(r);let s=0;let l=0;let u=0;let d=0;let f=0;const p=e=>{const i=[];let s=0;while(s!==r-1){const t=o[s];if(t!=null){const[r,a]=t;const o=Df(e-r);if(Bf(o,Cf)&&zf(o,n))i.push(a)}s=s+1}return XF(t,a,Vr(i,gi))};const m=(e,t)=>{if(r>0){s=s+1;const n=s%r;o[n]=[t,e]}d=l===0?e:Math.min(d,e);f=l===0?e:Math.max(f,e);l=l+1;u=u+e};return UF({get:()=>PF({error:t,quantiles:p(Date.now()),count:l,min:d,max:f,sum:u}),update:([e,t])=>m(e,t),modify:([e,t])=>m(e,t)})};const XF=(e,t,n)=>{const r=n.length;if(!Cr(t))return Qr();const i=t[0];const a=t.slice(1);const o=ZF(e,r,N(),0,i,n);const s=$r(o);a.forEach(t=>{s.push(ZF(e,r,o.value,o.consumed,t,o.rest))});return ei(s,e=>[e.quantile,e.value])};const ZF=(e,t,n,r,i,a)=>{let o=e;let s=t;let c=n;let l=r;let u=i;let d=a;let f=e;let p=t;let m=n;let h=r;let g=i;let ee=a;while(1){if(!Cr(d))return{quantile:u,value:N(),consumed:l,rest:[]};if(u===1)return{quantile:u,value:P(jr(d)),consumed:l+d.length,rest:[]};const e=kr(d);const t=Pr(d,t=>t===e);const n=u*s;const r=o/2*n;const i=l+t[0].length;const a=Math.abs(i-n);if(i<n-r){f=o;p=s;m=Or(d);h=i;g=u;ee=t[1];o=f;s=p;c=m;l=h;u=g;d=ee;continue}if(i>n+r){const t=In(c)?P(e):c;return{quantile:u,value:t,consumed:l,rest:d}}switch(c._tag){case`None`:{f=o;p=s;m=Or(d);h=i;g=u;ee=t[1];o=f;s=p;c=m;l=h;u=g;d=ee;continue}case`Some`:{const e=Math.abs(n-c.value);if(a<e){f=o;p=s;m=Or(d);h=i;g=u;ee=t[1];o=f;s=p;c=m;l=h;u=g;d=ee;continue}return{quantile:u,value:P(c.value),consumed:l,rest:d}}}}throw new Error(`BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues`)};const QF=`effect/MetricPair`;const $F=Symbol.for(QF);const eI={_Type:e=>e};const tI=(e,t)=>{return{[$F]:eI,metricKey:e,metricState:t,pipe(){return O(this,arguments)}}};const nI=`effect/MetricRegistry`;const rI=Symbol.for(nI);var iI=class{[rI]=rI;map=rF();snapshot(){const e=[];for(const[t,n]of this.map)e.push(tI(t,n.get()));return e}get(e){const t=c(this.map,iF(e),Wn);if(t==null){if(zP(e.keyType))return this.getCounter(e);if(VP(e.keyType))return this.getGauge(e);if(BP(e.keyType))return this.getFrequency(e);if(HP(e.keyType))return this.getHistogram(e);if(UP(e.keyType))return this.getSummary(e);throw new Error(`BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues`)}else return t}getCounter(e){let t=c(this.map,iF(e),Wn);if(t==null){const n=GF(e);if(!c(this.map,oF(e)))c(this.map,sF(e,n));t=n}return t}getFrequency(e){let t=c(this.map,iF(e),Wn);if(t==null){const n=KF(e);if(!c(this.map,oF(e)))c(this.map,sF(e,n));t=n}return t}getGauge(e){let t=c(this.map,iF(e),Wn);if(t==null){const n=qF(e,e.keyType.bigint?BigInt(0):0);if(!c(this.map,oF(e)))c(this.map,sF(e,n));t=n}return t}getHistogram(e){let t=c(this.map,iF(e),Wn);if(t==null){const n=JF(e);if(!c(this.map,oF(e)))c(this.map,sF(e,n));t=n}return t}getSummary(e){let t=c(this.map,iF(e),Wn);if(t==null){const n=YF(e);if(!c(this.map,oF(e)))c(this.map,sF(e,n));t=n}return t}};const aI=()=>{return new iI};const oI=`effect/Metric`;const sI=Symbol.for(oI);const cI={_Type:e=>e,_In:e=>e,_Out:e=>e};const lI=_(Symbol.for(`effect/Metric/globalMetricRegistry`),()=>aI());const uI=function(e,t,n,r){const i=Object.assign(e=>Wy(e,e=>gI(i,e)),{[sI]:cI,keyType:e,unsafeUpdate:t,unsafeValue:n,unsafeModify:r,register(){this.unsafeValue([]);return this},pipe(){return O(this,arguments)}});return i};const dI=(e,t)=>fI(XP(e,t));const fI=e=>{let t;const n=new WeakMap;const r=r=>{if(r.length===0){if(t!==void 0)return t;t=lI.get(e);return t}let i=n.get(r);if(i!==void 0)return i;i=lI.get(QP(e,r));n.set(r,i);return i};return uI(e.keyType,(e,t)=>r(t).update(e),e=>r(e).get(),(e,t)=>r(t).modify(e))};const pI=(e,t,n)=>fI(ZP(e,t,n));const mI=t(3,(e,t,n)=>hI(e,[Ok(t,n)]));const hI=t(2,(e,t)=>{return uI(e.keyType,(n,r)=>e.unsafeUpdate(n,Zr(t,r)),n=>e.unsafeValue(Zr(t,n)),(n,r)=>e.unsafeModify(n,Zr(t,r)))});const gI=t(2,(e,t)=>Eb(tx,n=>q(()=>e.unsafeUpdate(t,n))));const _I=`effect/Request`;const vI=Symbol.for(_I);const yI={_E:e=>e,_A:e=>e};const bI={...Rt,[vI]:yI};const xI=e=>v(e,vI);const SI=()=>e=>Object.assign(Object.create(bI),e);const CI=e=>t=>{const n=Object.assign(Object.create(bI),t);n._tag=e;return n};const wI=function(){function e(e){if(e)Object.assign(this,e)}e.prototype=bI;return e}();const TI=e=>{return class t extends wI{_tag=e}};const EI=t(2,(e,t)=>Eb(rk,n=>q(()=>{if(n.has(e)){const r=n.get(e);if(!r.state.completed){r.state.completed=true;FS(r.result,t)}}})));const DI=t(2,(e,t)=>Ty(t,{onFailure:t=>EI(e,Kx(t)),onSuccess:t=>EI(e,Z(t))}));const OI=t(2,(e,t)=>EI(e,Kx(t)));const kI=t(2,(e,t)=>EI(e,X(t)));const AI=t(2,(e,t)=>EI(e,Z(t)));var jI=class{count=0;observers=new Set;interrupted=false;addObserver(e){this.observers.add(e)}removeObserver(e){this.observers.delete(e)}increment(){this.count++;this.observers.forEach(e=>e(this.count))}decrement(){this.count--;this.observers.forEach(e=>e(this.count))}};const MI={Forward:0,Backward:1};var NI=class e{self;stack;direction;count=0;constructor(e,t,n){this.self=e;this.stack=t;this.direction=n}clone(){return new e(this.self,this.stack.slice(),this.direction)}reversed(){return new e(this.self,this.stack.slice(),this.direction===MI.Forward?MI.Backward:MI.Forward)}next(){const e=this.entry;this.count++;if(this.direction===MI.Forward)this.moveNext();else this.movePrev();switch(e._tag){case`None`:return{done:true,value:this.count};case`Some`:return{done:false,value:e.value}}}get key(){if(this.stack.length>0)return P(this.stack[this.stack.length-1].key);return N()}get value(){if(this.stack.length>0)return P(this.stack[this.stack.length-1].value);return N()}get entry(){return Jn(Ar(this.stack),e=>[e.key,e.value])}get index(){let e=0;const t=this.stack;if(t.length===0){const e=this.self._root;if(e!=null)return e.count;return 0}else if(t[t.length-1].left!=null)e=t[t.length-1].left.count;for(let n=t.length-2;n>=0;--n)if(t[n+1]===t[n].right){++e;if(t[n].left!=null)e+=t[n].left.count}return e}moveNext(){const e=this.stack;if(e.length===0)return;let t=e[e.length-1];if(t.right!=null){t=t.right;while(t!=null){e.push(t);t=t.left}}else{e.pop();while(e.length>0&&e[e.length-1].right===t){t=e[e.length-1];e.pop()}}}get hasNext(){const e=this.stack;if(e.length===0)return false;if(e[e.length-1].right!=null)return true;for(let t=e.length-1;t>0;--t)if(e[t-1].left===e[t])return true;return false}movePrev(){const e=this.stack;if(e.length===0)return;let t=e[e.length-1];if(t!=null&&t.left!=null){t=t.left;while(t!=null){e.push(t);t=t.right}}else{e.pop();while(e.length>0&&e[e.length-1].left===t){t=e[e.length-1];e.pop()}}}get hasPrev(){const e=this.stack;if(e.length===0)return false;if(e[e.length-1].left!=null)return true;for(let t=e.length-1;t>0;--t)if(e[t-1].right===e[t])return true;return false}};const $={Red:0,Black:1};const PI=({color:e,count:t,key:n,left:r,right:i,value:a})=>({color:e,key:n,value:a,left:r,right:i,count:t});function FI(e,t){e.key=t.key;e.value=t.value;e.left=t.left;e.right=t.right;e.color=t.color;e.count=t.count}const II=({count:e,key:t,left:n,right:r,value:i},a)=>({color:a,key:t,value:i,left:n,right:r,count:e});const LI=e=>{e.count=1+(e.left?.count??0)+(e.right?.count??0)};const RI=`effect/RedBlackTree`;const zI=Symbol.for(RI);const BI={_Key:e=>e,_Value:e=>e};const VI={[zI]:BI,[y](){let e=b(RI);for(const t of this)e^=c(b(t[0]),x(b(t[1])));return S(this,e)},[C](e){if(UI(e)){if((this._root?.count??0)!==(e._root?.count??0))return false;const t=Array.from(e);return Array.from(this).every((e,n)=>{const r=t[n];return w(e[0],r[0])&&w(e[1],r[1])})}return false},[Symbol.iterator](){const e=[];let t=this._root;while(t!=null){e.push(t);t=t.left}return new NI(this,e,MI.Forward)},toString(){return D(this.toJSON())},toJSON(){return{_id:`RedBlackTree`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const HI=(e,t)=>{const n=Object.create(VI);n._ord=e;n._root=t;return n};const UI=e=>v(e,zI);const WI=e=>HI(e,void 0);const GI=t(2,(e,t)=>{let n=WI(t);for(const[t,r]of e)n=nL(n,t,r);return n});const KI=e=>(...t)=>{return GI(t,e)};const qI=t(2,(e,t)=>YI(e,t,MI.Backward));const JI=t(2,(e,t)=>YI(e,t,MI.Forward));const YI=(e,t,n)=>{return{[Symbol.iterator]:()=>{if(t<0)return new NI(e,[],n);let r=e._root;const i=[];while(r!==void 0){i.push(r);if(r.left!==void 0){if(t<r.left.count){r=r.left;continue}t-=r.left.count}if(!t)return new NI(e,i,n);t-=1;if(r.right!==void 0){if(t>=r.right.count)break;r=r.right}else break}return new NI(e,[],n)}}};const XI=t(2,(e,t)=>{const n=[];let r=e._root;let i=fs();while(r!==void 0||n.length>0)if(r){n.push(r);r=r.left}else{const e=n.pop();if(w(t,e.key))i=L(e.value)(i);r=e.right}return i});const ZI=t(2,(e,t)=>{const n=e._ord;let r=e._root;while(r!==void 0){const e=n(t,r.key);if(w(t,r.key))return P(r.value);if(e<=0)r=r.left;else r=r.right}return N()});const QI=e=>{let t=e._root;let n=e._root;while(t!==void 0){n=t;t=t.left}return n?P([n.key,n.value]):N()};const $I=t(2,(e,t)=>{if(t<0)return N();let n=e._root;let r=void 0;while(n!==void 0){r=n;if(n.left){if(t<n.left.count){n=n.left;continue}t-=n.left.count}if(!t)return P([r.key,r.value]);t-=1;if(n.right){if(t>=n.right.count)break;n=n.right}else break}return N()});const eL=e=>e._ord;const tL=t(2,(e,t)=>F(ZI(e,t)));const nL=t(3,(e,t,n)=>{const r=e._ord;let i=e._root;const a=[];const o=[];while(i!=null){const e=r(t,i.key);a.push(i);o.push(e);if(e<=0)i=i.left;else i=i.right}a.push({color:$.Red,key:t,value:n,left:void 0,right:void 0,count:1});for(let e=a.length-2;e>=0;--e){const t=a[e];if(o[e]<=0)a[e]={color:t.color,key:t.key,value:t.value,left:a[e+1],right:t.right,count:t.count+1};else a[e]={color:t.color,key:t.key,value:t.value,left:t.left,right:a[e+1],count:t.count+1}}for(let e=a.length-1;e>1;--e){const t=a[e-1];const n=a[e];if(t.color===$.Black||n.color===$.Black)break;const r=a[e-2];if(r.left===t)if(t.left===n){const i=r.right;if(i&&i.color===$.Red){t.color=$.Black;r.right=II(i,$.Black);r.color=$.Red;e-=1}else{r.color=$.Red;r.left=t.right;t.color=$.Black;t.right=r;a[e-2]=t;a[e-1]=n;LI(r);LI(t);if(e>=3){const n=a[e-3];if(n.left===r)n.left=t;else n.right=t}break}}else{const i=r.right;if(i&&i.color===$.Red){t.color=$.Black;r.right=II(i,$.Black);r.color=$.Red;e-=1}else{t.right=n.left;r.color=$.Red;r.left=n.right;n.color=$.Black;n.left=t;n.right=r;a[e-2]=n;a[e-1]=t;LI(r);LI(t);LI(n);if(e>=3){const t=a[e-3];if(t.left===r)t.left=n;else t.right=n}break}}else if(t.right===n){const i=r.left;if(i&&i.color===$.Red){t.color=$.Black;r.left=II(i,$.Black);r.color=$.Red;e-=1}else{r.color=$.Red;r.right=t.left;t.color=$.Black;t.left=r;a[e-2]=t;a[e-1]=n;LI(r);LI(t);if(e>=3){const n=a[e-3];if(n.right===r)n.right=t;else n.left=t}break}}else{const i=r.left;if(i&&i.color===$.Red){t.color=$.Black;r.left=II(i,$.Black);r.color=$.Red;e-=1}else{t.left=n.right;r.color=$.Red;r.right=n.left;n.color=$.Black;n.right=t;n.left=r;a[e-2]=n;a[e-1]=t;LI(r);LI(t);LI(n);if(e>=3){const t=a[e-3];if(t.right===r)t.right=n;else t.left=n}break}}}a[0].color=$.Black;return HI(e._ord,a[0])});const rL=e=>aL(e,MI.Forward);const iL=e=>aL(e,MI.Backward);const aL=(e,t)=>{const n=e[Symbol.iterator]();let r=0;return{[Symbol.iterator]:()=>aL(e,t),next:()=>{r++;const e=n.key;if(t===MI.Forward)n.moveNext();else n.movePrev();switch(e._tag){case`None`:return{done:true,value:r};case`Some`:return{done:false,value:e.value}}}}};const oL=e=>{let t=e._root;let n=e._root;while(t!==void 0){n=t;t=t.right}return n?P([n.key,n.value]):N()};const sL=e=>{return{[Symbol.iterator]:()=>{const t=[];let n=e._root;while(n!==void 0){t.push(n);n=n.right}return new NI(e,t,MI.Backward)}}};const cL=t(2,(e,t)=>uL(e,t,MI.Backward));const lL=t(2,(e,t)=>uL(e,t,MI.Forward));const uL=(e,t,n)=>{return{[Symbol.iterator]:()=>{const r=e._ord;let i=e._root;const a=[];let o=0;while(i!==void 0){const e=r(t,i.key);a.push(i);if(e<0)o=a.length;if(e<0)i=i.left;else i=i.right}a.length=o;return new NI(e,a,n)}}};const dL=t(2,(e,t)=>pL(e,t,MI.Backward));const fL=t(2,(e,t)=>pL(e,t,MI.Forward));const pL=(e,t,n=MI.Forward)=>{return{[Symbol.iterator]:()=>{const r=e._ord;let i=e._root;const a=[];let o=0;while(i!==void 0){const e=r(t,i.key);a.push(i);if(e<=0)o=a.length;if(e<=0)i=i.left;else i=i.right}a.length=o;return new NI(e,a,n)}}};const mL=t(2,(e,t)=>gL(e,t,MI.Backward));const hL=t(2,(e,t)=>gL(e,t,MI.Forward));const gL=(e,t,n)=>{return{[Symbol.iterator]:()=>{const r=e._ord;let i=e._root;const a=[];let o=0;while(i!==void 0){const e=r(t,i.key);a.push(i);if(e>0)o=a.length;if(e<=0)i=i.left;else i=i.right}a.length=o;return new NI(e,a,n)}}};const _L=t(2,(e,t)=>yL(e,t,MI.Backward));const vL=t(2,(e,t)=>yL(e,t,MI.Forward));const yL=(e,t,n)=>{return{[Symbol.iterator]:()=>{const r=e._ord;let i=e._root;const a=[];let o=0;while(i!==void 0){const e=r(t,i.key);a.push(i);if(e>=0)o=a.length;if(e<0)i=i.left;else i=i.right}a.length=o;return new NI(e,a,n)}}};const bL=t(2,(e,t)=>{const n=e._root;if(n!==void 0)AL(n,(e,n)=>{t(e,n);return N()})});const xL=t(3,(e,t,n)=>{const r=e._root;const i=e._ord;if(r!==void 0)jL(r,t,i,(e,t)=>{n(e,t);return N()})});const SL=t(3,(e,t,n)=>{const r=e._root;const i=e._ord;if(r!==void 0)ML(r,t,i,(e,t)=>{n(e,t);return N()})});const CL=t(2,(e,{body:t,max:n,min:r})=>{const i=e._root;const a=e._ord;if(i)NL(i,r,n,a,(e,n)=>{t(e,n);return N()})});const wL=t(3,(e,t,n)=>{let r=t;for(const t of e)r=n(r,t[1],t[0]);return r});const TL=t(2,(e,t)=>{if(!tL(e,t))return e;const n=e._ord;const r=n;let i=e._root;const a=[];while(i!==void 0){const e=r(t,i.key);a.push(i);if(w(t,i.key))i=void 0;else if(e<=0)i=i.left;else i=i.right}if(a.length===0)return e;const o=new Array(a.length);let s=a[a.length-1];o[o.length-1]={color:s.color,key:s.key,value:s.value,left:s.left,right:s.right,count:s.count};for(let e=a.length-2;e>=0;--e){s=a[e];if(s.left===a[e+1])o[e]={color:s.color,key:s.key,value:s.value,left:o[e+1],right:s.right,count:s.count};else o[e]={color:s.color,key:s.key,value:s.value,left:s.left,right:o[e+1],count:s.count}}s=o[o.length-1];if(s.left!==void 0&&s.right!==void 0){const e=o.length;s=s.left;while(s.right!=null){o.push(s);s=s.right}const t=o[e-1];o.push({color:s.color,key:t.key,value:t.value,left:s.left,right:s.right,count:s.count});o[e-1].key=s.key;o[e-1].value=s.value;for(let t=o.length-2;t>=e;--t){s=o[t];o[t]={color:s.color,key:s.key,value:s.value,left:s.left,right:o[t+1],count:s.count}}o[e-1].left=o[e]}s=o[o.length-1];if(s.color===$.Red){const e=o[o.length-2];if(e.left===s)e.left=void 0;else if(e.right===s)e.right=void 0;o.pop();for(let e=0;e<o.length;++e)o[e].count--;return HI(n,o[0])}else if(s.left!==void 0||s.right!==void 0){if(s.left!==void 0)FI(s,s.left);else if(s.right!==void 0)FI(s,s.right);s.color=$.Black;for(let e=0;e<o.length-1;++e)o[e].count--;return HI(n,o[0])}else if(o.length===1)return HI(n,void 0);else{for(let e=0;e<o.length;++e)o[e].count--;const e=o[o.length-2];PL(o);if(e.left===s)e.left=void 0;else e.right=void 0}return HI(n,o[0])});const EL=e=>e._root?.count??0;const DL=e=>kL(e,MI.Forward);const OL=e=>kL(e,MI.Backward);const kL=(e,t)=>{const n=e[Symbol.iterator]();let r=0;return{[Symbol.iterator]:()=>kL(e,t),next:()=>{r++;const e=n.value;if(t===MI.Forward)n.moveNext();else n.movePrev();switch(e._tag){case`None`:return{done:true,value:r};case`Some`:return{done:false,value:e.value}}}}};const AL=(e,t)=>{let n=e;let r=void 0;let i=false;while(!i)if(n!=null){r=Zs(n,r);n=n.left}else if(r!=null){const e=t(r.value.key,r.value.value);if(F(e))return e;n=r.value.right;r=r.previous}else i=true;return N()};const jL=(e,t,n,r)=>{let i=e;let a=void 0;let o=false;while(!o)if(i!==void 0){a=Zs(i,a);if(n(t,i.key)<=0)i=i.left;else i=void 0}else if(a!==void 0){if(n(t,a.value.key)<=0){const e=r(a.value.key,a.value.value);if(F(e))return e}i=a.value.right;a=a.previous}else o=true;return N()};const ML=(e,t,n,r)=>{let i=e;let a=void 0;let o=false;while(!o)if(i!==void 0){a=Zs(i,a);i=i.left}else if(a!==void 0&&n(t,a.value.key)>0){const e=r(a.value.key,a.value.value);if(F(e))return e;i=a.value.right;a=a.previous}else o=true;return N()};const NL=(e,t,n,r,i)=>{let a=e;let o=void 0;let s=false;while(!s)if(a!==void 0){o=Zs(a,o);if(r(t,a.key)<=0)a=a.left;else a=void 0}else if(o!==void 0&&r(n,o.value.key)>0){if(r(t,o.value.key)<=0){const e=i(o.value.key,o.value.value);if(F(e))return e}a=o.value.right;o=o.previous}else s=true;return N()};const PL=e=>{let t,n,r,i;for(let a=e.length-1;a>=0;--a){t=e[a];if(a===0){t.color=$.Black;return}n=e[a-1];if(n.left===t){r=n.right;if(r!==void 0&&r.right!==void 0&&r.right.color===$.Red){r=n.right=PI(r);i=r.right=PI(r.right);n.right=r.left;r.left=n;r.right=i;r.color=n.color;t.color=$.Black;n.color=$.Black;i.color=$.Black;LI(n);LI(r);if(a>1){const t=e[a-2];if(t.left===n)t.left=r;else t.right=r}e[a-1]=r;return}else if(r!==void 0&&r.left!==void 0&&r.left.color===$.Red){r=n.right=PI(r);i=r.left=PI(r.left);n.right=i.left;r.left=i.right;i.left=n;i.right=r;i.color=n.color;n.color=$.Black;r.color=$.Black;t.color=$.Black;LI(n);LI(r);LI(i);if(a>1){const t=e[a-2];if(t.left===n)t.left=i;else t.right=i}e[a-1]=i;return}if(r!==void 0&&r.color===$.Black)if(n.color===$.Red){n.color=$.Black;n.right=II(r,$.Red);return}else{n.right=II(r,$.Red);continue}else if(r!==void 0){r=PI(r);n.right=r.left;r.left=n;r.color=n.color;n.color=$.Red;LI(n);LI(r);if(a>1){const t=e[a-2];if(t.left===n)t.left=r;else t.right=r}e[a-1]=r;e[a]=n;if(a+1<e.length)e[a+1]=t;else e.push(t);a=a+2}}else{r=n.left;if(r!==void 0&&r.left!==void 0&&r.left.color===$.Red){r=n.left=PI(r);i=r.left=PI(r.left);n.left=r.right;r.right=n;r.left=i;r.color=n.color;t.color=$.Black;n.color=$.Black;i.color=$.Black;LI(n);LI(r);if(a>1){const t=e[a-2];if(t.right===n)t.right=r;else t.left=r}e[a-1]=r;return}else if(r!==void 0&&r.right!==void 0&&r.right.color===$.Red){r=n.left=PI(r);i=r.right=PI(r.right);n.left=i.right;r.right=i.left;i.right=n;i.left=r;i.color=n.color;n.color=$.Black;r.color=$.Black;t.color=$.Black;LI(n);LI(r);LI(i);if(a>1){const t=e[a-2];if(t.right===n)t.right=i;else t.left=i}e[a-1]=i;return}if(r!==void 0&&r.color===$.Black)if(n.color===$.Red){n.color=$.Black;n.left=II(r,$.Red);return}else{n.left=II(r,$.Red);continue}else if(r!==void 0){r=PI(r);n.left=r.right;r.right=n;r.color=n.color;n.color=$.Red;LI(n);LI(r);if(a>1){const t=e[a-2];if(t.right===n)t.right=r;else t.left=r}e[a-1]=r;e[a]=n;if(a+1<e.length)e[a+1]=t;else e.push(t);a=a+2}}}};const FL=zI;const IL=MI;const LL=UI;const RL=WI;const zL=GI;const BL=KI;const VL=JI;const HL=qI;const UL=XI;const WL=ZI;const GL=QI;const KL=$I;const qL=eL;const JL=lL;const YL=cL;const XL=fL;const ZL=dL;const QL=tL;const $L=nL;const eR=rL;const tR=iL;const nR=oL;const rR=hL;const iR=mL;const aR=vL;const oR=_L;const sR=bL;const cR=xL;const lR=SL;const uR=CL;const dR=wL;const fR=TL;const pR=sL;const mR=EL;const hR=DL;const gR=OL;const _R=Symbol.for(`effect/SortedSet`);const vR={[_R]:{_A:e=>e},[y](){return c(b(this.keyTree),x(b(_R)),S(this))},[C](e){return bR(e)&&w(this.keyTree,e.keyTree)},[Symbol.iterator](){return eR(this.keyTree)},toString(){return D(this.toJSON())},toJSON(){return{_id:`SortedSet`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const yR=e=>{const t=Object.create(vR);t.keyTree=e;return t};const bR=e=>v(e,_R);const xR=t(2,(e,t)=>QL(e.keyTree,t)?e:yR($L(e.keyTree,t,true)));const SR=t(2,(e,t)=>yR(fR(e.keyTree,t)));const CR=`effect/Supervisor`;const wR=Symbol.for(CR);const TR={_T:e=>e};var ER=class e{underlying;value0;[wR]=TR;constructor(e,t){this.underlying=e;this.value0=t}get value(){return this.value0}onStart(e,t,n,r){this.underlying.onStart(e,t,n,r)}onEnd(e,t){this.underlying.onEnd(e,t)}onEffect(e,t){this.underlying.onEffect(e,t)}onSuspend(e){this.underlying.onSuspend(e)}onResume(e){this.underlying.onResume(e)}map(t){return new e(this,c(this.value,W(t)))}zip(e){return new DR(this,e)}};var DR=class e{left;right;_tag=`Zip`;[wR]=TR;constructor(e,t){this.left=e;this.right=t}get value(){return sb(this.left.value,this.right.value)}onStart(e,t,n,r){this.left.onStart(e,t,n,r);this.right.onStart(e,t,n,r)}onEnd(e,t){this.left.onEnd(e,t);this.right.onEnd(e,t)}onEffect(e,t){this.left.onEffect(e,t);this.right.onEffect(e,t)}onSuspend(e){this.left.onSuspend(e);this.right.onSuspend(e)}onResume(e){this.left.onResume(e);this.right.onResume(e)}map(e){return new ER(this,c(this.value,W(e)))}zip(t){return new e(this,t)}};const OR=e=>v(e,wR)&&_e(e,`Zip`);var kR=class{[wR]=TR;fibers=new Set;get value(){return q(()=>Array.from(this.fibers))}onStart(e,t,n,r){this.fibers.add(r)}onEnd(e,t){this.fibers.delete(t)}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ER(this,c(this.value,W(e)))}zip(e){return new DR(this,e)}onRun(e,t){return e()}};var AR=class{effect;[wR]=TR;constructor(e){this.effect=e}get value(){return this.effect}onStart(e,t,n,r){}onEnd(e,t){}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ER(this,c(this.value,W(e)))}zip(e){return new DR(this,e)}onRun(e,t){return e()}};var jR=class{ref;[wR]=TR;constructor(e){this.ref=e}get value(){return q(()=>Jf(this.ref))}onStart(e,t,n,r){c(this.ref,Yf(c(Jf(this.ref),xR(r))))}onEnd(e,t){c(this.ref,Yf(c(Jf(this.ref),SR(t))))}onEffect(e,t){}onSuspend(e){}onResume(e){}map(e){return new ER(this,c(this.value,W(e)))}zip(e){return new DR(this,e)}onRun(e,t){return e()}};const MR=()=>{return new kR};const NR=q(MR);const PR=e=>{return new AR(e)};const FR=_(`effect/Supervisor/none`,()=>PR(J));const IR=Hg;const LR=Jm;const RR=dh;const zR=Oh;const BR=Gh;const VR=og;const HR=Tg;const UR=Wg;const WR=Gg;const GR=Kg;const KR=qg;const qR=Jg;const JR=Yg;const YR=Xg;const XR=Zg;const ZR=Qg;const QR=$g;const $R=e_;const ez=`Empty`;const tz=`AddSupervisor`;const nz=`RemoveSupervisor`;const rz=`AndThen`;const iz={_tag:ez};const az=(e,t)=>{return{_tag:rz,first:e,second:t}};const oz=(e,t)=>{return sz(t,ms(e))};const sz=(e,t)=>{let n=e;let r=t;while(ks(r)){const e=R(r);switch(e._tag){case ez:{r=Ms(r);break}case tz:{n=n.zip(e.supervisor);r=Ms(r);break}case nz:{n=cz(n,e.supervisor);r=Ms(r);break}case rz:{r=L(e.first)(L(e.second)(Ms(r)));break}}}return n};const cz=(e,t)=>{if(w(e,t))return FR;else if(OR(e))return cz(e.left,t).zip(cz(e.right,t));else return e};const lz=e=>{if(w(e,FR))return Ll();else if(OR(e))return c(lz(e.left),$l(lz(e.right)));else return zl(e)};const uz=(e,t)=>{if(w(e,t))return iz;const n=lz(e);const r=lz(t);const i=c(r,Zl(n),iu(iz,(e,t)=>az(e,{_tag:tz,supervisor:t})));const a=c(n,Zl(r),iu(iz,(e,t)=>az(e,{_tag:nz,supervisor:t})));return az(i,a)};const dz=UR({empty:iz,patch:oz,combine:az,diff:uz});const fz=dI(`effect_fiber_started`,{incremental:true});const pz=dI(`effect_fiber_active`);const mz=dI(`effect_fiber_successes`,{incremental:true});const hz=dI(`effect_fiber_failures`,{incremental:true});const gz=mI(pI(`effect_fiber_lifetimes`,gP({start:.5,factor:2,count:35})),`time_unit`,`milliseconds`);const _z=`Continue`;const vz=`Done`;const yz=`Yield`;const bz={_E:e=>e,_A:e=>e};const xz=e=>{throw new Error(`BUG: FiberRuntime - ${ct(e)} - please report an issue at https://github.com/Effect-TS/effect/issues`)};const Sz=Symbol.for(`effect/internal/fiberRuntime/YieldedOp`);const Cz=_(`effect/internal/fiberRuntime/yieldedOpChannel`,()=>({currentOp:null}));const wz={[vt]:(e,t,n)=>{return Ke(()=>t.effect_instruction_i1(n))},["OnStep"]:(e,t,n)=>{return Z(Z(n))},[yt]:(e,t,n)=>{return Ke(()=>t.effect_instruction_i2(n))},[Dt]:(e,t,n)=>{e.patchRuntimeFlags(e.currentRuntimeFlags,t.patch);if(A_(e.currentRuntimeFlags)&&e.isInterrupted())return X(e.getInterruptedCause());else return Z(n)},[Ct]:(e,t,n)=>{Ke(()=>t.effect_instruction_i2(n));if(Ke(()=>t.effect_instruction_i0())){e.pushStack(t);return Ke(()=>t.effect_instruction_i1())}else return J},[wt]:(e,t,n)=>{const r=Ke(()=>t.effect_instruction_i0.next(n));if(r.done)return Z(r.value);e.pushStack(t);return Ve(r.value)}};const Tz={[WM]:(e,t,n,r)=>{e.processNewInterruptSignal(r.cause);return A_(t)?X(r.cause):n},[KM]:(e,t,n,r)=>{throw new Error(`It is illegal to have multiple concurrent run loops in a single fiber`)},[GM]:(e,t,n,r)=>{r.onFiber(e,LE(t));return n},[qM]:(e,t,n,r)=>{return U(ob(),()=>n)}};const Ez=e=>Dy(dv(e),e=>eB(Pv(e),([e,t])=>{const n=new Map;const r=[];for(const e of t){r.push(vs(e));for(const t of e)n.set(t.request,t)}const i=r.flat();return Pb(cV(e.runAll(r),i,()=>i.forEach(e=>{e.listeners.interrupted=true})),rk,n)},false,false));const Dz=kt();var Oz=class extends mT{[aN]=oN;[lN]=bz;_fiberRefs;_fiberId;_queue=new Array;_children=null;_observers=new Array;_running=false;_stack=[];_asyncInterruptor=null;_asyncBlockingOn=null;_exitValue=null;_steps=[];_isYielding=false;currentRuntimeFlags;currentOpCount=0;currentSupervisor;currentScheduler;currentTracer;currentSpan;currentContext;currentDefaultServices;constructor(e,t,n){super();this.currentRuntimeFlags=n;this._fiberId=e;this._fiberRefs=t;if(F_(n)){const e=this.getFiberRef(tx);fz.unsafeUpdate(1,e);pz.unsafeUpdate(1,e)}this.refreshRefCache()}commit(){return DN(this)}id(){return this._fiberId}resume(e){this.tell(XM(e))}get status(){return this.ask((e,t)=>t)}get runtimeFlags(){return this.ask((e,t)=>{if(BE(t))return e.currentRuntimeFlags;return t.runtimeFlags})}scope(){return nN(this)}get children(){return this.ask(e=>Array.from(e.getChildren()))}getChildren(){if(this._children===null)this._children=new Set;return this._children}getInterruptedCause(){return this.getFiberRef(ix)}fiberRefs(){return this.ask(e=>e.getFiberRefs())}ask(e){return K(()=>{const t=gS(this._fiberId);this.tell(YM((n,r)=>{FS(t,q(()=>e(n,r)))}));return yS(t)})}tell(e){this._queue.push(e);if(!this._running){this._running=true;this.drainQueueLaterOnExecutor()}}get await(){return ny(e=>{const t=t=>e(G(t));this.tell(YM((e,n)=>{if(e._exitValue!==null)t(this._exitValue);else e.addObserver(t)}));return q(()=>this.tell(YM((e,n)=>{e.removeObserver(t)})))},this.id())}get inheritAll(){return B((e,t)=>{const n=e.id();const r=e.getFiberRefs();const i=t.runtimeFlags;const a=this.getFiberRefs();const o=LT(r,n,a);e.setFiberRefs(o);const s=e.getFiberRef(YB);const l=c(B_(i,s),nv(b_),nv(C_));return Yy(l)})}get poll(){return q(()=>Un(this._exitValue))}unsafePoll(){return this._exitValue}interruptAsFork(e){return q(()=>this.tell(JM(bu(e))))}unsafeInterruptAsFork(e){this.tell(JM(bu(e)))}addObserver(e){if(this._exitValue!==null)e(this._exitValue);else this._observers.push(e)}removeObserver(e){this._observers=this._observers.filter(t=>t!==e)}getFiberRefs(){this.setFiberRef(YB,this.currentRuntimeFlags);return this._fiberRefs}unsafeDeleteFiberRef(e){this._fiberRefs=HT(this._fiberRefs,e)}getFiberRef(e){if(this._fiberRefs.locals.has(e))return this._fiberRefs.locals.get(e)[0][1];return e.initial}setFiberRef(e,t){this._fiberRefs=GT(this._fiberRefs,{fiberId:this._fiberId,fiberRef:e,value:t});this.refreshRefCache()}refreshRefCache(){this.currentDefaultServices=this.getFiberRef(xw);this.currentTracer=this.currentDefaultServices.unsafeMap.get(fw.key);this.currentSupervisor=this.getFiberRef(XB);this.currentScheduler=this.getFiberRef(tk);this.currentContext=this.getFiberRef(Hb);this.currentSpan=this.currentContext.unsafeMap.get(pw.key)}setFiberRefs(e){this._fiberRefs=e;this.refreshRefCache()}addChild(e){this.getChildren().add(e)}removeChild(e){this.getChildren().delete(e)}transferChildren(e){const t=this._children;this._children=null;if(t!==null&&t.size>0){for(const n of t)if(n._exitValue===null)e.add(this.currentRuntimeFlags,n)}}drainQueueOnCurrentThread(){let e=true;while(e){let t=_z;const n=globalThis[GN];globalThis[GN]=this;try{while(t===_z)t=this._queue.length===0?vz:this.evaluateMessageWhileSuspended(this._queue.splice(0,1)[0])}finally{this._running=false;globalThis[GN]=n}if(this._queue.length>0&&!this._running){this._running=true;if(t===yz){this.drainQueueLaterOnExecutor();e=false}else e=true}else e=false}}drainQueueLaterOnExecutor(){this.currentScheduler.scheduleTask(this.run,this.getFiberRef(Ub))}drainQueueWhileRunning(e,t){let n=t;while(this._queue.length>0){const t=this._queue.splice(0,1)[0];n=Tz[t._tag](this,e,n,t)}return n}isInterrupted(){return!Eu(this.getFiberRef(ix))}addInterruptedCause(e){const t=this.getFiberRef(ix);this.setFiberRef(ix,Su(t,e))}processNewInterruptSignal(e){this.addInterruptedCause(e);this.sendInterruptSignalToAllChildren()}sendInterruptSignalToAllChildren(){if(this._children===null||this._children.size===0)return false;let e=false;for(const t of this._children){t.tell(JM(bu(this.id())));e=true}return e}interruptAllChildren(){if(this.sendInterruptSignalToAllChildren()){const e=this._children.values();this._children=null;let t=false;const n=()=>{const n=e.next();if(!n.done)return Qv(n.value.await);else return q(()=>{t=true})};return Zy({while:()=>!t,body:n,step:()=>{}})}return null}reportExitValue(e){if(F_(this.currentRuntimeFlags)){const t=this.getFiberRef(tx);const n=this.id().startTimeMillis;const r=Date.now();gz.unsafeUpdate(r-n,t);pz.unsafeUpdate(-1,t);switch(e._tag){case A:{mz.unsafeUpdate(1,t);break}case k:{hz.unsafeUpdate(1,t);break}}}if(e._tag===`Failure`){const t=this.getFiberRef(Qb);if(!Ou(e.cause)&&t._tag===`Some`)this.log(`Fiber terminated with an unhandled error`,e.cause,t)}}setExitValue(e){this._exitValue=e;this.reportExitValue(e);for(let t=this._observers.length-1;t>=0;t--)this._observers[t](e);this._observers=[]}getLoggers(){return this.getFiberRef(Nz)}log(e,t,n){const r=F(n)?n.value:this.getFiberRef(Kb);const i=this.getFiberRef(kz);if($E(i,r))return;const a=this.getFiberRef(qb);const o=this.getFiberRef(Gb);const s=this.getLoggers();const c=this.getFiberRefs();if(Gl(s)>0){const n=Xd(this.getFiberRef(xw),XS);const i=new Date(n.unsafeCurrentTimeMillis());pt(c,()=>{for(const n of s)n.log({fiberId:this.id(),logLevel:r,message:e,cause:t,context:c,spans:a,annotations:o,date:i})})}}evaluateMessageWhileSuspended(e){switch(e._tag){case qM:return yz;case WM:{this.processNewInterruptSignal(e.cause);if(this._asyncInterruptor!==null){this._asyncInterruptor(X(e.cause));this._asyncInterruptor=null}return _z}case KM:{this._asyncInterruptor=null;this._asyncBlockingOn=null;this.evaluateEffect(e.effect);return _z}case GM:{e.onFiber(this,this._exitValue!==null?IE:RE(this.currentRuntimeFlags,this._asyncBlockingOn));return _z}default:return xz(e)}}evaluateEffect(e){this.currentSupervisor.onResume(this);try{let t=A_(this.currentRuntimeFlags)&&this.isInterrupted()?X(this.getInterruptedCause()):e;while(t!==null){const e=t;const n=this.runLoop(e);if(n===Sz){const e=Cz.currentOp;Cz.currentOp=null;if(e._op===Et)if(D_(this.currentRuntimeFlags)){this.tell(ZM());this.tell(XM(sS));t=null}else t=sS;else if(e._op===ht)t=null}else{this.currentRuntimeFlags=c(this.currentRuntimeFlags,k_(C_));const e=this.interruptAllChildren();if(e!==null)t=U(e,()=>n);else{if(this._queue.length===0)this.setExitValue(n);else this.tell(XM(n));t=null}}}}finally{this.currentSupervisor.onSuspend(this)}}start(e){if(!this._running){this._running=true;const t=globalThis[GN];globalThis[GN]=this;try{this.evaluateEffect(e)}finally{this._running=false;globalThis[GN]=t;if(this._queue.length>0)this.drainQueueLaterOnExecutor()}}else this.tell(XM(e))}startFork(e){this.tell(XM(e))}patchRuntimeFlags(e,t){const n=V_(e,t);globalThis[GN]=this;this.currentRuntimeFlags=n;return n}initiateAsync(e,t){let n=false;const r=e=>{if(!n){n=true;this.tell(XM(e))}};if(A_(e))this._asyncInterruptor=r;try{t(r)}catch(e){r(H(yu(e)))}}pushStack(e){this._stack.push(e);if(e._op===`OnStep`)this._steps.push({refs:this.getFiberRefs(),flags:this.currentRuntimeFlags})}popStack(){const e=this._stack.pop();if(e){if(e._op===`OnStep`)this._steps.pop();return e}return}getNextSuccessCont(){let e=this.popStack();while(e){if(e._op!==_t)return e;e=this.popStack()}}getNextFailCont(){let e=this.popStack();while(e){if(e._op!==vt&&e._op!==Ct&&e._op!==wt)return e;e=this.popStack()}}[xt](e){return q(()=>Qd(this.currentContext,e))}["Left"](e){return V(e.left)}["None"](e){return V(new Tx)}["Right"](e){return Z(e.right)}["Some"](e){return Z(e.value)}["Micro"](e){return ey(t=>{let n=t;const r=gO(eO(e,this.currentContext));r.addObserver(e=>{if(e._tag===`Success`)return n(Z(e.value));switch(e.cause._tag){case`Interrupt`:return n(X(bu(Cp)));case`Fail`:return n(V(e.cause.error));case`Die`:return n(uy(e.cause.defect))}});return ey(e=>{n=t=>{e(J)};r.unsafeInterrupt()})})}[bt](e){const t=Ke(()=>e.effect_instruction_i0());const n=this.getNextSuccessCont();if(n!==void 0){if(!(n._op in wz))xz(n);return wz[n._op](this,n,t)}else{Cz.currentOp=Z(t);return Sz}}[A](e){const t=e;const n=this.getNextSuccessCont();if(n!==void 0){if(!(n._op in wz))xz(n);return wz[n._op](this,n,t.effect_instruction_i0)}else{Cz.currentOp=t;return Sz}}[k](e){const t=e.effect_instruction_i0;const n=this.getNextFailCont();if(n!==void 0)switch(n._op){case _t:case yt:if(!(A_(this.currentRuntimeFlags)&&this.isInterrupted()))return Ke(()=>n.effect_instruction_i1(t));else return X(Lu(t));case`OnStep`:if(!(A_(this.currentRuntimeFlags)&&this.isInterrupted()))return Z(X(t));else return X(Lu(t));case Dt:{this.patchRuntimeFlags(this.currentRuntimeFlags,n.patch);if(A_(this.currentRuntimeFlags)&&this.isInterrupted())return X(Su(t,this.getInterruptedCause()));else return X(t)}default:xz(n)}else{Cz.currentOp=X(t);return Sz}}[Tt](e){return Ke(()=>e.effect_instruction_i0(this,LE(this.currentRuntimeFlags)))}["Blocked"](e){const t=this.getFiberRefs();const n=this.currentRuntimeFlags;if(this._steps.length>0){const r=[];const i=this._steps[this._steps.length-1];let a=this.popStack();while(a&&a._op!==`OnStep`){r.push(a);a=this.popStack()}this.setFiberRefs(i.refs);this.currentRuntimeFlags=i.flags;const o=gE(i.refs,t);const s=B_(i.flags,n);return Z(Uv(e.effect_instruction_i0,B(t=>{while(r.length>0)t.pushStack(r.pop());t.setFiberRefs(vE(t.id(),t.getFiberRefs())(o));t.currentRuntimeFlags=V_(s)(t.currentRuntimeFlags);return e.effect_instruction_i1})))}return Jy(t=>U(rB(Wv(e.effect_instruction_i0)),()=>t(e.effect_instruction_i1)))}["RunBlocked"](e){return Ez(e.effect_instruction_i0)}[St](e){const t=e.effect_instruction_i0;const n=this.currentRuntimeFlags;const r=V_(n,t);if(A_(r)&&this.isInterrupted())return X(this.getInterruptedCause());else{this.patchRuntimeFlags(this.currentRuntimeFlags,t);if(e.effect_instruction_i1){const t=B_(r,n);this.pushStack(new Kv(t,e));return Ke(()=>e.effect_instruction_i1(n))}else return sS}}[vt](e){this.pushStack(e);return e.effect_instruction_i0}["OnStep"](e){this.pushStack(e);return e.effect_instruction_i0}[_t](e){this.pushStack(e);return e.effect_instruction_i0}[yt](e){this.pushStack(e);return e.effect_instruction_i0}[ht](e){this._asyncBlockingOn=e.effect_instruction_i1;this.initiateAsync(this.currentRuntimeFlags,e.effect_instruction_i0);Cz.currentOp=e;return Sz}[Et](e){this._isYielding=false;Cz.currentOp=e;return Sz}[Ct](e){const t=e.effect_instruction_i0;const n=e.effect_instruction_i1;if(t()){this.pushStack(e);return n()}else return sS}[wt](e){return wz[wt](this,e,void 0)}[gt](e){return Ke(()=>e.commit())}runLoop(e){let t=e;this.currentOpCount=0;while(true){if((this.currentRuntimeFlags&x_)!==0)this.currentSupervisor.onEffect(this,t);if(this._queue.length>0)t=this.drainQueueWhileRunning(this.currentRuntimeFlags,t);if(!this._isYielding){this.currentOpCount+=1;const e=this.currentScheduler.shouldYield(this);if(e!==false){this._isYielding=true;this.currentOpCount=0;const n=t;t=U(ob({priority:e}),()=>n)}}try{t=this.currentTracer.context(()=>{if(Dz!==t[Gv]._V){const e=this.getFiberRef($b);if(e._tag===`Some`){const n=t[Gv]._V;this.log(`Executing an Effect versioned ${n} with a Runtime of version ${kt()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`,_u,e)}}return this[t._op](t)},this);if(t===Sz){const e=Cz.currentOp;if(e._op===Et||e._op===ht)return Sz;Cz.currentOp=null;return e._op===A||e._op===k?e:X(yu(e))}}catch(e){if(t!==Sz&&!v(t,`_op`)||!(t._op in this))t=dy(`Not a valid effect: ${ct(t)}`);else if(xx(e))t=X(Su(yu(e),bu(Cp)));else t=uy(e)}}}run=()=>{this.drainQueueOnCurrentThread()}};const kz=_(`effect/FiberRef/currentMinimumLogLevel`,()=>Ib(eD(`Info`)));const Az=e=>XN(t=>{const n=$T(t.context,xw);Xd(n,ew).unsafe.log(e.log(t))});const jz=_(Symbol.for(`effect/Logger/defaultLogger`),()=>Az(nP));const Mz=_(Symbol.for(`effect/Logger/tracerLogger`),()=>XN(({annotations:e,cause:t,context:n,fiberId:r,logLevel:i,message:a})=>{const o=$d(WT(n,Hb),pw);if(o._tag===`None`||o.value._tag===`ExternalSpan`)return;const s=Qd(WT(n,xw),XS);const c={};for(const[t,n]of e)c[t]=n;c[`effect.fiberId`]=Fp(r);c[`effect.logLevel`]=i.label;if(t!==null&&t._tag!==`Empty`)c[`effect.cause`]=$u(t,{renderErrorCause:true});o.value.event(ct(Array.isArray(a)?a[0]:a),s.unsafeCurrentTimeNanos(),c)}));const Nz=_(Symbol.for(`effect/FiberRef/currentLoggers`),()=>Lb(zl(jz,Mz)));const Pz=function(){if(typeof arguments[0]===`string`)return JB(Gb,Qp(arguments[0],arguments[1]));const e=Object.entries(arguments[0]);return JB(Gb,sm(t=>{for(let n=0;n<e.length;n++){const[r,i]=e[n];Qp(t,r,i)}return t}))};const Fz=t(2,(e,t)=>{const n=typeof t===`string`?eD(t):t;return B(t=>{const r=t.getFiberRef(kz);if($E(r,n))return G(N());return W(e,P)})});const Iz=t(e=>z(e[0]),(e,t)=>qy(Wy(e,e=>Rz(n=>t(e,n)))));const Lz=t(e=>z(e[0]),(e,t)=>sV(e,Rz(e=>t(e))));const Rz=e=>B(t=>{const n=t.getFiberRefs();const r=O_(t.currentRuntimeFlags,b_);return U(zB,t=>fx(t,t=>B(i=>{const a=i.getFiberRefs();const o=i.currentRuntimeFlags;const s=gE(a,n);const c=B_(o,r);const l=gE(n,a);i.setFiberRefs(vE(s,i.id(),n));return sV(rb(e(t),c),q(()=>{i.setFiberRefs(vE(l,i.id(),i.getFiberRefs()))}))})))});const zz=e=>{const t=Pb(rx,P(rN));return t(e)};const Bz=Symbol.for(`effect/Effect/existsPar/found`);const Vz=t(e=>Se(e[0])&&!z(e[0]),(e,t,n)=>ak(n?.concurrency,()=>K(()=>Hz(e[Symbol.iterator](),0,t)),()=>Ty(Qz(e,(e,n)=>Oy(t(e,n),{onTrue:()=>V(Bz),onFalse:()=>J}),n),{onFailure:e=>e===Bz?G(true):V(e),onSuccess:()=>G(false)})));const Hz=(e,t,n)=>{const r=e.next();if(r.done)return G(false);return U(n(r.value,t),r=>r?G(r):Hz(e,t+1,n))};const Uz=t(e=>Se(e[0])&&!z(e[0]),(e,t,n)=>{const r=n?.negate?(e,n)=>W(t(e,n),Lw):t;return ak(n?.concurrency,()=>K(()=>I(e).reduceRight((e,t,n)=>lb(e,K(()=>r(t,n)),(e,n)=>n?[t,...e]:e),q(()=>new Array))),()=>W(Qz(e,(e,t)=>W(r(e,t),t=>t?P(e):N()),n),ai))});const Wz=e=>{if(Array.isArray(e)||Se(e))return[e,N()];const t=Object.keys(e);const n=t.length;return[t.map(t=>e[t]),P(e=>{const r={};for(let i=0;i<n;i++)r[t[i]]=e[i];return r})]};const Gz=(e,t,r)=>{const i=[];for(const t of e)i.push(py(t));return U(Qz(i,n,{concurrency:r?.concurrency,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),e=>{const n=N();const i=e.length;const a=new Array(i);const o=new Array(i);let s=false;for(let t=0;t<i;t++){const r=e[t];if(r._tag===`Left`){a[t]=P(r.left);s=true}else{o[t]=r.right;a[t]=n}}if(s)return t._tag===`Some`?V(t.value(a)):V(a);else if(r?.discard)return J;return t._tag===`Some`?G(t.value(o)):G(o)})};const Kz=(e,t,r)=>{const i=[];for(const t of e)i.push(py(t));if(r?.discard)return Qz(i,n,{concurrency:r?.concurrency,batching:r?.batching,discard:true,concurrentFinalizers:r?.concurrentFinalizers});return W(Qz(i,n,{concurrency:r?.concurrency,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),e=>t._tag===`Some`?t.value(e):e)};const qz=(e,t)=>{const[r,i]=Wz(e);if(t?.mode===`validate`)return Gz(r,i,t);else if(t?.mode===`either`)return Kz(r,i,t);return t?.discard!==true&&i._tag===`Some`?W(Qz(r,n,t),i.value):Qz(r,n,t)};const Jz=e=>t=>qz(t,e);const Yz=(e,t)=>W(qz(I(e).map(my),t),ri(e=>Rx(e)?P(e.effect_instruction_i0):N()));const Xz=t(2,(e,t)=>Array.from({length:t},()=>e));const Zz=t(e=>z(e[0]),(e,t,n)=>qz(Xz(e,t),n));const Qz=t(e=>Se(e[0]),(e,t,n)=>B(r=>{const i=n?.batching===true||n?.batching===`inherit`&&r.getFiberRef(Zb);if(n?.discard)return ik(n.concurrency,()=>vB(TT,n?.concurrentFinalizers)(n=>i?eB(e,(e,r)=>n(t(e,r)),true,false,1):Dy(e,(e,r)=>n(t(e,r)))),()=>vB(ET,n?.concurrentFinalizers)(n=>eB(e,(e,r)=>n(t(e,r)),i,false)),r=>vB(DT(r),n?.concurrentFinalizers)(n=>eB(e,(e,r)=>n(t(e,r)),i,false,r)));return ik(n?.concurrency,()=>vB(TT,n?.concurrentFinalizers)(n=>i?tB(e,1,(e,r)=>n(t(e,r)),true):Ey(e,(e,r)=>n(t(e,r)))),()=>vB(ET,n?.concurrentFinalizers)(n=>$z(e,(e,r)=>n(t(e,r)),i)),r=>vB(DT(r),n?.concurrentFinalizers)(n=>tB(e,r,(e,r)=>n(t(e,r)),i)))}));const $z=(e,t,n)=>K(()=>{const r=I(e);const i=new Array(r.length);const a=(e,n)=>U(t(e,n),e=>q(()=>i[n]=e));return Y(eB(r,a,n,false),G(i))});const eB=(e,t,n,r,i)=>Jy(a=>Gy(o=>B(s=>{let c=Array.from(e).reverse();let l=c.length;if(l===0)return J;let u=0;let d=false;const f=i?Math.min(c.length,i):c.length;const p=new Set;const m=new Array;const h=()=>p.forEach(e=>{e.currentScheduler.scheduleTask(()=>{e.unsafeInterruptAsFork(s.id())},0)});const g=new Array;const ee=new Array;const te=new Array;const ne=()=>{const e=m.filter(({exit:e})=>e._tag===`Failure`).sort((e,t)=>e.index<t.index?-1:e.index===t.index?0:1).map(({exit:e})=>e);if(e.length===0)e.push(sS);return e};const re=(e,t=false)=>{const n=qy(o(e));const r=oB(n,s,s.currentRuntimeFlags,rN);s.currentScheduler.scheduleTask(()=>{if(t)r.unsafeInterruptAsFork(s.id());r.resume(n)},0);return r};const ie=()=>{if(!r){l-=c.length;c=[]}d=true;h()};const ae=n?by:my;const oe=re(ny(e=>{const r=(e,t)=>{if(e._op===`Blocked`)te.push(e);else{m.push({index:t,exit:e});if(e._op===`Failure`&&!d)ie()}};const o=()=>{if(c.length>0){const f=c.pop();let h=u++;const ie=()=>{const e=c.pop();h=u++;return U(ob(),()=>U(ae(a(t(e,h))),oe))};const oe=e=>{if(c.length>0){r(e,h);if(c.length>0)return ie()}return G(e)};const _=U(ae(a(t(f,h))),oe);const se=re(_);g.push(se);p.add(se);if(d)se.currentScheduler.scheduleTask(()=>{se.unsafeInterruptAsFork(s.id())},0);se.addObserver(t=>{let a;if(t._op===`Failure`)a=t;else a=t.effect_instruction_i0;ee.push(se);p.delete(se);r(a,h);if(m.length===l)e(G(Bn(Ux(ne(),{parallel:true}),()=>sS)));else if(te.length+m.length===l){const t=ne();const r=te.map(e=>e.effect_instruction_i0).reduce(cv);e(G(Uv(r,eB([Bn(Ux(t,{parallel:true}),()=>sS),...te.map(e=>e.effect_instruction_i1)],e=>e,n,true,i))))}else o()})}};for(let e=0;e<f;e++)o()}));return Qv(Ly(xy(a(DN(oe))),aS({onFailure:e=>{ie();const t=te.length+1;const n=Math.min(typeof i===`number`?i:te.length,te.length);const r=Array.from(te);return ny(i=>{const a=[];let o=0;let s=0;const c=(n,s)=>c=>{a[n]=c;o++;if(o===t)i(Z(X(e)));if(r.length>0&&s)l()};const l=()=>{re(r.pop(),true).addObserver(c(s,true));s++};oe.addObserver(c(s,false));s++;for(let e=0;e<n;e++)l()})},onSuccess:()=>Ey(ee,e=>e.inheritAll)})))})));const tB=(e,t,n,r)=>K(()=>{const i=I(e);const a=new Array(i.length);const o=(e,t)=>W(n(e,t),e=>a[t]=e);return Y(eB(i,o,r,false,t),G(a))});const nB=e=>B((t,n)=>G(aB(e,t,n.runtimeFlags)));const rB=e=>cB(e,rN);const iB=t(2,(e,t)=>nB(Iy(e,e=>{const n=Nu(e);switch(n._tag){case`Left`:return t(n.left);case`Right`:return H(n.right)}})));const aB=(e,t,n,r=null)=>{const i=sB(e,t,n,r);i.resume(e);return i};const oB=(e,t,n,r=null)=>{const i=sB(e,t,n,r);return i};const sB=(e,t,n,r=null)=>{const i=Rp();const a=t.getFiberRefs();const o=RT(a,i);const s=new Oz(i,o,n);const l=WT(o,Hb);const u=s.currentSupervisor;u.onStart(l,e,P(t),s);s.addObserver(e=>u.onEnd(e,s));const d=r!==null?r:c(t.getFiberRef(rx),Bn(()=>t.scope()));d.add(n,s);return s};const cB=(e,t)=>B((n,r)=>G(aB(e,n,r.runtimeFlags,t)));const lB=t(e=>fe(e[2]),(e,t,n,r)=>ak(r?.concurrency,()=>I(e).reduce((e,t,r)=>lb(e,t,(e,t)=>n(e,t,r)),G(t)),()=>U(LO(t),t=>U(Qz(e,(e,r)=>U(e,e=>KO(t,t=>n(t,e,r))),r),()=>RO(t)))));const uB=t(e=>Se(e[0]),(e,t,r)=>c(Qz(e,(e,n)=>py(t(e,n)),r),W(e=>Hy(e,n))));const dB=t(e=>Se(e[0]),(e,t,n)=>U(uB(e,t,{concurrency:n?.concurrency,batching:n?.batching,concurrentFinalizers:n?.concurrentFinalizers}),([e,t])=>Sr(e)?V(e):n?.discard?J:G(t)));const fB=e=>{const t=hs(e);if(!ks(t))return fy(()=>new Cx(`Received an empty collection of effects`));const n=R(t);const r=Ms(t);const i=e=>c(SN(e[1]),Zv(e[0]));return c(_S(),U(e=>c(LO(r.length),U(t=>Jy(a=>c(nB(jy(n)),U(n=>c(r,Ey(e=>nB(jy(e))),W(e=>Ss(e)),W(e=>c(e,L(n))),Wy(n=>c(n,oi(J,(r,i)=>c(r,Y(c(pN(i),U(pB(n,i,e,t)),nB,Qv)))))),U(t=>c(a(c(Vw(e),U(i))),Ry(()=>c(t,oi(J,(e,t)=>c(e,cb(db(t))))))))))))))))};const pB=(e,t,n,r)=>i=>oS(i,{onFailure:e=>c(HO(r,t=>[t===0?c(TS(n,e),Qv):J,t-1]),xy),onSuccess:r=>c(NS(n,[r,t]),U(n=>n?c(hs(e),oi(J,(e,n)=>n===t?e:c(e,cb(db(n))))):J))});const mB=t(e=>Se(e[0])&&!z(e[0]),(e,t,n,r)=>ak(r?.concurrency,()=>I(e).reduce((e,t,r)=>lb(e,t,(e,t)=>n(e,t,r)),t),()=>K(()=>c(lB([t,...e],N(),(e,t,r)=>{switch(e._tag){case`None`:return P(t);case`Some`:return P(n(e.value,t,r))}},r),W(e=>{switch(e._tag){case`None`:throw new Error(`BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues`);case`Some`:return e.value}})))));const hB=e=>zS(t=>Ln($d(t,RB),{onNone:()=>e,onSome:t=>{switch(t.strategy._tag){case`Parallel`:return e;case`Sequential`:case`ParallelN`:return U(mx(t,ET),t=>WB(e,t))}}}));const gB=e=>t=>zS(n=>Ln($d(n,RB),{onNone:()=>t,onSome:n=>{if(n.strategy._tag===`ParallelN`&&n.strategy.parallelism===e)return t;return U(mx(n,DT(e)),e=>WB(t,e))}}));const _B=e=>t=>vB(e,true)(t);const vB=(e,t)=>r=>zS(i=>Ln($d(i,RB),{onNone:()=>r(n),onSome:i=>{if(t===true){const t=e._tag===`Parallel`?hB:e._tag===`Sequential`?SB:gB(e.parallelism);switch(i.strategy._tag){case`Parallel`:return t(r(hB));case`Sequential`:return t(r(SB));case`ParallelN`:return t(r(gB(i.strategy.parallelism)))}}else return r(n)}}));const yB=e=>U(RB,e);const bB=e=>U(UB(),t=>Ly(e(t),e=>t.close(e)));const xB=e=>U(UB(),t=>GB(e,t));const SB=e=>zS(t=>Ln($d(t,RB),{onNone:()=>e,onSome:t=>{switch(t.strategy._tag){case`Sequential`:return e;case`Parallel`:case`ParallelN`:return U(mx(t,TT),t=>WB(e,t))}}}));const CB=(e,t)=>wB([Ok(e,t)]);const wB=e=>JB(tx,t=>Zr(t,e));const TB=t(2,(e,t)=>bB(n=>U(WB(e,n),t)));const EB=t(e=>z(e[1]),(e,t,n)=>DB(e,t,(e,t)=>[e,t],n));const DB=t(e=>z(e[1]),(e,t,n,r)=>xy(IB(my(e),my(t),(e,t)=>mS(e,t,{onSuccess:n,onFailure:(e,t)=>r?.concurrent?xu(e,t):Su(e,t)}),r)));const OB=t(e=>Se(e[0]),(e,t,n)=>Sy(Qz(e,(e,n)=>Sy(t(e,n)),n)));const kB=e=>JB(xw,Yd(XS,e));const AB=e=>JB(xw,Yd(iw,e));const jB=e=>JB(xw,Yd(FC,e));const MB=e=>yB(t=>U(mx(t,vT),t=>c(e,WB(t),W(e=>[vy(e=>px(t,eS(e))),e]))));const NB=t(e=>z(e[1]),(e,t,n)=>IB(e,t,(e,t)=>[e,t],n));const PB=t(e=>z(e[1]),(e,t,n)=>{if(n?.concurrent!==true&&(n?.batching===void 0||n.batching===false))return cb(e,t);return IB(e,t,(e,t)=>e,n)});const FB=t(e=>z(e[1]),(e,t,n)=>{if(n?.concurrent!==true&&(n?.batching===void 0||n.batching===false))return Y(e,t);return IB(e,t,(e,t)=>t,n)});const IB=t(e=>z(e[1]),(e,t,n,r)=>W(qz([e,t],{concurrency:r?.concurrent?2:1,batching:r?.batching,concurrentFinalizers:r?.concurrentFinalizers}),([e,t])=>n(e,t)));const LB=e=>{if(e===W_)return J;return c(Uy,U(t=>{const n=V_(t,e);const r=B_(n,t);return c(Yy(e),Y(Rz(()=>Yy(r))),Qv)}),qy)};const RB=Vd(`effect/Scope`);const zB=RB;const BB=(e,t)=>{if(e.state._tag===`Open`)e.state.finalizers.set({},t)};const VB={[lx]:lx,[ux]:ux,pipe(){return O(this,arguments)},fork(e){return q(()=>{const t=HB(e);if(this.state._tag===`Closed`){t.state=this.state;return t}const n={};const r=e=>t.close(e);this.state.finalizers.set(n,r);BB(t,e=>q(()=>{if(this.state._tag===`Open`)this.state.finalizers.delete(n)}));return t})},close(e){return K(()=>{if(this.state._tag===`Closed`)return J;const t=Array.from(this.state.finalizers.values()).reverse();this.state={_tag:`Closed`,exit:e};if(t.length===0)return J;return xT(this.strategy)?c(Ey(t,t=>my(t(e))),U(e=>c(Ux(e),Jn(Vx),Bn(()=>sS)))):ST(this.strategy)?c($z(t,t=>my(t(e)),false),U(e=>c(Ux(e,{parallel:true}),Jn(Vx),Bn(()=>sS)))):c(tB(t,this.strategy.parallelism,t=>my(t(e)),false),U(e=>c(Ux(e,{parallel:true}),Jn(Vx),Bn(()=>sS))))})},addFinalizer(e){return K(()=>{if(this.state._tag===`Closed`)return e(this.state.exit);this.state.finalizers.set({},e);return J})}};const HB=(e=vT)=>{const t=Object.create(VB);t.strategy=e;t.state={_tag:`Open`,finalizers:new Map};return t};const UB=(e=vT)=>q(()=>HB(e));const WB=t(2,(e,t)=>HS(e,ef(Jd(RB,t))));const GB=t(2,(e,t)=>c(e,WB(t),Ly(e=>t.close(e))));const KB=e=>Bb(e,{differ:dz,fork:iz});const qB=t(2,(e,t)=>Qv(Iz(U(Tb(e),n=>Zv(Db(e,t),n)),t=>Db(e,t))));const JB=t(2,(e,t)=>Eb(e,n=>qB(e,t(n))));const YB=Vb(P_);const XB=KB(FR);const ZB=e=>Qz(e,pN);const QB=e=>{const t={...uT,commit(){return DN(this)},[aN]:oN,id:()=>I(e).reduce((e,t)=>Ap(e,t.id()),Cp),await:my($z(e,e=>xy(e.await),false)),children:W($z(e,e=>e.children,false),ni),inheritAll:Dy(e,e=>e.inheritAll),poll:W(Ey(e,e=>e.poll),si(P(Z(new Array)),(e,t)=>{switch(t._tag){case`None`:return N();case`Some`:switch(e._tag){case`None`:return N();case`Some`:return P(mS(t.value,e.value,{onSuccess:(e,t)=>[e,...t],onFailure:xu}))}}})),interruptAsFork:t=>Dy(e,e=>e.interruptAsFork(t))};return t};const $B=e=>Qv(rB(db(e)));const eV=e=>DN(QB(e));const tV=e=>Iz(G(e),db);const nV=t(3,(e,t,n)=>aV(e,t,{onSelfWin:(e,t)=>U(e.await,r=>{switch(r._tag){case A:return U(e.inheritAll,()=>n.onSelfDone(r,t));case k:return n.onSelfDone(r,t)}}),onOtherWin:(e,t)=>U(e.await,r=>{switch(r._tag){case A:return U(e.inheritAll,()=>n.onOtherDone(r,t));case k:return n.onOtherDone(r,t)}})}));const rV=e=>Jy(t=>vy(n=>U(rB(t(e)),e=>c(t(DN(e)),Ry(()=>c(e,EN(n)))))));const iV=t(2,(e,t)=>vy(n=>nV(e,t,{onSelfDone:(e,t)=>oS(e,{onFailure:e=>c(DN(t),zA(t=>xu(e,t))),onSuccess:e=>c(t,fb(n),Zv(e))}),onOtherDone:(e,t)=>oS(e,{onFailure:e=>c(DN(t),zA(t=>xu(t,e))),onSuccess:e=>c(t,fb(n),Zv(e))})})));const aV=t(3,(e,t,n)=>B((r,i)=>{const a=i.runtimeFlags;const o=Kf(true);const s=sB(e,r,a,n.selfScope);const c=sB(t,r,a,n.otherScope);return ny(r=>{s.addObserver(()=>oV(s,c,n.onSelfWin,o,r));c.addObserver(()=>oV(c,s,n.onOtherWin,o,r));s.startFork(e);c.startFork(t)},Ap(s.id(),c.id()))}));const oV=(e,t,n,r,i)=>{if(qf(true,false)(r))i(n(e,t))};const sV=t(2,(e,t)=>Jy(n=>wy(n(e),{onFailure:e=>wy(t,{onFailure:t=>H(Su(e,t)),onSuccess:()=>H(e)}),onSuccess:e=>Zv(t,e)})));const cV=(e,t,n)=>vy(r=>U(U(rB(jy(e)),e=>ny(r=>{const i=t.map(e=>e.listeners.count);const a=()=>{if(i.every(e=>e===0)){if(t.every(e=>{if(e.result.state.current._tag===`Pending`)return true;else if(e.result.state.current._tag===`Done`&&Ix(e.result.state.current.effect)&&e.result.state.current.effect._tag===`Failure`&&Du(e.result.state.current.effect.cause))return true;else return false})){o.forEach(e=>e());n?.();r(db(e))}}};e.addObserver(e=>{o.forEach(e=>e());r(e)});const o=t.map((e,t)=>{const n=e=>{i[t]=e;a()};e.listeners.addObserver(n);return()=>e.listeners.removeObserver(n)});a();return q(()=>{o.forEach(e=>e())})})),()=>K(()=>{const e=t.flatMap(e=>{if(!e.state.completed)return[e];return[]});return Dy(e,e=>EI(e.request,eS(r)))})));const lV=t(2,(e,t)=>Eb(rk,n=>K(()=>{const r=I(t).flatMap(e=>n.has(e)?[n.get(e)]:[]);return cV(e,r)})));const uV=(e,t)=>{t=vw(t);return qy(B(n=>{const r=Qd(n.getFiberRef(Hb),RB);const i=Qj(n,e,t);const a=n.getFiberRef(ox);const o=Xd(n.getFiberRef(xw),XS);return Zv(fx(r,e=>nM(i,e,o,a)),i)}))};const dV=e=>JB(xw,Yd(fw,e));const fV=function(){const e=typeof arguments[0]!==`string`;const t=e?arguments[1]:arguments[0];const n=vw(e?arguments[2]:arguments[1]);if(e){const e=arguments[0];return U(uV(t,vw(n)),t=>ZA(e,pw,t))}return e=>U(uV(t,vw(n)),t=>ZA(e,pw,t))};const pV=`effect/ScheduleInterval`;const mV=Symbol.for(pV);const hV={[mV]:mV,startMillis:0,endMillis:0};const gV=(e,t)=>{if(e>t)return hV;return{[mV]:mV,startMillis:e,endMillis:t}};const _V=t(2,(e,t)=>vV(e,t)===e);const vV=t(2,(e,t)=>{if(e.endMillis<=t.startMillis)return e;if(t.endMillis<=e.startMillis)return t;if(e.startMillis<t.startMillis)return e;if(t.startMillis<e.startMillis)return t;if(e.endMillis<=t.endMillis)return e;return t});const yV=t(2,(e,t)=>vV(e,t)===e?t:e);const bV=e=>{return e.startMillis>=e.endMillis};const xV=e=>{return!bV(e)};const SV=t(2,(e,t)=>{const n=Math.max(e.startMillis,t.startMillis);const r=Math.min(e.endMillis,t.endMillis);return gV(n,r)});const CV=e=>{return Df(e.endMillis-e.startMillis)};const wV=t(2,(e,t)=>{const n=Math.max(e.startMillis,t.startMillis);const r=Math.min(e.endMillis,t.endMillis);return n<r?N():P(gV(n,r))});const TV=e=>{return gV(e,Number.POSITIVE_INFINITY)};const EV=e=>{return gV(Number.NEGATIVE_INFINITY,e)};const DV=mV;const OV=gV;const kV=hV;const AV=_V;const jV=vV;const MV=yV;const NV=bV;const PV=xV;const FV=SV;const IV=CV;const LV=wV;const RV=TV;const zV=EV;const BV=`effect/ScheduleIntervals`;const VV=Symbol.for(BV);const HV=e=>{return{[VV]:VV,intervals:e}};const UV=HV(fs());const WV=e=>Array.from(e).reduce((e,t)=>c(e,GV(HV(ms(t)))),UV);const GV=t(2,(e,t)=>{if(!ks(t.intervals))return e;if(!ks(e.intervals))return t;if(R(e.intervals).startMillis<R(t.intervals).startMillis)return KV(Ms(e.intervals),t.intervals,R(e.intervals),fs());return KV(e.intervals,Ms(t.intervals),R(t.intervals),fs())});const KV=(e,t,n,r)=>{let i=e;let a=t;let o=n;let s=r;while(ks(i)||ks(a))if(!ks(i)&&ks(a))if(o.endMillis<R(a).startMillis){s=c(s,L(o));o=R(a);a=Ms(a);i=fs()}else{o=OV(o.startMillis,R(a).endMillis);a=Ms(a);i=fs()}else if(ks(i)&&Os(a))if(o.endMillis<R(i).startMillis){s=c(s,L(o));o=R(i);a=fs();i=Ms(i)}else{o=OV(o.startMillis,R(i).endMillis);a=fs();i=Ms(i)}else if(ks(i)&&ks(a))if(R(i).startMillis<R(a).startMillis)if(o.endMillis<R(i).startMillis){s=c(s,L(o));o=R(i);i=Ms(i)}else{o=OV(o.startMillis,R(i).endMillis);i=Ms(i)}else if(o.endMillis<R(a).startMillis){s=c(s,L(o));o=R(a);a=Ms(a)}else{o=OV(o.startMillis,R(a).endMillis);a=Ms(a)}else throw new Error(Ee(`Intervals.unionLoop`));return HV(c(s,L(o),bs))};const qV=t(2,(e,t)=>JV(e.intervals,t.intervals,fs()));const JV=(e,t,n)=>{let r=e;let i=t;let a=n;while(ks(r)&&ks(i)){const e=c(R(r),FV(R(i)));const t=NV(e)?a:c(a,L(e));if(c(R(r),AV(R(i))))r=Ms(r);else i=Ms(i);a=t}return HV(bs(a))};const YV=e=>{return c(e.intervals,As,Bn(()=>kV)).startMillis};const XV=e=>{return c(e.intervals,As,Bn(()=>kV)).endMillis};const ZV=t(2,(e,t)=>YV(e)<YV(t));const QV=e=>{return ks(e.intervals)};const $V=t(2,(e,t)=>ZV(e,t)?t:e);const eH=VV;const tH=HV;const nH=UV;const rH=WV;const iH=GV;const aH=qV;const oH=YV;const sH=XV;const cH=ZV;const lH=QV;const uH=$V;const dH=`Continue`;const fH=`Done`;const pH=e=>{return{_tag:dH,intervals:e}};const mH=e=>{return{_tag:dH,intervals:tH(ms(e))}};const hH={_tag:fH};const gH=e=>{return e._tag===dH};const _H=e=>{return e._tag===fH};const vH=pH;const yH=mH;const bH=hH;const xH=gH;const SH=_H;const CH=lx;const wH=ux;const TH=RB;const EH=dx;const DH=fx;const OH=px;const kH=WB;const AH=mx;const jH=GB;const MH=UB;var NH=class{permits;waiters=new Set;taken=0;constructor(e){this.permits=e}get free(){return this.permits-this.taken}take=e=>ty(t=>{if(this.free<e){const n=()=>{if(this.free<e)return;this.waiters.delete(n);this.taken+=e;t(G(e))};this.waiters.add(n);return q(()=>{this.waiters.delete(n)})}this.taken+=e;return t(G(e))});updateTaken=e=>B(t=>{this.taken=e(this.taken);if(this.waiters.size>0)t.getFiberRef(tk).scheduleTask(()=>{const e=this.waiters.values();let t=e.next();while(t.done===false&&this.free>0){t.value();t=e.next()}},t.getFiberRef(Ub));return G(this.free)});release=e=>this.updateTaken(t=>t-e);releaseAll=this.updateTaken(e=>0);withPermits=e=>t=>Jy(n=>U(n(this.take(e)),e=>sV(n(t),this.release(e))));withPermitsIfAvailable=e=>t=>Jy(n=>K(()=>{if(this.free<e)return lj;this.taken+=e;return sV(n(jk(t)),this.release(e))}))};const PH=e=>new NH(e);const FH=e=>q(()=>PH(e));var IH=class extends mT{isOpen;waiters=[];scheduled=false;constructor(e){super();this.isOpen=e}commit(){return this.await}unsafeSchedule(e){if(this.scheduled||this.waiters.length===0)return J;this.scheduled=true;e.currentScheduler.scheduleTask(this.flushWaiters,e.getFiberRef(Ub));return J}flushWaiters=()=>{this.scheduled=false;const e=this.waiters;this.waiters=[];for(let t=0;t<e.length;t++)e[t](sS)};open=B(e=>{if(this.isOpen)return J;this.isOpen=true;return this.unsafeSchedule(e)});unsafeOpen(){if(this.isOpen)return;this.isOpen=true;this.flushWaiters()}release=B(e=>{if(this.isOpen)return J;return this.unsafeSchedule(e)});await=ty(e=>{if(this.isOpen)return e(J);this.waiters.push(e);return q(()=>{const t=this.waiters.indexOf(e);if(t!==-1)this.waiters.splice(t,1)})});unsafeClose(){this.isOpen=false}close=q(()=>{this.isOpen=false});whenOpen=e=>{return Y(this.await,e)}};const LH=e=>new IH(e??false);const RH=e=>q(()=>LH(e));const zH=e=>KH(e,ZB);const BH=t(2,(e,t)=>W(VH(e,t),e=>e[0]));const VH=t(2,(e,t)=>{const n=gf(t);return U(RS(),t=>W(fU(N()),r=>[BS(UH(e,n,r),t),WH(r)]))});const HH=(e,t,n)=>{const r=Nf(gf(t));return c(_S(),Wy(t=>Ny(e,t)),W(e=>P([n+r,e])))};const UH=(e,t,n)=>Jy(r=>c(Vk(e=>e.currentTimeMillis),U(r=>mU(n,n=>{switch(n._tag){case`None`:return P(HH(e,t,r));case`Some`:{const[i]=n.value;return i-r<=0?P(HH(e,t,r)):N()}}})),U(e=>In(e)?dy(`BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues`):r(yS(e.value[1])))));const WH=e=>TO(e,N());const GH=t(2,(e,t)=>KH(e,e=>t(QB(e))));const KH=t(2,(e,t)=>U(NR,n=>c(nU(e,n),sV(U(n.value,t)))));const qH=t(e=>Se(e[0]),(e,t)=>t?.discard?Dy(e,nB):W(Ey(e,nB),QB));const JH=t(2,(e,t)=>B((n,r)=>{const i=t;const a=aB(e,n,r.runtimeFlags,rN);if(i.state._tag===`Open`){const e=()=>vy(e=>w(e,a.id())?J:Qv(db(a)));const t={};i.state.finalizers.set(t,e);a.addObserver(()=>{if(i.state._tag===`Closed`)return;i.state.finalizers.delete(t)})}else a.unsafeInterruptAsFork(n.id());return G(a)}));const YH=e=>yB(t=>JH(e,t));const XH=e=>DN(e);const ZH=e=>K(()=>U(e,DN));const QH=Symbol.for(`effect/Effect/memoizeFunction.key`);var $H=class{a;eq;[QH]=QH;constructor(e,t){this.a=e;this.eq=t}[C](e){if(v(e,QH))if(this.eq)return this.eq(this.a,e.a);else return w(this.a,e.a);return false}[y](){return this.eq?0:S(this,b(this.a))}};const eU=(e,t)=>{return c(q(()=>rF()),U(fU),W(n=>r=>c(n.modifyEffect(n=>{const i=c(n,iF(new $H(r,t)));if(In(i))return c(_S(),Wy(t=>c(qk(e(r)),Ny(t),nB)),W(e=>[e,c(n,sF(new $H(r,t),e))]));return G([i.value,n])}),U(yS),U(([e,t])=>c(YA(e),Zv(t))))))};const tU=t(2,(e,t)=>c(my(e),iV(my(t)),e=>xy(e)));const nU=t(2,(e,t)=>{const n=Fb(XB,e=>e.zip(t));return n(e)});const rU=t(2,(e,t)=>iU(e,{onTimeout:()=>Nx(t),duration:t}));const iU=t(2,(e,{duration:t,onTimeout:n})=>xy(sU(e,{onTimeout:()=>hy(n),onSuccess:G,duration:t})));const aU=t(2,(e,{duration:t,onTimeout:n})=>xy(sU(e,{onTimeout:()=>gy(n),onSuccess:G,duration:t})));const oU=t(2,(e,t)=>sU(e,{duration:t,onSuccess:P,onTimeout:N}));const sU=t(2,(e,{duration:t,onSuccess:n,onTimeout:r})=>vy(i=>Jy(a=>aV(a(e),jy(cj(t)),{onSelfWin:(e,t)=>U(e.await,r=>{if(r._tag===`Success`)return U(e.inheritAll,()=>Zv(fb(t,i),n(r.value)));else return U(fb(t,i),()=>X(r.cause))}),onOtherWin:(e,t)=>U(e.await,n=>{if(n._tag===`Success`)return U(e.inheritAll,()=>Zv(fb(t,i),r()));else return U(fb(t,i),()=>X(n.cause))}),otherScope:rN}))));const cU=`effect/Ref/SynchronizedRef`;const lU=Symbol.for(cU);const uU={_A:e=>e};var dU=class extends mT{ref;withLock;[lU]=uU;[yO]=bO;[_O]=_O;constructor(e,t){super();this.ref=e;this.withLock=t;this.get=wO(this.ref)}get;commit(){return this.get}modify(e){return this.modifyEffect(t=>G(e(t)))}modifyEffect(e){return this.withLock(c(U(wO(this.ref),e),U(([e,t])=>Zv(TO(this.ref,t),e))))}};const fU=e=>q(()=>pU(e));const pU=e=>{const t=SO(e);const n=PH(1);return new dU(t,n.withPermits(1))};const mU=t(2,(e,t)=>e.modifyEffect(e=>{const n=t(e);switch(n._tag){case`None`:return G([e,e]);case`Some`:return W(n.value,e=>[e,e])}}));const hU=t(2,(e,t)=>vU(e,t,(e,t)=>[e,t]));const gU=t(2,(e,t)=>vU(e,t,(e,t)=>e));const _U=t(2,(e,t)=>vU(e,t,(e,t)=>t));const vU=t(3,(e,t,n)=>({...uT,commit(){return DN(this)},[aN]:oN,id:()=>c(e.id(),Mp(t.id())),await:c(e.await,xy,IB(xy(t.await),n,{concurrent:true}),my),children:e.children,inheritAll:Y(t.inheritAll,e.inheritAll),poll:lb(e.poll,t.poll,(e,t)=>c(e,Yn(e=>c(t,Jn(t=>UM(e,t,{onSuccess:n,onFailure:xu})))))),interruptAsFork:n=>Y(e.interruptAsFork(n),t.interruptAsFork(n)),pipe(){return O(this,arguments)}}));const yU=t(e=>z(e[0]),(e,t,n)=>U(e,e=>qz(t(e),n).pipe(W(t=>Object.assign({},e,t)))));const bU=Symbol.for(`effect/ManagedRuntime`);const xU=`Fresh`;const SU=`Suspend`;const CU=`ZipWith`;const wU=aN;const TU=lN;const EU=uN;const DU=dN;const OU=fN;const kU=xN;const AU=pN;const jU=ZB;const MU=mN;const NU=QB;const PU=hN;const FU=gN;const IU=_N;const LU=vN;const RU=yN;const zU=bN;const BU=KN;const VU=SN;const HU=db;const UU=CN;const WU=fb;const GU=EN;const KU=wN;const qU=TN;const JU=$B;const YU=DN;const XU=eV;const ZU=ON;const QU=kN;const $U=AN;const eW=jN;const tW=NN;const nW=PN;const rW=FN;const iW=IN;const aW=zN;const oW=VN;const sW=BN;const cW=tV;const lW=HN;const uW=UN;const dW=WN;const fW=hU;const pW=gU;const mW=_U;const hW=vU;const gW=e=>function(){if(arguments.length===1){const t=arguments[0];return(n,...r)=>e(t,n,...r)}return e.apply(this,arguments)};const _W=gW((e,t,n)=>{const r=Rp();const i=[[Hb,[[r,e.context]]]];if(n?.scheduler)i.push([tk,[[r,n.scheduler]]]);let a=rE(e.fiberRefs,{entries:i,forkAs:r});if(n?.updateRefs)a=n.updateRefs(a,r);const o=new Oz(r,a,e.runtimeFlags);let s=t;if(n?.scope)s=U(AH(n.scope,vT),e=>Y(dx(e,vy(e=>w(e,o.id())?J:fb(o,e))),Ly(t,t=>OH(e,t))));const c=o.currentSupervisor;if(c!==FR){c.onStart(e.context,s,N(),o);o.addObserver(e=>c.onEnd(e,o))}rN.add(e.runtimeFlags,o);if(n?.immediate===false)o.resume(s);else o.start(s);return o});const vW=gW((e,t,n={})=>{const r=_W(e,t,n);if(n.onExit)r.addObserver(e=>{n.onExit(e)});return(t,n)=>vW(e)(c(r,WU(t??Cp)),{...n,onExit:n?.onExit?e=>n.onExit(CM(e)):void 0})});const yW=gW((e,t)=>{const n=DW(e)(t);if(n._tag===`Failure`)throw TW(n.effect_instruction_i0);return n.effect_instruction_i0});var bW=class extends Error{fiber;_tag=`AsyncFiberException`;constructor(e){super(`Fiber #${e.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);this.fiber=e;this.name=this._tag;this.stack=this.message}};const xW=e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=0;const n=new bW(e);Error.stackTraceLimit=t;return n};const SW=Symbol.for(`effect/Runtime/FiberFailure`);const CW=Symbol.for(`effect/Runtime/FiberFailure/Cause`);var wW=class extends Error{[SW];[CW];constructor(e){const t=sd(e)[0];super(t?.message||`An error has occurred`);this[SW]=SW;this[CW]=e;this.name=t?`(FiberFailure) ${t.name}`:`FiberFailure`;if(t?.stack)this.stack=t.stack}toJSON(){return{_id:`FiberFailure`,cause:this[CW].toJSON()}}toString(){return`(FiberFailure) `+$u(this[CW],{renderErrorCause:true})}[T](){return this.toString()}};const TW=e=>{const t=Error.stackTraceLimit;Error.stackTraceLimit=0;const n=new wW(e);Error.stackTraceLimit=t;return n};const EW=e=>{const t=e;switch(t._op){case`Failure`:case`Success`:return t;case`Left`:return Kx(t.left);case`Right`:return Z(t.right);case`Some`:return Z(t.value);case`None`:return Kx(Tx())}};const DW=gW((e,t)=>{const n=EW(t);if(n)return n;const r=new ek;const i=_W(e)(t,{scheduler:r});r.flush();const a=i.unsafePoll();if(a)return a;return Wx(ly(xW(i),GS(i)))});const OW=gW((e,t,n)=>kW(e,t,n).then(e=>{switch(e._tag){case A:return e.effect_instruction_i0;case k:throw TW(e.effect_instruction_i0)}}));const kW=gW((e,t,n)=>new Promise(r=>{const i=EW(t);if(i)r(i);const a=_W(e)(t);a.addObserver(e=>{r(e)});if(n?.signal!==void 0)if(n.signal.aborted)a.unsafeInterruptAsFork(a.id());else n.signal.addEventListener(`abort`,()=>{a.unsafeInterruptAsFork(a.id())},{once:true})}));var AW=class{context;runtimeFlags;fiberRefs;constructor(e,t,n){this.context=e;this.runtimeFlags=t;this.fiberRefs=n}pipe(){return O(this,arguments)}};const jW=e=>new AW(e.context,e.runtimeFlags,e.fiberRefs);const MW=()=>B((e,t)=>G(new AW(e.getFiberRef(Hb),t.runtimeFlags,e.getFiberRefs())));const NW=N_(b_,w_,S_);const PW=jW({context:qd(),runtimeFlags:NW,fiberRefs:aE()});const FW=vW(PW);const IW=_W(PW);const LW=OW(PW);const RW=kW(PW);const zW=yW(PW);const BW=DW(PW);const VW=e=>K(()=>{let t=void 0;return U(_S(),n=>U(MW(),r=>Jy(i=>Y(nB(i(wy(e(e=>vW(r)(Ny(e,n))),{onFailure:e=>TS(n,e),onSuccess:e=>{t=e;return J}}))),i(Ry(yS(n),()=>t??J))))))});const HW=t(2,(e,t)=>e.modifyEffect(t));const UW=`effect/Layer`;const WW=Symbol.for(UW);const GW={_RIn:e=>e,_E:e=>e,_ROut:e=>e};const KW={[WW]:GW,pipe(){return O(this,arguments)}};const qW=`effect/Layer/MemoMap`;const JW=Symbol.for(qW);const YW=sf()(`effect/Layer/CurrentMemoMap`,{defaultValue:()=>eG()});const XW=e=>v(e,WW);const ZW=e=>{return e._op_layer===xU};var QW=class{ref;[JW];constructor(e){this.ref=e;this[JW]=JW}getOrElseMemoize(e,t){return c(HW(this.ref,n=>{const r=n.get(e);if(r!==void 0){const[e,i]=r;const a=c(e,U(([e,t])=>c(YA(e),Zv(t))),Ly(aS({onFailure:()=>J,onSuccess:()=>fx(t,i)})));return G([a,n])}return c(CO(0),U(r=>c(_S(),U(i=>c(CO(()=>J),W(a=>{const o=Jy(o=>c(UB(),U(s=>c(o(U(rG(e,s,true),e=>qk(e(this)))),my,U(o=>{switch(o._tag){case k:return c(TS(i,o.effect_instruction_i0),Y(px(s,o)),Y(H(o.effect_instruction_i0)));case A:return c(TO(a,e=>c(px(s,e),Xy(AO(r,e=>[e===1,e-1])),Qv)),Y(MO(r,e=>e+1)),Y(fx(t,t=>c(q(()=>n.delete(e)),Y(wO(a)),U(e=>e(t))))),Y(NS(i,o.effect_instruction_i0)),Zv(o.effect_instruction_i0[1]))}})))));const s=[c(yS(i),Ly(oS({onFailure:()=>J,onSuccess:()=>MO(r,e=>e+1)}))),e=>c(wO(a),U(t=>t(e)))];return[o,ZW(e)?n:n.set(e,s)]}))))))}),xy)}};const $W=K(()=>W(fU(new Map),e=>new QW(e)));const eG=()=>new QW(pU(new Map));const tG=t(2,(e,t)=>U($W,n=>nG(e,n,t)));const nG=t(3,(e,t,n)=>U(rG(e,n),e=>ZA(e(t),YW,t)));const rG=(e,t,n=false)=>{const r=e;switch(r._op_layer){case`Locally`:return q(()=>e=>r.f(e.getOrElseMemoize(r.self,t)));case`ExtendScope`:return q(()=>e=>yB(t=>e.getOrElseMemoize(r.layer,t)));case`Fold`:return q(()=>e=>c(e.getOrElseMemoize(r.layer,t),wy({onFailure:n=>e.getOrElseMemoize(r.failureK(n),t),onSuccess:n=>e.getOrElseMemoize(r.successK(n),t)})));case`Fresh`:return q(()=>e=>c(r.layer,tG(t)));case`FromEffect`:return n?q(()=>e=>r.effect):q(()=>n=>n.getOrElseMemoize(e,t));case`Provide`:return q(()=>e=>c(e.getOrElseMemoize(r.first,t),U(n=>c(e.getOrElseMemoize(r.second,t),BS(n)))));case`Scoped`:return n?q(()=>e=>WB(r.effect,t)):q(()=>n=>n.getOrElseMemoize(e,t));case`Suspend`:return q(()=>e=>e.getOrElseMemoize(r.evaluate(),t));case`ProvideMerge`:return q(()=>e=>c(e.getOrElseMemoize(r.first,t),lb(e.getOrElseMemoize(r.second,t),r.zipK)));case`ZipWith`:return q(()=>e=>c(e.getOrElseMemoize(r.first,t),IB(e.getOrElseMemoize(r.second,t),r.zipK,{concurrent:true})))}};const iG=t(2,(e,t)=>sG(e,t,(e,t)=>ef(e,t)));const aG=(...e)=>{let t=e[0];for(let n=1;n<e.length;n++)t=iG(t,e[n]);return t};const oG=e=>{const t=Object.create(KW);t._op_layer=SU;t.evaluate=e;return t};const sG=t(3,(e,t,n)=>oG(()=>{const r=Object.create(KW);r._op_layer=CU;r.first=e;r.second=t;r.zipK=n;return r}));const cG=t(2,(e,t)=>bB(n=>U(tG(t,n),t=>VS(e,t))));const lG=t(2,(e,t)=>{const n=gE(PW.fiberRefs,t.fiberRefs);const r=B_(PW.runtimeFlags,t.runtimeFlags);return Jy(i=>B(a=>{const o=a.getFiberRef(Hb);const s=a.getFiberRefs();const c=vE(a.id(),s)(n);const l=a.currentRuntimeFlags;const u=V_(r)(l);const d=gE(c,s);const f=B_(u,l);a.setFiberRefs(c);a.currentRuntimeFlags=u;return sV(VS(i(e),ef(o,t.context)),B(e=>{e.setFiberRefs(vE(e.id(),e.getFiberRefs())(d));e.currentRuntimeFlags=V_(f)(e.currentRuntimeFlags);return J}))}))});const uG=t(2,(e,t)=>{if(Array.isArray(t))return cG(e,aG(...t));else if(XW(t))return cG(e,t);else if(Wd(t))return VS(e,t);else if(bU in t)return U(t.runtimeEffect,t=>lG(e,t));else return lG(e,t)});const dG=W(Tb(xw),Xd(ew));const fG=e=>Eb(xw,t=>e(Xd(t,ew)));const pG=t(2,(e,t)=>Fb(e,xw,Yd(ew,t)));const mG=e=>JB(xw,Yd(ew,e));const hG=qm;const gG=Km;const _G=Km;const vG=function(){const e=Symbol.for(`effect/Data/Error/plainArgs`);const t={BaseEffectError:class extends hx{constructor(t){super(t?.message,t?.cause?{cause:t.cause}:void 0);if(t){Object.assign(this,t);Object.defineProperty(this,e,{value:t,enumerable:false})}}toJSON(){return{...this[e],...this}}}};return t.BaseEffectError}();const yG=e=>{const t={BaseEffectError:class extends vG{_tag=e}};t.BaseEffectError.prototype.name=e;return t.BaseEffectError};const bG=`effect/Schedule`;const xG=Symbol.for(bG);const SG=e=>v(e,xG);const CG=`effect/ScheduleDriver`;const wG=Symbol.for(CG);const TG={start:0,now:0,input:void 0,output:void 0,elapsed:Cf,elapsedSincePrevious:Cf,recurrence:0};const EG=sf()(`effect/Schedule/CurrentIterationMetadata`,{defaultValue:()=>TG});const DG={_Out:e=>e,_In:e=>e,_R:e=>e};const OG={_Out:e=>e,_In:e=>e,_R:e=>e};var kG=class{initial;step;[xG]=DG;constructor(e,t){this.initial=e;this.step=t}pipe(){return O(this,arguments)}};const AG=(e,t,n,r)=>MO(e,e=>e.recurrence===0?{now:t,input:n,output:r,recurrence:e.recurrence+1,elapsed:Cf,elapsedSincePrevious:Cf,start:t}:{now:t,input:n,output:r,recurrence:e.recurrence+1,elapsed:Df(t-e.start),elapsedSincePrevious:Df(t-e.now),start:e.start});var jG=class{schedule;ref;[wG]=OG;constructor(e,t){this.schedule=e;this.ref=t}get state(){return W(wO(this.ref),e=>e[1])}get last(){return U(wO(this.ref),([e,t])=>{switch(e._tag){case`None`:return hy(()=>new Tx);case`Some`:return G(e.value)}})}iterationMeta=SO(TG);get reset(){return TO(this.ref,[N(),this.schedule.initial]).pipe(cb(TO(this.iterationMeta,TG)))}next(e){return c(W(wO(this.ref),e=>e[1]),U(t=>c(lk,U(n=>c(K(()=>this.schedule.step(n,e,t)),U(([t,r,i])=>{const a=TO(this.ref,[P(r),t]);if(SH(i))return a.pipe(Y(V(N())));const o=oH(i.intervals)-n;if(o<=0)return a.pipe(Y(AG(this.iterationMeta,n,e,r)),Zv(r));const s=Df(o);return c(a,Y(AG(this.iterationMeta,n,e,r)),Y(cj(s)),Zv(r))}))))))}};const MG=(e,t)=>new kG(e,t);const NG=e=>BG(e,s);const PG=t(2,(e,t)=>FG(e,(e,n)=>q(()=>t(e,n))));const FG=t(2,(e,t)=>MG(e.initial,(n,r,i)=>U(e.step(n,r,i),([e,n,i])=>{if(SH(i))return G([e,n,bH]);return W(t(r,n),t=>t?[e,n,i]:[e,n,bH])})));const IG=e=>c(CO([N(),e.initial]),W(t=>new jG(e,t)));const LG=t(2,(e,t)=>RG(e,t,aH));const RG=t(3,(e,t,n)=>MG([e.initial,t.initial],(r,i,a)=>c(lb(e.step(r,i,a[0]),t.step(r,i,a[1]),(e,t)=>[e,t]),U(([[r,a,o],[s,c,l]])=>{if(xH(o)&&xH(l))return zG(e,t,i,r,a,o.intervals,s,c,l.intervals,n);return G([[r,s],[a,c],bH])}))));const zG=(e,t,n,r,i,a,o,s,l,u)=>{const d=u(a,l);if(lH(d))return G([[r,o],[i,s],vH(d)]);if(c(a,cH(l)))return U(e.step(sH(a),n,r),([r,i,a])=>{if(SH(a))return G([[r,o],[i,s],bH]);return zG(e,t,n,r,i,a.intervals,o,s,l,u)});return U(t.step(sH(l),n,o),([o,s,c])=>{if(SH(c))return G([[r,o],[i,s],bH]);return zG(e,t,n,r,i,a,o,s,c.intervals,u)})};const BG=t(2,(e,t)=>VG(e,e=>q(()=>t(e))));const VG=t(2,(e,t)=>MG(e.initial,(n,r,i)=>U(e.step(n,r,i),([e,n,r])=>W(t(n),t=>[e,t,r]))));const HG=e=>MG(e.initial,(t,n,r)=>c(e.step(t,n,r),W(([e,t,r])=>[e,n,r])));const UG=e=>qG(fK,t=>t<e);const WG=(e,t)=>MG(e,(e,n,r)=>q(()=>[t(r),r,yH(RV(e))]));const GG=t(2,(e,t)=>FG(e,(e,n)=>HA(t(e))));const KG=t(2,(e,t)=>FG(e,(e,n)=>t(e)));const qG=t(2,(e,t)=>PG(e,(e,n)=>t(n)));const JG=Symbol.for(`effect/Schedule/ScheduleDefect`);var YG=class{error;[JG];constructor(e){this.error=e;this[JG]=JG}};const XG=e=>v(e,JG);const ZG=e=>iy(e,e=>uy(new YG(e)));const QG=e=>Ln(Gu(e,e=>Tu(e)&&XG(e.defect)?P(e.defect):N()),{onNone:()=>e,onSome:e=>vu(e.error)});const $G=e=>ry(e,e=>H(QG(e)));const eK=t(2,(e,t)=>nK(e,t,(e,t)=>V(e)));const tK=t(2,(e,t)=>{if(SG(t))return eK(e,t);const n=t.schedule??HG(fK);const r=t.while?KG(n,e=>{const n=t.while(e);if(typeof n===`boolean`)return G(n);return ZG(n)}):n;const i=t.until?GG(r,e=>{const n=t.until(e);if(typeof n===`boolean`)return G(n);return ZG(n)}):r;const a=t.times?LG(i,UG(t.times)).pipe(BG(e=>e[0])):i;return $G(eK(e,a))});const nK=t(3,(e,t,n)=>U(IG(t),t=>Ty(e,{onFailure:e=>n(e,N()),onSuccess:r=>rK(QA(e,EG,wO(t.iterationMeta)),t,(e,r)=>QA(n(e,r),EG,wO(t.iterationMeta)),r)})));const rK=(e,t,n,r)=>Ty(t.next(r),{onFailure:()=>By(t.last),onSuccess:r=>Ty(e,{onFailure:e=>n(e,P(r)),onSuccess:r=>rK(e,t,n,r)})});const iK=t(2,(e,t)=>sK(e,t,(e,t)=>V(e)));const aK=t(2,(e,t)=>{if(SG(t))return iK(e,t);return $G(iK(e,oK(t)))});const oK=e=>{const t=e.schedule??fK;const n=e.while?KG(t,t=>{const n=e.while(t);if(typeof n===`boolean`)return G(n);return ZG(n)}):t;const r=e.until?GG(n,t=>{const n=e.until(t);if(typeof n===`boolean`)return G(n);return ZG(n)}):n;return e.times?LG(r,UG(e.times)):r};const sK=t(3,(e,t,n)=>U(IG(t),t=>cK(QA(e,EG,wO(t.iterationMeta)),t,(e,r)=>QA(n(e,r),EG,wO(t.iterationMeta)))));const cK=(e,t,n)=>{return iy(e,r=>Ty(t.next(r),{onFailure:()=>c(t.last,By,U(e=>n(r,e))),onSuccess:()=>cK(e,t,n)}))};const lK=t(2,(e,t)=>uK(e,void 0,t));const uK=t(3,(e,t,n)=>U(IG(n),n=>dK(QA(e,EG,wO(n.iterationMeta)),t,n)));const dK=(e,t,n)=>Ty(n.next(t),{onFailure:()=>By(n.last),onSuccess:()=>U(e,t=>dK(e,t,n))});const fK=WG(0,e=>e+1);const pK=NG(UG(1));const mK=t(2,(e,t)=>YH(lK(e,t)));const hK=t(2,(e,t)=>K(()=>{let n=0;let r;return U(Zy({while:()=>n<t.steps.length&&(r===void 0||gn(r)),body:()=>{const i=t.steps[n];let a=uG(e,i.provide);if(r){let e=false;const t=a;a=K(()=>{if(e)return t;e=true;return r});a=$G(iK(a,gK(i,false)))}else{const e=gK(i,true);a=e?$G(iK(a,e)):a}return py(a)},step:e=>{r=e;n++}}),()=>r)}));const gK=(e,t)=>{if(!t)return oK({schedule:e.schedule?e.schedule:e.attempts?void 0:pK,times:e.attempts,while:e.while});else if(e.attempts===1||!(e.schedule||e.attempts))return void 0;return oK({schedule:e.schedule,while:e.while,times:e.attempts?e.attempts-1:void 0})};const _K=Symbol.for(`effect/MutableList`);const vK={[_K]:_K,[Symbol.iterator](){let e=false;let t=this.head;return{next(){if(e)return this.return();if(t==null){e=true;return this.return()}const n=t.value;t=t.next;return{done:e,value:n}},return(t){if(!e)e=true;return{done:true,value:t}}}},toString(){return D(this.toJSON())},toJSON(){return{_id:`MutableList`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const yK=e=>({value:e,removed:false,prev:void 0,next:void 0});const bK=()=>{const e=Object.create(vK);e.head=void 0;e.tail=void 0;e._length=0;return e};const xK=e=>SK(e)===0;const SK=e=>e._length;const CK=t(2,(e,t)=>{const n=yK(t);if(e.head===void 0)e.head=n;if(e.tail===void 0)e.tail=n;else{e.tail.next=n;n.prev=e.tail;e.tail=n}e._length+=1;return e});const wK=e=>{const t=e.head;if(t!==void 0){TK(e,t);return t.value}return void 0};const TK=(e,t)=>{if(t.removed)return;t.removed=true;if(t.prev!==void 0&&t.next!==void 0){t.prev.next=t.next;t.next.prev=t.prev}else if(t.prev!==void 0){e.tail=t.prev;t.prev.next=void 0}else if(t.next!==void 0){e.head=t.next;t.next.prev=void 0}else{e.tail=void 0;e.head=void 0}if(e._length>0)e._length-=1};const EK=Symbol.for(`effect/MutableQueue`);const DK=Symbol.for(`effect/mutable/MutableQueue/Empty`);const OK={[EK]:EK,[Symbol.iterator](){return Array.from(this.queue)[Symbol.iterator]()},toString(){return D(this.toJSON())},toJSON(){return{_id:`MutableQueue`,values:Array.from(this).map(E)}},[T](){return this.toJSON()},pipe(){return O(this,arguments)}};const kK=e=>{const t=Object.create(OK);t.queue=bK();t.capacity=e;return t};const AK=()=>kK(void 0);const jK=t(2,(e,t)=>{const n=SK(e.queue);if(e.capacity!==void 0&&n===e.capacity)return false;CK(t)(e.queue);return true});const MK=t(2,(e,t)=>{if(xK(e.queue))return t;return wK(e.queue)});const NK=(e,t,n,r)=>qm({_tag:`Complete`,key:e,exit:t,entryStats:n,timeToLiveMillis:r});const PK=(e,t)=>qm({_tag:`Pending`,key:e,deferred:t});const FK=(e,t)=>qm({_tag:`Refreshing`,deferred:e,complete:t});const IK=Symbol.for(`effect/Cache/MapKey`);var LK=class{current;[IK]=IK;previous=void 0;next=void 0;constructor(e){this.current=e}[y](){return c(b(this.current),x(b(this.previous)),x(b(this.next)),S(this))}[C](e){if(this===e)return true;return zK(e)&&w(this.current,e.current)&&w(this.previous,e.previous)&&w(this.next,e.next)}};const RK=e=>new LK(e);const zK=e=>v(e,IK);var BK=class{head=void 0;tail=void 0;add(e){if(e!==this.tail)if(this.tail===void 0){this.head=e;this.tail=e}else{const t=e.previous;const n=e.next;if(n!==void 0){e.next=void 0;if(t!==void 0){t.next=n;n.previous=t}else{this.head=n;this.head.previous=void 0}}this.tail.next=e;e.previous=this.tail;this.tail=e}}remove(){const e=this.head;if(e!==void 0){const t=e.next;if(t!==void 0){e.next=void 0;this.head=t;this.head.previous=void 0}else{this.head=void 0;this.tail=void 0}}return e}};const VK=()=>new BK;const HK=(e,t,n,r,i,a)=>({map:e,keys:t,accesses:n,updating:r,hits:i,misses:a});const UK=()=>HK(rF(),VK(),AK(),Kf(false),0,0);const WK=`effect/Cache`;const GK=Symbol.for(WK);const KK={_Key:e=>e,_Error:e=>e,_Value:e=>e};const qK=`effect/ConsumerCache`;const JK=Symbol.for(qK);const YK={_Key:e=>e,_Error:e=>e,_Value:e=>e};const XK=e=>e;const ZK=e=>({loadedMillis:e});var QK=class{capacity;context;fiberId;lookup;timeToLive;[GK]=KK;[JK]=YK;cacheState;constructor(e,t,n,r,i){this.capacity=e;this.context=t;this.fiberId=n;this.lookup=r;this.timeToLive=i;this.cacheState=UK()}get(e){return W(this.getEither(e),Cn)}get cacheStats(){return q(()=>XK({hits:this.cacheState.hits,misses:this.cacheState.misses,size:uF(this.cacheState.map)}))}getOption(e){return K(()=>Ln(iF(this.cacheState.map,e),{onNone:()=>{const t=RK(e);this.trackAccess(t);this.trackMiss();return G(N())},onSome:e=>this.resolveMapValue(e)}))}getOptionComplete(e){return K(()=>Ln(iF(this.cacheState.map,e),{onNone:()=>{const t=RK(e);this.trackAccess(t);this.trackMiss();return G(N())},onSome:e=>this.resolveMapValue(e,true)}))}contains(e){return q(()=>oF(this.cacheState.map,e))}entryStats(e){return q(()=>{const t=iF(this.cacheState.map,e);if(F(t))switch(t.value._tag){case`Complete`:{const e=t.value.entryStats.loadedMillis;return P(ZK(e))}case`Pending`:return N();case`Refreshing`:{const e=t.value.complete.entryStats.loadedMillis;return P(ZK(e))}}return N()})}getEither(e){return K(()=>{const t=e;let n=void 0;let r=void 0;let i=Wn(iF(this.cacheState.map,t));if(i===void 0){r=rT(this.fiberId);n=RK(t);if(oF(this.cacheState.map,t))i=Wn(iF(this.cacheState.map,t));else sF(this.cacheState.map,t,PK(n,r))}if(i===void 0){this.trackAccess(n);this.trackMiss();return W(this.lookupValueOf(e,r),j)}else return U(this.resolveMapValue(i),Ln({onNone:()=>this.getEither(e),onSome:e=>G(M(e))}))})}invalidate(e){return q(()=>{lF(this.cacheState.map,e)})}invalidateWhen(e,t){return q(()=>{const n=iF(this.cacheState.map,e);if(F(n)&&n.value._tag===`Complete`){if(n.value.exit._tag===`Success`){if(t(n.value.exit.value))lF(this.cacheState.map,e)}}})}get invalidateAll(){return q(()=>{this.cacheState.map=rF()})}refresh(e){return Vk(t=>K(()=>{const n=e;const r=rT(this.fiberId);let i=Wn(iF(this.cacheState.map,n));if(i===void 0)if(oF(this.cacheState.map,n))i=Wn(iF(this.cacheState.map,n));else sF(this.cacheState.map,n,PK(RK(n),r));if(i===void 0)return Qv(this.lookupValueOf(e,r));else switch(i._tag){case`Complete`:{if(this.hasExpired(t,i.timeToLiveMillis)){const t=Wn(iF(this.cacheState.map,n));if(w(t,i))lF(this.cacheState.map,n);return Qv(this.get(e))}return c(this.lookupValueOf(e,r),Nj(()=>{const e=Wn(iF(this.cacheState.map,n));if(w(e,i)){const e=FK(r,i);sF(this.cacheState.map,n,e);return true}return false}),Qv)}case`Pending`:return Vw(i.deferred);case`Refreshing`:return Vw(i.deferred)}}))}set(e,t){return Vk(n=>q(()=>{const r=n.unsafeCurrentTimeMillis();const i=e;const a=FM(t);const o=NK(RK(i),a,ZK(r),r+Nf(gf(this.timeToLive(a))));sF(this.cacheState.map,i,o)}))}get size(){return q(()=>{return uF(this.cacheState.map)})}get values(){return q(()=>{const e=[];for(const t of this.cacheState.map)if(t[1]._tag===`Complete`&&t[1].exit._tag===`Success`)e.push(t[1].exit.value);return e})}get entries(){return q(()=>{const e=[];for(const t of this.cacheState.map)if(t[1]._tag===`Complete`&&t[1].exit._tag===`Success`)e.push([t[0],t[1].exit.value]);return e})}get keys(){return q(()=>{const e=[];for(const t of this.cacheState.map)if(t[1]._tag===`Complete`&&t[1].exit._tag===`Success`)e.push(t[0]);return e})}resolveMapValue(e,t=false){return Vk(n=>{switch(e._tag){case`Complete`:{this.trackAccess(e.key);if(this.hasExpired(n,e.timeToLiveMillis)){lF(this.cacheState.map,e.key.current);return G(N())}this.trackHit();return W(e.exit,P)}case`Pending`:{this.trackAccess(e.key);this.trackHit();if(t)return G(N());return W(Vw(e.deferred),P)}case`Refreshing`:{this.trackAccess(e.complete.key);this.trackHit();if(this.hasExpired(n,e.complete.timeToLiveMillis)){if(t)return G(N());return W(Vw(e.deferred),P)}return W(e.complete.exit,P)}}})}trackHit(){this.cacheState.hits=this.cacheState.hits+1}trackMiss(){this.cacheState.misses=this.cacheState.misses+1}trackAccess(e){jK(this.cacheState.accesses,e);if(qf(this.cacheState.updating,false,true)){let e=true;while(e){const t=MK(this.cacheState.accesses,DK);if(t===DK)e=false;else this.cacheState.keys.add(t)}let t=uF(this.cacheState.map);e=t>this.capacity;while(e){const n=this.cacheState.keys.remove();if(n!==void 0){if(oF(this.cacheState.map,n.current)){lF(this.cacheState.map,n.current);t=t-1;e=t>this.capacity}}else e=false}Yf(this.cacheState.updating,false)}}hasExpired(e,t){return e.unsafeCurrentTimeMillis()>t}lookupValueOf(e,t){return Vk(n=>K(()=>{const r=e;return c(this.lookup(e),BS(this.context),my,U(e=>{const i=n.unsafeCurrentTimeMillis();const a=ZK(i);const o=NK(RK(r),e,a,i+Nf(gf(this.timeToLive(e))));sF(this.cacheState.map,r,o);return Y(Ww(t,e),e)}),Ry(()=>Y(Zw(t),q(()=>{lF(this.cacheState.map,r)}))))}))}};const $K=(e,t,n)=>new QK(e,qd(),ap,t,e=>gf(n(e)));const eq=_(Symbol.for(`effect/FiberRef/currentCache`),()=>Ib($K(65536,()=>W(_S(),e=>({listeners:new jI,handle:e})),()=>Of(60))));const tq=_(Symbol.for(`effect/FiberRef/currentCacheEnabled`),()=>Ib(false));const nq=(e,t)=>U(z(t)?t:G(t),t=>vy(n=>{const r=new Proxy(e,{});return Eb(tq,e=>{if(e){const e=Eb(eq,i=>U(i.getEither(r),a=>{switch(a._tag){case`Left`:{if(a.left.listeners.interrupted)return U(i.invalidateWhen(r,e=>e.handle===a.left.handle),()=>e);a.left.listeners.increment();return Jy(e=>U(my(Uv(sv,e(yS(a.left.handle)))),e=>{a.left.listeners.decrement();return e}))}case`Right`:{a.right.listeners.increment();return Jy(e=>U(my(Uv(uv(t,vv({request:r,result:a.right.handle,listeners:a.right.listeners,ownerId:n,state:{completed:false}})),e(yS(a.right.handle)))),()=>{a.right.listeners.decrement();return yS(a.right.handle)}))}}}));return e}const i=new jI;i.increment();return U(_S(),e=>sV(Uv(uv(t,vv({request:r,result:e,listeners:i,ownerId:n,state:{completed:false}})),yS(e)),q(()=>i.decrement())))})}));const rq=(e,t)=>{return Eb(tq,n=>{if(n)return Eb(eq,n=>U(n.getEither(e),e=>{switch(e._tag){case`Left`:return J;case`Right`:return bS(e.right.handle,t)}}));return J})};const iq=t(2,(e,t)=>Pb(e,tq,t));const aq=t(2,(e,t)=>Pb(e,eq,t));const oq=vI;const sq=xI;const cq=SI;const lq=CI;const uq=wI;const dq=TI;const fq=EI;const pq=lV;const mq=DI;const hq=OI;const gq=kI;const _q=AI;const vq=_v;const yq=vv;const bq=Gv;const xq=z;const Sq=BH;const Cq=VH;const wq=BA;const Tq=eU;const Eq=WA;const Dq=qz;const Oq=Jz;const kq=Yz;const Aq=$k;const jq=eA;const Mq=mj;const Nq=hj;const Pq=mA;const Fq=Vz;const Iq=Uz;const Lq=rA;const Rq=lA;const zq=Qz;const Bq=vA;const Vq=lB;const Hq=uB;const Uq=ej;const Wq=nj;const Gq=tj;const Kq=mB;const qq=Xz;const Jq=Zz;const Yq=dB;const Xq=OB;const Zq=ny;const Qq=VW;const $q=$v;const eJ=B;const tJ=V;const nJ=hy;const rJ=H;const iJ=gy;const aJ=uy;const oJ=dy;const sJ=fy;const cJ=$y;const lJ=ub;const uJ=UA;const dJ=XA;const fJ=G;const pJ=lj;const mJ=uj;const hJ=K;const gJ=q;const _J=J;const vJ=ob;const yJ=Pk;const bJ=iy;const xJ=ry;const SJ=Fk;const CJ=ay;const wJ=oy;const TJ=Ik;const EJ=Lk;const DJ=Rk;const OJ=zk;const kJ=Bk;const AJ=nA;const jJ=yA;const MJ=bA;const NJ=JA;const PJ=oj;const FJ=aK;const IJ=hK;const LJ=sK;const RJ=Nk;const zJ=Ej;const BJ=Dj;const VJ=Tj;const HJ=Aj;const UJ=Gk;const WJ=sy;const GJ=rV;const KJ=ky;const qJ=Ay;const JJ=jy;const YJ=My;const XJ=Ry;const ZJ=qy;const QJ=Jy;const $J=sA;const eY=Zv;const tY=jk;const nY=Mk;const rY=Qv;const iY=Sy;const aY=fA;const oY=W;const sY=RA;const cY=Py;const lY=Fy;const uY=zA;const dY=VA;const fY=HA;const pY=Iz;const mY=Lz;const hY=Xv;const gY=Rz;const _Y=sV;const vY=Iy;const yY=Ly;const bY=hB;const xY=SB;const SY=_B;const CY=zB;const wY=yB;const TY=bB;const EY=xB;const DY=TB;const OY=MB;const kY=zH;const AY=zz;const jY=Kk;const MY=Wk;const NY=qk;const PY=GH;const FY=KH;const IY=_y;const LY=vy;const RY=nB;const zY=rB;const BY=qH;const VY=JH;const HY=YH;const UY=iB;const WY=XH;const GY=ZH;const KY=nU;const qY=Gy;const JY=tb;const YY=nk;const XY=Jb;const ZY=Yb;const QY=Hk;const $Y=Vk;const eX=kB;const tX=Dw;const nX=dG;const rX=fG;const iX=mG;const aX=pG;const oX=Uk;const sX=cj;const cX=xj;const lX=Sj;const uX=rU;const dX=oU;const fX=iU;const pX=aU;const mX=sU;const hX=kw;const gX=Ow;const _X=jB;const vX=RS;const yX=tA;const bX=zS;const xX=HS;const SX=uG;const CX=ZA;const wX=QA;const TX=Rj;const EX=Lj;const DX=zj;const OX=Bj;const kX=Vj;const AX=Hj;const jX=Uj;const MX=Mj;const NX=Yk;const PX=Xk;const FX=yU;const IX=Zk;const LX=Qk;const RX=GA;const zX=py;const BX=my;const VX=Ny;const HX=Oy;const UX=iA;const WX=aA;const GX=oA;const KX=cA;const qX=US;const JX=WS;const YX=Oj;const XX=kj;const ZX=Nj;const QX=Xy;const $X=Pj;const eZ=Fj;const tZ=U;const nZ=yy;const rZ=xy;const iZ=iV;const aZ=fB;const oZ=tU;const sZ=nV;const cZ=dj;const lZ=Wy;const uZ=gj;const dZ=_j;const fZ=vj;const pZ=yj;const mZ=bj;const hZ=gA;const gZ=wA;const _Z=FA;const vZ=tK;const yZ=ij;const bZ=nK;const xZ=lK;const SZ=mK;const CZ=uK;const wZ=Zy;const TZ=_A;const EZ=xA;const DZ=Pb;const OZ=Fb;const kZ=qB;const AZ=JB;const jZ=YA;const MZ=sj;const NZ=jj;const PZ=SA;const FZ=CA;const IZ=pA;const LZ=Cy;const RZ=wy;const zZ=Ty;const BZ=EA;const VZ=DA;const HZ=OA;const UZ=kA;const WZ=AA;const GZ=jA;const KZ=MA;const qZ=NA;const JZ=Ak;const YZ=Pz;const XZ=PA;const ZZ=ex;const QZ=Fz;const $Z=By;const eQ=Vy;const tQ=zy;const nQ=KA;const rQ=qA;const iQ=dA;const aQ=$A;const oQ=Aw;const sQ=jw;const cQ=AB;const lQ=MW;const uQ=Uy;const dQ=Yy;const fQ=rb;const pQ=LB;const mQ=fj;const hQ=pj;const gQ=CB;const _Q=wB;const vQ=nx;const yQ=Ij;const bQ=PH;const xQ=FH;const SQ=LH;const CQ=RH;const wQ=IW;const TQ=FW;const EQ=LW;const DQ=RW;const OQ=zW;const kQ=BW;const AQ=EB;const jQ=DB;const MQ=NB;const NQ=PB;const PQ=FB;const FQ=IB;const IQ=Uv;const LQ=Wv;const RQ=by;const zQ=t(e=>sq(e[0]),nq);const BQ=rq;const VQ=nb;const HQ=iq;const UQ=aq;const WQ=wj;const GQ=Mw;const KQ=Nw;const qQ=dV;const JQ=ib;const YQ=ab;const XQ=Kj;const ZQ=Wj;const QQ=Jj;const $Q=qj;const e$=eM;const t$=tM;const n$=Yj;const r$=Gj;const i$=$j;const a$=uV;const o$=rM;const s$=aM;const c$=oM;const l$=fV;const u$=iM;const d$=sM;const f$=cM;const p$=eb;const m$=(e,t=[])=>({value:e,forest:t});const h$=e=>oY(F$(e),e=>_$(e));const g$=e=>OQ(h$(e));const _$=e=>e.value+v$(`
`,e.forest);const v$=(e,t)=>{let n=``;const r=t.length;let i;for(let a=0;a<r;a++){i=t[a];const o=a===r-1;n+=e+(o?`└`:`├`)+`─ `+i.value;n+=v$(e+(r>1&&!o?`│  `:`   `),i.forest)}return n};const y$=e=>{switch(e){case`Encoded`:return`Encoded side transformation failure`;case`Transformation`:return`Transformation process failure`;case`Type`:return`Type side transformation failure`}};const b$=e=>{switch(e){case`From`:return`From side refinement failure`;case`Predicate`:return`Predicate refinement failure`}};const x$=e=>`ast`in e?P(e.ast):N();const S$=e=>x$(e).pipe(Yn(ta),tZ(t=>{const n=t(e);return se(n)?fJ({message:n,override:false}):xq(n)?oY(n,e=>({message:e,override:false})):se(n.message)?fJ({message:n.message,override:n.override}):oY(n.message,e=>({message:e,override:n.override}))}));const C$=e=>t=>t._tag===e;const w$=C$(`Composite`);const T$=C$(`Refinement`);const E$=C$(`Transformation`);const D$=e=>S$(e).pipe(tZ(t=>{const n=!t.override&&(w$(e)||T$(e)&&e.kind===`From`||E$(e)&&e.kind!==`Transformation`);return n?E$(e)||T$(e)?D$(e.issue):N():fJ(t.message)}));const O$=e=>x$(e).pipe(Yn(ca),Zn(t=>Un(t(e))));const k$=e=>D$(e).pipe(tQ(()=>O$(e)),bJ(()=>fJ(e.message??`Expected ${String(e.ast)}, actual ${Ci(e.actual)}`)));const A$=e=>Bn(O$(e),()=>String(e.ast));const j$=e=>e.message??`is forbidden`;const M$=e=>e.message??`is unexpected`;const N$=e=>na(e.ast).pipe(tZ(e=>{const t=e();return se(t)?fJ(t):t}),bJ(()=>fJ(e.message??`is missing`)));const P$=(e,t)=>zZ(D$(e),{onFailure:t,onSuccess:e=>fJ(m$(e))});const F$=e=>{switch(e._tag){case`Type`:return oY(k$(e),m$);case`Forbidden`:return fJ(m$(A$(e),[m$(j$(e))]));case`Unexpected`:return fJ(m$(M$(e)));case`Missing`:return oY(N$(e),m$);case`Transformation`:return P$(e,()=>oY(F$(e.issue),t=>m$(A$(e),[m$(y$(e.kind),[t])])));case`Refinement`:return P$(e,()=>oY(F$(e.issue),t=>m$(A$(e),[m$(b$(e.kind),[t])])));case`Pointer`:return oY(F$(e.issue),t=>m$(Oi(e.path),[t]));case`Composite`:{const t=A$(e);return P$(e,()=>Ti(e.issues)?oY(zq(e.issues,F$),e=>m$(t,e)):oY(F$(e.issues),e=>m$(t,[e])))}}};var I$=class{path;actual;issue;_tag=`Pointer`;constructor(e,t,n){this.path=e;this.actual=t;this.issue=n}};var L$=class{actual;message;_tag=`Unexpected`;constructor(e,t){this.actual=e;this.message=t}};var R$=class{ast;message;_tag=`Missing`;actual=void 0;constructor(e,t){this.ast=e;this.message=t}};var z$=class{ast;actual;issues;output;_tag=`Composite`;constructor(e,t,n,r){this.ast=e;this.actual=t;this.issues=n;this.output=r}};var B$=class{ast;actual;kind;issue;_tag=`Refinement`;constructor(e,t,n,r){this.ast=e;this.actual=t;this.kind=n;this.issue=r}};var V$=class{ast;actual;kind;issue;_tag=`Transformation`;constructor(e,t,n,r){this.ast=e;this.actual=t;this.kind=n;this.issue=r}};var H$=class{ast;actual;message;_tag=`Type`;constructor(e,t,n){this.ast=e;this.actual=t;this.message=n}};var U$=class{ast;actual;message;_tag=`Forbidden`;constructor(e,t,n){this.ast=e;this.actual=t;this.message=n}};const W$=Symbol.for(`@effect/schema/ParseErrorTypeId`);var G$=class extends yG(`ParseError`){[W$]=W$;get message(){return this.toString()}toString(){return g$(this.issue)}toJSON(){return{_id:`ParseError`,message:this.toString()}}[T](){return this.toJSON()}};const K$=e=>new G$({issue:e});const q$=j;const J$=M;const Y$=mn;const X$=pn;const Z$=t(2,(e,t)=>{const n=e;if(n[`_tag`]===`Left`)return n;if(n[`_tag`]===`Right`)return t(n.right);return tZ(e,t)});const Q$=t(2,(e,t)=>{const n=e;if(n[`_tag`]===`Left`)return n;if(n[`_tag`]===`Right`)return j(t(n.right));return oY(e,t)});const $$=t(2,(e,t)=>{const n=e;if(n[`_tag`]===`Left`)return M(t(n.left));if(n[`_tag`]===`Right`)return n;return lY(e,t)});const e1=e=>{const t=e;if(t[`_tag`]===`Left`||t[`_tag`]===`Right`)return t};const t1=t(2,(e,t)=>{const n=e;if(n[`_tag`]===`Left`)return t(n.left);if(n[`_tag`]===`Right`)return n;return bJ(e,t)});const n1=(e,t)=>{if(t===void 0||ce(t))return e;if(e===void 0)return t;return{...e,...t}};const r1=(e,t,n)=>{const r=l1(e,t);return(e,t)=>r(e,n1(n,t))};const i1=(e,t,n)=>{const r=r1(e,t,n);return(e,t)=>wn(r(e,t),K$)};const a1=(e,t)=>i1(Eo(e.ast),true,t);const o1=(e,t)=>{const n=l1(Eo(e.ast),true);return(e,r)=>_n(n(e,{exact:true,...n1(t,r)}))};const s1=_(Symbol.for(`@effect/schema/Parser/decodeMemoMap`),()=>new WeakMap);const c1=_(Symbol.for(`@effect/schema/Parser/encodeMemoMap`),()=>new WeakMap);const l1=(e,t)=>{const n=t?s1:c1;const r=n.get(e);if(r)return r;const i=f1(e,t);const a=la(e);const o=F(a)?(e,t)=>i(e,n1(t,a.value)):i;const s=ua(e);const c=t&&F(s)?(t,n)=>v1(t1(o(t,n),s.value),e,t,n):o;n.set(e,c);return c};const u1=e=>Wn(oa(e));const d1=e=>Wn(sa(e));const f1=(e,t)=>{switch(e._tag){case`Refinement`:if(t){const t=l1(e.from,true);return(n,r)=>{r=r??ho;const i=r?.errors===`all`;const a=Z$(t1(t(n,r),t=>{const a=new B$(e,n,`From`,t);if(i&&pa(e))return Ln(e.filter(n,r,e),{onNone:()=>M(a),onSome:t=>M(new z$(e,n,[a,new B$(e,n,`Predicate`,t)]))});return M(a)}),t=>Ln(e.filter(t,r,e),{onNone:()=>j(t),onSome:t=>M(new B$(e,n,`Predicate`,t))}));return v1(a,e,n,r)}}else{const t=l1(Eo(e),true);const n=l1(_1(e.from),false);return(r,i)=>v1(Z$(t(r,i),e=>n(e,i)),e,r,i)}case`Transformation`:{const n=x1(e.transformation,t);const r=t?l1(e.from,true):l1(e.to,false);const i=t?l1(e.to,true):l1(e.from,false);return(a,o)=>v1(Z$($$(r(a,o),n=>new V$(e,a,t?`Encoded`:`Type`,n)),r=>Z$($$(n(r,o??ho,e,a),t=>new V$(e,a,`Transformation`,t)),n=>$$(i(n,o),n=>new V$(e,a,t?`Type`:`Encoded`,n)))),e,a,o)}case`Declaration`:{const n=t?e.decodeUnknown(...e.typeParameters):e.encodeUnknown(...e.typeParameters);return(t,r)=>v1(n(t,r??ho,e),e,t,r)}case`Literal`:return m1(e,t=>t===e.literal);case`UniqueSymbol`:return m1(e,t=>t===e.symbol);case`UndefinedKeyword`:return m1(e,pe);case`NeverKeyword`:return m1(e,me);case`UnknownKeyword`:case`AnyKeyword`:case`VoidKeyword`:return j;case`StringKeyword`:return m1(e,se);case`NumberKeyword`:return m1(e,ce);case`BooleanKeyword`:return m1(e,le);case`BigIntKeyword`:return m1(e,ue);case`SymbolKeyword`:return m1(e,de);case`ObjectKeyword`:return m1(e,ge);case`Enums`:return m1(e,t=>e.enums.some(([e,n])=>n===t));case`TemplateLiteral`:{const t=wo(e);return m1(e,e=>se(e)&&t.test(e))}case`TupleType`:{const n=e.elements.map(e=>l1(e.type,t));const r=e.rest.map(e=>l1(e.type,t));let i=e.elements.filter(e=>!e.isOptional);if(e.rest.length>0)i=i.concat(e.rest.slice(1));const a=i.length;const o=e.elements.length>0?e.elements.map((e,t)=>t).join(` | `):`never`;const s=u1(e);const c=d1(e);return(t,l)=>{if(!yr(t))return M(new H$(e,t));const u=l?.errors===`all`;const d=[];let f=0;const p=[];const m=t.length;for(let n=m;n<=a-1;n++){const r=new I$(n,t,new R$(i[n-m]));if(u){d.push([f++,r]);continue}else return M(new z$(e,t,r,p))}if(e.rest.length===0)for(let n=e.elements.length;n<=m-1;n++){const r=new I$(n,t,new L$(t[n],`is unexpected, expected: ${o}`));if(u){d.push([f++,r]);continue}else return M(new z$(e,t,r,p))}let h=0;let g=void 0;for(;h<n.length;h++)if(m<h+1){if(e.elements[h].isOptional)continue}else{const r=n[h];const i=r(t[h],l);const a=e1(i);if(a){if(gn(a)){const n=new I$(h,t,a.left);if(u){d.push([f++,n]);continue}else return M(new z$(e,t,n,b1(p)))}p.push([f++,a.right])}else{const n=f++;const r=h;if(!g)g=[];g.push(({es:a,output:o})=>tZ(zX(i),i=>{if(gn(i)){const s=new I$(r,t,i.left);if(u){a.push([n,s]);return _J}else return M(new z$(e,t,s,b1(o)))}o.push([n,i.right]);return _J}))}}if(Cr(r)){const[n,...i]=r;for(;h<m-i.length;h++){const r=n(t[h],l);const i=e1(r);if(i)if(gn(i)){const n=new I$(h,t,i.left);if(u){d.push([f++,n]);continue}else return M(new z$(e,t,n,b1(p)))}else p.push([f++,i.right]);else{const n=f++;const i=h;if(!g)g=[];g.push(({es:a,output:o})=>tZ(zX(r),r=>{if(gn(r)){const s=new I$(i,t,r.left);if(u){a.push([n,s]);return _J}else return M(new z$(e,t,s,b1(o)))}else{o.push([n,r.right]);return _J}}))}}for(let n=0;n<i.length;n++){h+=n;if(m<h+1)continue;else{const r=i[n](t[h],l);const a=e1(r);if(a){if(gn(a)){const n=new I$(h,t,a.left);if(u){d.push([f++,n]);continue}else return M(new z$(e,t,n,b1(p)))}p.push([f++,a.right])}else{const n=f++;const i=h;if(!g)g=[];g.push(({es:a,output:o})=>tZ(zX(r),r=>{if(gn(r)){const s=new I$(i,t,r.left);if(u){a.push([n,s]);return _J}else return M(new z$(e,t,s,b1(o)))}o.push([n,r.right]);return _J}))}}}}const ee=({es:n,output:r})=>Sr(n)?M(new z$(e,t,b1(n),b1(r))):j(b1(r));if(g&&g.length>0){const e=g;return hJ(()=>{const t={es:Yr(d),output:Yr(p)};return tZ(zq(e,e=>e(t),{concurrency:s,batching:c,discard:true}),()=>ee(t))})}return ee({output:p,es:d})}}case`TypeLiteral`:{if(e.propertySignatures.length===0&&e.indexSignatures.length===0)return m1(e,ye);const n=[];const r={};const i=[];for(const a of e.propertySignatures){n.push([l1(a.type,t),a]);r[a.name]=null;i.push(a.name)}const a=e.indexSignatures.map(e=>[l1(e.parameter,t),l1(e.type,t),e.parameter]);const o=so.make(e.indexSignatures.map(e=>e.parameter).concat(i.map(e=>de(e)?new ba(e):new va(e))));const s=l1(o,t);const c=u1(e);const l=d1(e);return(t,u)=>{if(!Ce(t))return M(new H$(e,t));const d=u?.errors===`all`;const f=[];let p=0;const m=u?.onExcessProperty===`error`;const h=u?.onExcessProperty===`preserve`;const g={};let ee;if(m||h){ee=bi(t);for(const n of ee){const r=e1(s(n,u));if(gn(r))if(m){const r=new I$(n,t,new L$(t[n],`is unexpected, expected: ${String(o)}`));if(d){f.push([p++,r]);continue}else return M(new z$(e,t,r,g))}else g[n]=t[n]}}let te=void 0;const ne=u?.exact===true;for(let r=0;r<n.length;r++){const i=n[r][1];const a=i.name;const o=Object.prototype.hasOwnProperty.call(t,a);if(!o){if(i.isOptional)continue;else if(ne){const n=new I$(a,t,new R$(i));if(d){f.push([p++,n]);continue}else return M(new z$(e,t,n,g))}}const s=n[r][0];const c=s(t[a],u);const l=e1(c);if(l){if(gn(l)){const n=new I$(a,t,o?l.left:new R$(i));if(d){f.push([p++,n]);continue}else return M(new z$(e,t,n,g))}g[a]=l.right}else{const n=p++;const r=a;if(!te)te=[];te.push(({es:a,output:s})=>tZ(zX(c),c=>{if(gn(c)){const l=new I$(r,t,o?c.left:new R$(i));if(d){a.push([n,l]);return _J}else return M(new z$(e,t,l,s))}s[r]=c.right;return _J}))}}for(let n=0;n<a.length;n++){const i=a[n];const o=i[0];const s=i[1];const c=yi(t,i[2]);for(const n of c){const i=e1(o(n,u));if(i&&_n(i)){const i=s(t[n],u);const a=e1(i);if(a){if(gn(a)){const r=new I$(n,t,a.left);if(d){f.push([p++,r]);continue}else return M(new z$(e,t,r,g))}else if(!Object.prototype.hasOwnProperty.call(r,n))g[n]=a.right}else{const a=p++;const o=n;if(!te)te=[];te.push(({es:s,output:c})=>tZ(zX(i),i=>{if(gn(i)){const n=new I$(o,t,i.left);if(d){s.push([a,n]);return _J}else return M(new z$(e,t,n,c))}else{if(!Object.prototype.hasOwnProperty.call(r,n))c[n]=i.right;return _J}}))}}}}const re=({es:n,output:r})=>{if(Sr(n))return M(new z$(e,t,b1(n),r));if(u?.propertyOrder===`original`){const e=ee||bi(t);for(const t of i)if(e.indexOf(t)===-1)e.push(t);const n={};for(const t of e)if(Object.prototype.hasOwnProperty.call(r,t))n[t]=r[t];return j(n)}return j(r)};if(te&&te.length>0){const e=te;return hJ(()=>{const t={es:Yr(f),output:Object.assign({},g)};return tZ(zq(e,e=>e(t),{concurrency:c,batching:l,discard:true}),()=>re(t))})}return re({es:f,output:g})}}case`Union`:{const n=g1(e.types,t);const r=bi(n.keys);const i=r.length;const a=new Map;for(let n=0;n<e.types.length;n++)a.set(e.types[n],l1(e.types[n],t));const o=u1(e)??1;const s=d1(e);return(t,c)=>{const l=[];let u=0;let d=[];if(i>0)if(p1(t))for(let e=0;e<i;e++){const i=r[e];const a=n.keys[i].buckets;if(Object.prototype.hasOwnProperty.call(t,i)){const e=String(t[i]);if(Object.prototype.hasOwnProperty.call(a,e))d=d.concat(a[e]);else{const e=so.make(n.keys[i].literals);l.push([u++,new z$(new eo([new Za(i,e,false,true)],[]),t,new I$(i,t,new H$(e,t[i])))])}}else{const e=so.make(n.keys[i].literals);const r=new Za(i,e,false,true);l.push([u++,new z$(new eo([r],[]),t,new I$(i,t,new R$(r)))])}}else l.push([u++,new H$(e,t)]);if(n.otherwise.length>0)d=d.concat(n.otherwise);let f=void 0;for(let e=0;e<d.length;e++){const n=d[e];const r=a.get(n)(t,c);const i=!f||f.length===0?e1(r):void 0;if(i)if(_n(i))return i;else l.push([u++,i.left]);else{const e=u++;if(!f)f=[];f.push(t=>hJ(()=>{if(`finalResult`in t)return _J;else return tZ(zX(r),n=>{if(_n(n))t.finalResult=n;else t.es.push([e,n.left]);return _J})}))}}const p=n=>Sr(n)?n.length===1&&n[0][1]._tag===`Type`?M(n[0][1]):M(new z$(e,t,b1(n))):M(new H$(e,t));if(f&&f.length>0){const e=f;return hJ(()=>{const t={es:Yr(l)};return tZ(zq(e,e=>e(t),{concurrency:o,batching:s,discard:true}),()=>{if(`finalResult`in t)return t.finalResult;return p(t.es)})})}return p(l)}}case`Suspend`:{const n=xi(()=>l1(xo(e.f(),e.annotations),t));return(e,t)=>n()(e,t)}}};const p1=e=>typeof e===`object`&&e!==null;const m1=(e,t)=>n=>t(n)?j(n):M(new H$(e,n));const h1=(e,t)=>{switch(e._tag){case`Declaration`:{const n=da(e);if(F(n))return h1(n.value,t);break}case`TypeLiteral`:{const n=[];for(let r=0;r<e.propertySignatures.length;r++){const i=e.propertySignatures[r];const a=t?Mo(i.type):Eo(i.type);if(ya(a)&&!i.isOptional)n.push([i.name,a])}return n}case`TupleType`:{const n=[];for(let r=0;r<e.elements.length;r++){const i=e.elements[r];const a=t?Mo(i.type):Eo(i.type);if(ya(a)&&!i.isOptional)n.push([r,a])}return n}case`Refinement`:return h1(e.from,t);case`Suspend`:return h1(e.f(),t);case`Transformation`:return h1(t?e.from:e.to,t)}return[]};const g1=(e,t)=>{const n={};const r=[];for(let i=0;i<e.length;i++){const a=e[i];const o=h1(a,t);if(o.length>0)for(let e=0;e<o.length;e++){const[t,r]=o[e];const i=String(r.literal);n[t]=n[t]||{buckets:{},literals:[]};const s=n[t].buckets;if(Object.prototype.hasOwnProperty.call(s,i)){if(e<o.length-1)continue;s[i].push(a);n[t].literals.push(r)}else{s[i]=[a];n[t].literals.push(r);break}}else r.push(a)}return{keys:n,otherwise:r}};const _1=e=>mo(e)?_1(e.from):e;const v1=(e,t,n,r)=>{const i=e1(e);if(i)return i;if(r?.isEffectAllowed===true)return e;try{return OQ(zX(e))}catch(e){return M(new U$(t,n,`cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work`))}};const y1=([e],[t])=>e>t?1:e<t?-1:0;function b1(e){return e.sort(y1).map(e=>e[1])}const x1=(e,t)=>{switch(e._tag){case`FinalTransformation`:return t?e.decode:e.encode;case`ComposeTransformation`:return j;case`TypeLiteralTransformation`:return n=>{let r=j(n);for(const n of e.propertySignatureTransformations){const[e,i]=t?[n.from,n.to]:[n.to,n.from];const a=t?n.decode:n.encode;const o=t=>{const n=a(Object.prototype.hasOwnProperty.call(t,e)?P(t[e]):N());delete t[e];if(F(n))t[i]=n.value;return t};r=Q$(r,o)}return r}}};const S1=Symbol.for(`@effect/schema/EquivalenceHookId`);const C1=Symbol.for(`@effect/schema/PrettyHookId`);const w1=ea(C1);const T1=e=>t=>Ln(w1(t),{onNone:()=>e,onSome:e=>e()});const E1=T1(Ci);const D1=Symbol.for(`effect/Encoding/errors/Decode`);const O1=(e,t)=>{const n={_tag:`DecodeException`,[D1]:D1,input:e};if(se(t))n.message=t;return n};const k1=e=>v(e,D1);const A1=Symbol.for(`effect/Encoding/errors/Encode`);const j1=(e,t)=>{const n={_tag:`EncodeException`,[A1]:A1,input:e};if(se(t))n.message=t;return n};const M1=e=>v(e,A1);const N1=new TextEncoder;const P1=new TextDecoder;const F1=e=>{const t=e.length;let n=``;let r;for(r=2;r<t;r+=3){n+=z1[e[r-2]>>2];n+=z1[(e[r-2]&3)<<4|e[r-1]>>4];n+=z1[(e[r-1]&15)<<2|e[r]>>6];n+=z1[e[r]&63]}if(r===t+1){n+=z1[e[r-2]>>2];n+=z1[(e[r-2]&3)<<4];n+=`==`}if(r===t){n+=z1[e[r-2]>>2];n+=z1[(e[r-2]&3)<<4|e[r-1]>>4];n+=z1[(e[r-1]&15)<<2];n+=`=`}return n};const I1=e=>{const t=L1(e);const n=t.length;if(n%4!==0)return M(O1(t,`Length must be a multiple of 4, but is ${n}`));const r=t.indexOf(`=`);if(r!==-1&&(r<n-2||r===n-2&&t[n-1]!==`=`))return M(O1(t,`Found a '=' character, but it is not at the end`));try{const e=t.endsWith(`==`)?2:t.endsWith(`=`)?1:0;const r=new Uint8Array(3*(n/4)-e);for(let e=0,i=0;e<n;e+=4,i+=3){const n=R1(t.charCodeAt(e))<<18|R1(t.charCodeAt(e+1))<<12|R1(t.charCodeAt(e+2))<<6|R1(t.charCodeAt(e+3));r[i]=n>>16;r[i+1]=n>>8&255;r[i+2]=n&255}return j(r)}catch(e){return M(O1(t,e instanceof Error?e.message:`Invalid input`))}};const L1=e=>e.replace(/[\n\r]/g,``);function R1(e){if(e>=B1.length)throw new TypeError(`Invalid character ${String.fromCharCode(e)}`);const t=B1[e];if(t===255)throw new TypeError(`Invalid character ${String.fromCharCode(e)}`);return t}const z1=[`A`,`B`,`C`,`D`,`E`,`F`,`G`,`H`,`I`,`J`,`K`,`L`,`M`,`N`,`O`,`P`,`Q`,`R`,`S`,`T`,`U`,`V`,`W`,`X`,`Y`,`Z`,`a`,`b`,`c`,`d`,`e`,`f`,`g`,`h`,`i`,`j`,`k`,`l`,`m`,`n`,`o`,`p`,`q`,`r`,`s`,`t`,`u`,`v`,`w`,`x`,`y`,`z`,`0`,`1`,`2`,`3`,`4`,`5`,`6`,`7`,`8`,`9`,`+`,`/`];const B1=[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];const V1=e=>F1(e).replace(/=/g,``).replace(/\+/g,`-`).replace(/\//g,`_`);const H1=e=>{const t=L1(e);const n=t.length;if(n%4===1)return M(O1(t,`Length should be a multiple of 4, but is ${n}`));if(!/^[-_A-Z0-9]*?={0,2}$/i.test(t))return M(O1(t,`Invalid input`));let r=n%4===2?`${t}==`:n%4===3?`${t}=`:t;r=r.replace(/-/g,`+`).replace(/_/g,`/`);return I1(r)};const U1=e=>{let t=``;for(let n=0;n<e.length;++n)t+=G1[e[n]];return t};const W1=e=>{const t=new TextEncoder().encode(e);if(t.length%2!==0)return M(O1(e,`Length must be a multiple of 2, but is ${t.length}`));try{const e=t.length/2;const n=new Uint8Array(e);for(let r=0;r<e;r++){const e=K1(t[r*2]);const i=K1(t[r*2+1]);n[r]=e<<4|i}return j(n)}catch(t){return M(O1(e,t instanceof Error?t.message:`Invalid input`))}};const G1=[`00`,`01`,`02`,`03`,`04`,`05`,`06`,`07`,`08`,`09`,`0a`,`0b`,`0c`,`0d`,`0e`,`0f`,`10`,`11`,`12`,`13`,`14`,`15`,`16`,`17`,`18`,`19`,`1a`,`1b`,`1c`,`1d`,`1e`,`1f`,`20`,`21`,`22`,`23`,`24`,`25`,`26`,`27`,`28`,`29`,`2a`,`2b`,`2c`,`2d`,`2e`,`2f`,`30`,`31`,`32`,`33`,`34`,`35`,`36`,`37`,`38`,`39`,`3a`,`3b`,`3c`,`3d`,`3e`,`3f`,`40`,`41`,`42`,`43`,`44`,`45`,`46`,`47`,`48`,`49`,`4a`,`4b`,`4c`,`4d`,`4e`,`4f`,`50`,`51`,`52`,`53`,`54`,`55`,`56`,`57`,`58`,`59`,`5a`,`5b`,`5c`,`5d`,`5e`,`5f`,`60`,`61`,`62`,`63`,`64`,`65`,`66`,`67`,`68`,`69`,`6a`,`6b`,`6c`,`6d`,`6e`,`6f`,`70`,`71`,`72`,`73`,`74`,`75`,`76`,`77`,`78`,`79`,`7a`,`7b`,`7c`,`7d`,`7e`,`7f`,`80`,`81`,`82`,`83`,`84`,`85`,`86`,`87`,`88`,`89`,`8a`,`8b`,`8c`,`8d`,`8e`,`8f`,`90`,`91`,`92`,`93`,`94`,`95`,`96`,`97`,`98`,`99`,`9a`,`9b`,`9c`,`9d`,`9e`,`9f`,`a0`,`a1`,`a2`,`a3`,`a4`,`a5`,`a6`,`a7`,`a8`,`a9`,`aa`,`ab`,`ac`,`ad`,`ae`,`af`,`b0`,`b1`,`b2`,`b3`,`b4`,`b5`,`b6`,`b7`,`b8`,`b9`,`ba`,`bb`,`bc`,`bd`,`be`,`bf`,`c0`,`c1`,`c2`,`c3`,`c4`,`c5`,`c6`,`c7`,`c8`,`c9`,`ca`,`cb`,`cc`,`cd`,`ce`,`cf`,`d0`,`d1`,`d2`,`d3`,`d4`,`d5`,`d6`,`d7`,`d8`,`d9`,`da`,`db`,`dc`,`dd`,`de`,`df`,`e0`,`e1`,`e2`,`e3`,`e4`,`e5`,`e6`,`e7`,`e8`,`e9`,`ea`,`eb`,`ec`,`ed`,`ee`,`ef`,`f0`,`f1`,`f2`,`f3`,`f4`,`f5`,`f6`,`f7`,`f8`,`f9`,`fa`,`fb`,`fc`,`fd`,`fe`,`ff`];const K1=e=>{if(48<=e&&e<=57)return e-48;if(97<=e&&e<=102)return e-97+10;if(65<=e&&e<=70)return e-65+10;throw new TypeError(`Invalid input`)};const q1=e=>typeof e===`string`?F1(N1.encode(e)):F1(e);const J1=e=>I1(e);const Y1=e=>xn(J1(e),e=>P1.decode(e));const X1=e=>typeof e===`string`?V1(N1.encode(e)):V1(e);const Z1=e=>H1(e);const Q1=e=>xn(Z1(e),e=>P1.decode(e));const $1=e=>typeof e===`string`?U1(N1.encode(e)):U1(e);const e0=e=>W1(e);const t0=e=>xn(e0(e),e=>P1.decode(e));const n0=D1;const r0=O1;const i0=k1;const a0=A1;const o0=j1;const s0=M1;const c0=t(e=>ge(e[0]),(e,...t)=>{const n={};for(const r of t)if(r in e)n[r]=e[r];return n});const l0=t(e=>ge(e[0]),(e,...t)=>{const n={...e};for(const e of t)delete n[e];return n});const u0=te;const d0=Nn;const f0=Symbol.for(`@effect/schema/Schema`);const p0=e=>class t{[f0]=m0;static Type;static Encoded;static Context;static[f0]=m0;static ast=e;static annotations(e){return p0(g0(this.ast,e))}static pipe(){return O(this,arguments)}static toString(){return String(e)}};const m0={_A:e=>e,_I:e=>e,_R:e=>e};const h0=e=>{if(!e)return{};const t={};const n=Object.getOwnPropertySymbols(e);for(const r of n)t[r]=e[r];if(e.typeId!==void 0){const n=e.typeId;if(typeof n===`object`){t[Li]=n.id;t[n.id]=n.annotation}else t[Li]=n}const r=(n,r)=>{if(e[n]!==void 0)t[r]=e[n]};r(`message`,Ri);r(`missingMessage`,zi);r(`identifier`,Bi);r(`title`,Vi);r(`description`,Hi);r(`examples`,Ui);r(`default`,Wi);r(`documentation`,Ki);r(`jsonSchema`,Gi);r(`arbitrary`,es);r(`pretty`,C1);r(`equivalence`,S1);r(`concurrency`,qi);r(`batching`,Ji);r(`parseIssueTitle`,Yi);r(`parseOptions`,Xi);r(`decodingFallback`,Zi);return t};const g0=(e,t)=>xo(e,h0(t));const _0=e=>v(e,f0)&&ge(e[f0]);const v0=(e,t,n)=>p0(new ga(e.map(e=>e.ast),(...e)=>t.decode(...e.map(p0)),(...e)=>t.encode(...e.map(p0)),h0(n)));const y0=(e,t)=>{const n=()=>(t,n,r)=>e(t)?q$(t):J$(new H$(r,t));const r=n;return p0(new ga([],n,r,h0(t)))};const b0=function(){if(Array.isArray(arguments[0])){const e=arguments[0];const t=arguments[1];const n=arguments[2];return v0(e,t,n)}const e=arguments[0];const t=arguments[1];return y0(e,t)};var x0=class extends p0(Ma){};var S0=class extends p0(Fa){};var C0=class extends p0(Ra){};var w0=class e{ast;from;[f0];_Token;constructor(e,t){this.ast=e;this.from=t}annotations(t){return new e(new qa(this.ast.type,this.ast.isOptional,{...this.ast.annotations,...h0(t)}),this.from)}toString(){return`${this.ast.type}${this.ast.isOptional?`?`:``}`}};const T0=(e,t)=>new Ya(e.map(e=>_0(e)?new qa(e.ast,false):e.ast),t.map(e=>_0(e)?new Ka(e.ast):e.ast),true);const E0=(e,t,n=T0(e,t))=>class r extends p0(n){static annotations(e){return E0(this.elements,this.rest,g0(this.ast,e))}static elements=[...e];static rest=[...t]};function D0(...e){return Array.isArray(e[0])?E0(e[0],e.slice(1)):E0(e,[])}const O0=(e,t)=>class n extends E0([],[e],t){static annotations(e){return O0(this.value,g0(this.ast,e))}static value=e};const k0=e=>O0(e);const A0=e=>e?`"?:"`:`":"`;var j0=class extends qa{isReadonly;defaultValue;_tag=`PropertySignatureDeclaration`;constructor(e,t,n,r,i){super(e,t,r);this.isReadonly=n;this.defaultValue=i}toString(){const e=A0(this.isOptional);const t=String(this.type);return`PropertySignature<${e}, ${t}, never, ${e}, ${t}>`}};var M0=class extends qa{isReadonly;fromKey;constructor(e,t,n,r,i){super(e,t,r);this.isReadonly=n;this.fromKey=i}};var N0=class extends qa{isReadonly;defaultValue;constructor(e,t,n,r,i){super(e,t,r);this.isReadonly=n;this.defaultValue=i}};const P0=e=>{if(e===void 0)return`never`;if(se(e))return JSON.stringify(e);return String(e)};var F0=class{from;to;decode;encode;_tag=`PropertySignatureTransformation`;constructor(e,t,n,r){this.from=e;this.to=t;this.decode=n;this.encode=r}toString(){return`PropertySignature<${A0(this.to.isOptional)}, ${this.to.type}, ${P0(this.from.fromKey)}, ${A0(this.from.isOptional)}, ${this.from.type}>`}};const I0=(e,t)=>{switch(e._tag){case`PropertySignatureDeclaration`:return new j0(e.type,e.isOptional,e.isReadonly,{...e.annotations,...t},e.defaultValue);case`PropertySignatureTransformation`:return new F0(new M0(e.from.type,e.from.isOptional,e.from.isReadonly,e.from.annotations),new N0(e.to.type,e.to.isOptional,e.to.isReadonly,{...e.to.annotations,...t},e.to.defaultValue),e.decode,e.encode)}};const L0=Symbol.for(`@effect/schema/PropertySignature`);const R0=e=>v(e,L0);var z0=class e{ast;[f0];[L0]=null;_TypeToken;_Key;_EncodedToken;_HasDefault;constructor(e){this.ast=e}pipe(){return O(this,arguments)}annotations(t){return new e(I0(this.ast,h0(t)))}toString(){return String(this.ast)}};const B0=(e,t)=>{const n=bi(e);const r=[];if(n.length>0){const i=[];const a=[];const o=[];for(let t=0;t<n.length;t++){const s=n[t];const c=e[s];if(R0(c)){const e=c.ast;switch(e._tag){case`PropertySignatureDeclaration`:{const t=e.type;const n=e.isOptional;const o=e.annotations;i.push(new Za(s,t,n,true));a.push(new Za(s,Eo(t),n,true,o));r.push(new Za(s,t,n,true,o));break}case`PropertySignatureTransformation`:{const t=e.from.fromKey??s;i.push(new Za(t,e.from.type,e.from.isOptional,true,e.from.annotations));a.push(new Za(s,e.to.type,e.to.isOptional,true,e.to.annotations));o.push(new yo(t,s,e.decode,e.encode));break}}}else{i.push(new Za(s,c.ast,false,true));a.push(new Za(s,Eo(c.ast),false,true));r.push(new Za(s,c.ast,false,true))}}if(Cr(o)){const e=[];const n=[];for(const r of t){const{indexSignatures:t,propertySignatures:o}=To(r.key.ast,r.value.ast);o.forEach(e=>{i.push(e);a.push(new Za(e.name,Eo(e.type),e.isOptional,e.isReadonly,e.annotations))});t.forEach(t=>{e.push(t);n.push(new $a(t.parameter,Eo(t.type),t.isReadonly))})}return new go(new eo(i,e,{[Vi]:`Struct (Encoded side)`}),new eo(a,n,{[Vi]:`Struct (Type side)`}),new bo(o))}}const i=[];for(const e of t){const{indexSignatures:t,propertySignatures:n}=To(e.key.ast,e.value.ast);n.forEach(e=>r.push(e));t.forEach(e=>i.push(e))}return new eo(r,i)};const V0=(e,t)=>{const n=bi(e);for(const r of n){const n=e[r];if(t[r]===void 0&&R0(n)){const e=n.ast;const i=e._tag===`PropertySignatureDeclaration`?e.defaultValue:e.to.defaultValue;if(i!==void 0)t[r]=i()}}return t};const H0=(e,t,n=B0(e,t))=>{return class r extends p0(n){static annotations(e){return H0(this.fields,this.records,g0(this.ast,e))}static fields={...e};static records=[...t];static make=(t,n)=>{const r=V0(e,{...t});return j2(n)?r:a1(this)(r)};static pick(...t){return U0(c0(e,...t))}static omit(...t){return U0(l0(e,...t))}}};function U0(e,...t){return H0(e,t)}const W0=Do([Bi]);const G0=Symbol.for(`@effect/schema/refine`);const K0=(e,t,n)=>class r extends p0(n){static annotations(e){return K0(this.from,this.filter,g0(this.ast,e))}static[G0]=e;static from=e;static filter=t;static make=(e,t)=>{return j2(t)?e:a1(this)(e)}};const q0=(e,t,n)=>{if(le(e))return e?N():P(new H$(t,n));if(se(e))return P(new H$(t,n,e));if(e!==void 0){if(`_tag`in e)return P(e);const r=new H$(t,n,e.message);return P(Cr(e.path)?new I$(e.path,n,r):r)}return N()};const J0=(e,t,n)=>{if(Ei(e))return q0(e,t,n);if(Cr(e)){const r=ri(e,e=>q0(e,t,n));if(Cr(r))return P(r.length===1?r[0]:new z$(t,n,r))}return N()};function Y0(e,t){return n=>{function r(t,n,r){return J0(e(t,n,r),r,t)}const i=new po(n.ast,r,h0(t));return K0(n,r,i)}}const X0=(e,t,n)=>class r extends p0(n){static annotations(e){return X0(this.from,this.to,g0(this.ast,e))}static from=e;static to=t};const Z0=t(e=>_0(e[0])&&_0(e[1]),(e,t,n)=>X0(e,t,new go(e.ast,t.ast,new vo(n.decode,n.encode))));const Q0=Yo;const $0=Jo;const e2=Xo;const t2=x0.annotations({[Bi]:`JsonString`,[Vi]:`JsonString`,[Hi]:`a JSON string`});const n2=Symbol.for(`@effect/schema/TypeId/Finite`);const r2=e=>t=>t.pipe(Y0(e=>Number.isFinite(e),{typeId:n2,description:`a finite number`,...e}));const i2=Lo;const a2=Ro;const o2=(e,t)=>n=>n.pipe(Y0(t=>t>=e,{typeId:a2,description:e===0?`a non-negative number`:`a number greater than or equal to ${e}`,jsonSchema:{minimum:e},...t}));const s2=Vo;const c2=zo;const l2=Bo;const u2=Ho;const d2=e=>o2(0,e);var f2=class extends S0.pipe(d2({identifier:`NonNegative`,title:`NonNegative`})){};const p2=Uo;const m2=Wo;const h2=Go;const g2=Ko;const _2=qo;const v2=D0(f2.pipe(r2({[Vi]:`seconds`,[Hi]:`seconds`})),f2.pipe(r2({[Vi]:`nanos`,[Hi]:`nanos`})));const y2=b0(be,{identifier:`Uint8ArrayFromSelf`,pretty:()=>e=>`new Uint8Array(${JSON.stringify(Array.from(e))})`,arbitrary:()=>e=>e.uint8Array(),equivalence:()=>ui(w)});const b2=(e,t,n)=>Z0(x0.annotations({description:`a string that will be parsed into a Uint8Array`}),y2,{strict:true,decode:(e,n,r)=>bn(t(e),t=>new H$(r,e,t.message)),encode:e=>q$(n(e))}).annotations({identifier:e});const x2=b2(`Uint8ArrayFromBase64`,J1,q1);const S2=b2(`Uint8ArrayFromBase64Url`,Z1,X1);const C2=b2(`Uint8ArrayFromHex`,e0,$1);const w2=(e,t,n)=>Z0(x0.annotations({description:`A string that is interpreted as being ${e}-encoded and will be decoded into a UTF-8 string`}),x0,{strict:true,decode:(e,n,r)=>bn(t(e),t=>new H$(r,e,t.message)),encode:e=>q$(n(e))}).annotations({identifier:`StringFrom${e}`});const T2=w2(`Base64`,Y1,q1);const E2=w2(`Base64Url`,Q1,X1);const D2=w2(`Hex`,t0,$1);const O2=Zo;const k2=Qo;const A2=$o;const j2=e=>le(e)?e:e?.disableValidation??false;var M2=o1(U0({number:S0,negNumber:S0,maxNumber:S0,string:x0,longString:x0,boolean:C0,deeplyNested:U0({foo:x0,num:S0,bool:C0}),items:k0(S0)}));export{M2 as default};