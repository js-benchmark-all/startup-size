const e=e=>Array.isArray(e)?e:[e];const t=(e,t)=>{const n=[[],[]];for(const r of e)if(t(r))n[0].push(r);else n[1].push(r);return n};const n=Array;const r=(e,t)=>e.includes(t);const i=(e,t=0)=>[...new Array(e)].map((e,n)=>n+t);const a=(e,t,n)=>{if(e===void 0)return t===void 0?[]:Array.isArray(t)?t:[t];if(n?.prepend)if(Array.isArray(t))e.unshift(...t);else e.unshift(t);else if(Array.isArray(t))e.push(...t);else e.push(t);return e};const o=(t,n)=>{if(n===void 0||n===null)return t??[];if(t===void 0||t===null)return e(n);return t.concat(n)};const s=(...e)=>e.reduce(o,[]);const c=(t,n,r)=>{if(t===void 0)return Array.isArray(n)?n:[n];const i=r?.isEqual??((e,t)=>e===t);for(const r of e(n))if(!t.some(e=>i(e,r)))t.push(r);return t};const l=(e,t)=>e.reduce((e,n)=>{const r=n[t];e[r]=a(e[r],n);return e},{});const u=(e,t,n)=>e.length===t.length&&e.every(n?.isEqual?(e,r)=>n.isEqual(e,t[r]):(e,n)=>e===t[n]);const d=(e,t)=>f(e)===t;const f=e=>{const t=typeof e;return t===`object`?e===null?`null`:`object`:t===`function`?`object`:t};const p={boolean:`boolean`,null:`null`,undefined:`undefined`,bigint:`a bigint`,number:`a number`,object:`an object`,string:`a string`,symbol:`a symbol`};const ee={...p,function:`a function`};var te=class extends Error{};const m=e=>ne(e,te);const ne=(e,t=Error)=>{throw new t(e)};var re=class extends Error{name=`ParseError`};const h=e=>ne(e,re);const g=e=>` ${e}`;const _=(e,t)=>{const n={};const r=Array.isArray(e);let i=false;for(const[o,s]of Object.entries(e).entries()){const e=r?t(o,s[1]):t(...s,o);i||=typeof e[0]===`number`;const c=Array.isArray(e[0])||e.length===0?e:[e];for(const[e,t]of c)if(typeof e===`object`)n[e.group]=a(n[e.group],t);else n[e]=t}return i?Object.values(n):n};const ie=Object.entries;const ae=(e,t)=>e in t;const oe=(e,t)=>t in e;var se=class{constructor(e){Object.assign(this,e)}};const ce=class{};var le=class extends ce{};const ue=(e,t)=>{const n={};const r={};let i;for(i in e)if(i in t)n[i]=e[i];else r[i]=e[i];return[n,r]};const de=(e,t)=>ue(e,t)[1];const fe=e=>Object.keys(e).length===0;const pe=e=>[...Object.entries(e),...Object.getOwnPropertySymbols(e).map(t=>[t,e[t]])];const me=(e,t)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(t));const he=e=>{const t=Object.keys(e).sort();const n={};for(let r=0;r<t.length;r++)n[t[r]]=e[t[r]];return n};const v=g(`represents an uninitialized value`);const ge={Array,Boolean,Date,Error,Function,Map,Number,Promise,RegExp,Set,String,WeakMap,WeakSet};const _e=globalThis.File??Blob;const ve={ArrayBuffer,Blob,File:_e,FormData,Headers,Request,Response,URL};const ye={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array};const be={...ge,...ve,...ye,String,Number,Boolean};const xe=e=>{let t=Object.getPrototypeOf(e);while(t?.constructor&&(!ae(t.constructor.name,be)||!(e instanceof be[t.constructor.name])))t=Object.getPrototypeOf(t);const n=t?.constructor?.name;if(n===void 0||n===`Object`)return void 0;return n};const Se=e=>typeof e===`object`&&e!==null?xe(e)??`object`:f(e);const y=Array.isArray;const Ce={Array:`an array`,Function:`a function`,Date:`a Date`,RegExp:`a RegExp`,Error:`an Error`,Map:`a Map`,Set:`a Set`,String:`a String object`,Number:`a Number object`,Boolean:`a Boolean object`,Promise:`a Promise`,WeakMap:`a WeakMap`,WeakSet:`a WeakSet`};const we={ArrayBuffer:`an ArrayBuffer instance`,Blob:`a Blob instance`,File:`a File instance`,FormData:`a FormData instance`,Headers:`a Headers instance`,Request:`a Request instance`,Response:`a Response instance`,URL:`a URL instance`};const Te={Int8Array:`an Int8Array`,Uint8Array:`a Uint8Array`,Uint8ClampedArray:`a Uint8ClampedArray`,Int16Array:`an Int16Array`,Uint16Array:`a Uint16Array`,Int32Array:`an Int32Array`,Uint32Array:`a Uint32Array`,Float32Array:`a Float32Array`,Float64Array:`a Float64Array`,BigInt64Array:`a BigInt64Array`,BigUint64Array:`a BigUint64Array`};const Ee={...Ce,...we,...Te};const De=e=>{const t=Object(e).name??null;return t&&ae(t,be)&&be[t]===e?t:null};const Oe=e=>{let t=Object.getPrototypeOf(e);const n=[];while(t!==null){n.push(t.constructor);t=Object.getPrototypeOf(t)}return n};const ke=(e,t)=>{let n=e.prototype;while(n!==null){if(n===t.prototype)return true;n=Object.getPrototypeOf(n)}return false};const Ae=e=>je(e,new Map);const je=(e,t)=>{if(typeof e!==`object`||e===null)return e;if(t?.has(e))return t.get(e);const n=De(e.constructor);if(n===`Date`)return new Date(e.getTime());if(n&&n!==`Array`)return e;const r=Array.isArray(e)?e.slice():Object.create(Object.getPrototypeOf(e));const i=Object.getOwnPropertyDescriptors(e);if(t){t.set(e,r);for(const e in i){const n=i[e];if(`get`in n||`set`in n)continue;n.value=je(n.value,t)}}Object.defineProperties(r,i);return r};const Me=e=>{let t=v;return()=>t===v?t=e():t};const Ne=e=>typeof e===`function`&&e.length===0;const Pe=class extends Function{constructor(...e){const t=e.slice(0,-1);const n=e.at(-1);try{super(...t,n)}catch(t){return m(`Encountered an unexpected error while compiling your definition:
                Message: ${t} 
                Source: (${e.slice(0,-1)}) => {
                    ${e.at(-1)}
                }`)}}};var Fe=class{constructor(e,...[t]){return Object.assign(Object.setPrototypeOf(e.bind(t?.bind??this),this.constructor.prototype),t?.attach)}};const Ie=Me(()=>{try{return new Function(`return false`)()}catch{return true}});const Le=g(`brand`);const Re=g(`arkInferred`);const ze=g(`args`);const Be=()=>{try{const e=new Error;const t=e.stack?.split(`
`)[2]?.trim()||``;const n=t.match(/\(?(.+?)(?::\d+:\d+)?\)?$/)?.[1]||`unknown`;return n.replace(/^file:\/\//,``)}catch{return`unknown`}};const Ve=globalThis.process?.env??{};const He={fileName:Be,env:Ve};const Ue=e=>e[0].toUpperCase()+e.slice(1);const We=e=>new RegExp(Ge(e),typeof e===`string`?``:e.flags);const Ge=e=>{const t=typeof e===`string`?e:e.source;return`^(?:${t})$`};const b={negativeLookahead:e=>`(?!${e})`,nonCapturingGroup:e=>`(?:${e})`};const Ke=/^-0\.?0*$/.source;const qe=/[1-9]\d*/.source;const Je=/\.\d+/.source;const Ye=/\.\d*[1-9]/.source;const Xe=e=>We(b.negativeLookahead(Ke)+b.nonCapturingGroup(`-?`+b.nonCapturingGroup(b.nonCapturingGroup(`0|`+qe)+b.nonCapturingGroup(e.decimalPattern)+`?`)+(e.allowDecimalOnly?`|`+e.decimalPattern:``)+`?`));const Ze=Xe({decimalPattern:Ye,allowDecimalOnly:false});const Qe=Ze.test.bind(Ze);const $e=Xe({decimalPattern:Je,allowDecimalOnly:true});const et=$e.test.bind($e);const tt=We(b.negativeLookahead(`^-0$`)+`-?`+b.nonCapturingGroup(b.nonCapturingGroup(`0|`+qe)));const nt=tt.test.bind(tt);const rt=/^-?\d+$/;const it=rt.test.bind(rt);const at=`0.46.0`;const ot={version:at,filename:He.fileName(),FileConstructor:_e};const st=ot;const ct=new Map;const lt=Object.create(null);const ut=e=>{const t=ct.get(e);if(t)return t;let n=ft(e);if(lt[n])n=`${n}${lt[n]++}`;else lt[n]=1;st[n]=e;ct.set(e,n);return n};const dt=e=>/^[$A-Z_a-z][\w$]*$/.test(e);const ft=e=>{switch(typeof e){case`object`:{if(e===null)break;const t=xe(e)??`object`;return t[0].toLowerCase()+t.slice(1)}case`function`:return dt(e.name)?e.name:`fn`;case`symbol`:return e.description&&dt(e.description)?e.description:`symbol`}return m(`Unexpected attempt to register serializable value of type ${f(e)}`)};const pt=e=>typeof e===`string`?JSON.stringify(e):typeof e===`bigint`?`${e}n`:`${e}`;const mt=(e,t={})=>gt(e,{onUndefined:`$ark.undefined`,onBigInt:e=>`$ark.bigint-${e}`,...t},[]);const x=(e,t)=>{switch(f(e)){case`object`:const n=e;const r=n.constructor.name;return r===`Object`||r===`Array`?t?.quoteKeys===false?ht(n,t?.indent??0,``):JSON.stringify(gt(n,S,[]),null,t?.indent):ht(n,t?.indent??0,``);case`symbol`:return S.onSymbol(e);default:return pt(e)}};const ht=(e,t,n)=>{if(typeof e===`function`)return S.onFunction(e);if(typeof e!==`object`||e===null)return pt(e);const r=n+` `.repeat(t);if(Array.isArray(e)){if(e.length===0)return`[]`;const i=e.map(e=>ht(e,t,r)).join(`,
`+r);return t?`[\n${r}${i}\n${n}]`:`[${i}]`}const i=e.constructor.name;if(i===`Object`){const i=pe(e).map(([e,n])=>{const i=typeof e===`symbol`?S.onSymbol(e):dt(e)?e:JSON.stringify(e);const a=ht(n,t,r);return`${r}${i}: ${a}`});if(i.length===0)return`{}`;return t?`{\n${i.join(`,
`)}\n${n}}`:`{${i.join(`, `)}}`}if(e instanceof Date)return _t(e);if(`expression`in e&&typeof e.expression===`string`)return e.expression;return i};const S={onCycle:()=>`(cycle)`,onSymbol:e=>`Symbol(${ut(e)})`,onFunction:e=>`Function(${ut(e)})`};const gt=(e,t,n)=>{switch(f(e)){case`object`:{const r=e;if(`toJSON`in r&&typeof r.toJSON===`function`)return r.toJSON();if(typeof r===`function`)return S.onFunction(r);if(n.includes(r))return`(cycle)`;const i=[...n,r];if(Array.isArray(r))return r.map(e=>gt(e,t,i));if(r instanceof Date)return r.toDateString();const a={};for(const e in r)a[e]=gt(r[e],t,i);for(const e of Object.getOwnPropertySymbols(r))a[t.onSymbol?.(e)??e.toString()]=gt(r[e],t,i);return a}case`symbol`:return S.onSymbol(e);case`bigint`:return t.onBigInt?.(e)??`${e}n`;case`undefined`:return t.onUndefined??`undefined`;case`string`:return e.replaceAll(`\\`,`\\\\`);default:return e}};const _t=e=>{const t=e.getFullYear();const n=e.getMonth();const r=e.getDate();const i=e.getHours();const a=e.getMinutes();const o=e.getSeconds();const s=e.getMilliseconds();if(n===0&&r===1&&i===0&&a===0&&o===0&&s===0)return`${t}`;const c=`${vt[n]} ${r}, ${t}`;if(i===0&&a===0&&o===0&&s===0)return c;let l=e.toLocaleTimeString();const u=l.endsWith(` AM`)||l.endsWith(` PM`)?l.slice(-3):``;if(u)l=l.slice(0,-u.length);if(s)l+=`.${bt(s,3)}`;else if(yt.test(l))l=l.slice(0,-3);return`${l+u}, ${c}`};const vt=[`January`,`February`,`March`,`April`,`May`,`June`,`July`,`August`,`September`,`October`,`November`,`December`];const yt=/:\d\d:00$/;const bt=(e,t)=>String(e).padStart(t,`0`);const xt=(e,t,...[n])=>{const r=n?.stringifySymbol??x;let i=e;switch(typeof t){case`string`:i=dt(t)?e===``?t:`${e}.${t}`:`${e}[${JSON.stringify(t)}]`;break;case`number`:i=`${e}[${t}]`;break;case`symbol`:i=`${e}[${r(t)}]`;break;default:if(n?.stringifyNonKey)i=`${e}[${n.stringifyNonKey(t)}]`;else h(`${x(t)} must be a PropertyKey or stringifyNonKey must be passed to options`)}return i};const St=(e,...t)=>e.reduce((e,n)=>xt(e,n,...t),``);var Ct=class extends n{cache={};constructor(...e){super();this.push(...e)}toJSON(){if(this.cache.json)return this.cache.json;this.cache.json=[];for(let e=0;e<this.length;e++)this.cache.json.push(typeof this[e]===`symbol`?x(this[e]):this[e]);return this.cache.json}stringify(){if(this.cache.stringify)return this.cache.stringify;return this.cache.stringify=St(this)}stringifyAncestors(){if(this.cache.stringifyAncestors)return this.cache.stringifyAncestors;let e=``;const t=[e];for(const n of this){e=xt(e,n);t.push(e)}return this.cache.stringifyAncestors=t}};const wt=g(`implementedTraits`);const Tt=e=>t=>{if(!d(t,`object`))return false;if(wt in t.constructor&&t.constructor[wt].includes(e))return true;return Oe(t).includes(e)};var Et=class extends ce{static get[Symbol.hasInstance](){return Tt(this)}traitsOf(){return wt in this.constructor?this.constructor[wt]:[]}};let Dt=`$ark`;let Ot=2;while(Dt in globalThis)Dt=`$ark${Ot++}`;const kt=Dt;globalThis[kt]=st;const C=st;const At=e=>`${kt}.${e}`;const w=e=>At(ut(e));var jt=class extends le{argNames;body=``;constructor(...e){super();this.argNames=e;for(const t of e){if(t in this)throw new Error(`Arg name '${t}' would overwrite an existing property on FunctionBody`);this[t]=t}}indentation=0;indent(){this.indentation+=4;return this}dedent(){this.indentation-=4;return this}prop(e,t=false){return Nt(e,t)}index(e,t=false){return Ft(`${e}`,t)}line(e){this.body+=`${` `.repeat(this.indentation)}${e}\n`;return this}const(e,t){this.line(`const ${e} = ${t}`);return this}let(e,t){return this.line(`let ${e} = ${t}`)}set(e,t){return this.line(`${e} = ${t}`)}if(e,t){return this.block(`if (${e})`,t)}elseIf(e,t){return this.block(`else if (${e})`,t)}else(e){return this.block(`else`,e)}for(e,t,n=0){return this.block(`for (let i = ${n}; ${e}; i++)`,t)}forIn(e,t){return this.block(`for (const k in ${e})`,t)}block(e,t,n=``){this.line(`${e} {`);this.indent();t(this);this.dedent();return this.line(`}${n}`)}return(e=``){return this.line(`return ${e}`)}write(e=`anonymous`,t=0){return`${e}(${this.argNames.join(`, `)}) { ${t?this.body.split(`
`).map(e=>` `.repeat(t)+`${e}`).join(`
`):this.body} }`}compile(){return new Pe(...this.argNames,this.body)}};const Mt=e=>d(e,`object`)||typeof e===`symbol`?w(e):pt(e);const Nt=(e,t=false)=>{if(typeof e===`string`&&dt(e))return`${t?`?`:``}.${e}`;return Ft(Pt(e),t)};const Pt=e=>typeof e===`symbol`?w(e):JSON.stringify(e);const Ft=(e,t=false)=>`${t?`?.`:``}[${e}]`;var It=class extends jt{traversalKind;optimistic;constructor(e){super(`data`,`ctx`);this.traversalKind=e.kind;this.optimistic=e.optimistic===true}invoke(e,t){const n=t?.arg??this.data;const r=typeof e===`string`?true:this.requiresContextFor(e);const i=typeof e===`string`?e:e.id;if(r)return`${this.referenceToId(i,t)}(${n}, ${this.ctx})`;return`${this.referenceToId(i,t)}(${n})`}referenceToId(e,t){const n=t?.kind??this.traversalKind;const r=`this.${e}${n}`;return t?.bind?`${r}.bind(${t?.bind})`:r}requiresContextFor(e){return this.traversalKind===`Apply`||e.allowsRequiresContext}initializeErrorCount(){return this.const(`errorCount`,`ctx.currentErrorCount`)}returnIfFail(){return this.if(`ctx.currentErrorCount > errorCount`,()=>this.return())}returnIfFailFast(){return this.if(`ctx.failFast && ctx.currentErrorCount > errorCount`,()=>this.return())}traverseKey(e,t,n){const r=this.requiresContextFor(n);if(r)this.line(`${this.ctx}.path.push(${e})`);this.check(n,{arg:t});if(r)this.line(`${this.ctx}.path.pop()`);return this}check(e,t){return this.traversalKind===`Allows`?this.if(`!${this.invoke(e,t)}`,()=>this.return(false)):this.line(this.invoke(e,t))}};const Lt=e=>_(e,(e,t)=>[e,y(t)?[...t]:t]);const T=g(`arkKind`);const E=(e,t)=>e?.[T]===t;const D=e=>E(e,`root`)||E(e,`constraint`);const Rt=[`unit`,`proto`,`domain`];const zt=[`required`,`optional`,`index`,`sequence`];const Bt=[`pattern`,`divisor`,`exactLength`,`max`,`min`,`maxLength`,`minLength`,`before`,`after`];const Vt=[...Bt,...zt,`structure`,`predicate`];const Ht=[`alias`,`union`,`morph`,`unit`,`intersection`,`proto`,`domain`];const Ut=[...Ht,...Vt];const Wt=_(Vt,(e,t)=>[t,1]);const Gt=_([...zt,`undeclared`],(e,t)=>[t,1]);const Kt=_(Ut,(e,t)=>[t,e]);const qt=e=>typeof e===`string`&&e in Kt;const Jt=e=>Kt[e];const Yt=e=>Ht.slice(Jt(e)+1);const Xt=[...Yt(`union`),`alias`];const Zt=[...Yt(`morph`),`alias`];const O=e=>{if(typeof e===`string`||typeof e===`boolean`||e===null)return e;if(typeof e===`number`){if(Number.isNaN(e))return`NaN`;if(e===Number.POSITIVE_INFINITY)return`Infinity`;if(e===Number.NEGATIVE_INFINITY)return`-Infinity`;return e}return Mt(e)};const Qt=e=>{let t=`{ `;for(const[n,r]of Object.entries(e))t+=`${n}: ${Mt(r)}, `;return t+` }`};const k=e=>{const t=e;if(t.hasAssociatedError){t.defaults.expected??=e=>`description`in e?e.description:t.defaults.description(e);t.defaults.actual??=e=>x(e);t.defaults.problem??=e=>`must be ${e.expected}${e.actual?` (was ${e.actual})`:``}`;t.defaults.message??=e=>{if(e.path.length===0)return e.problem;const t=`${e.propString} ${e.problem}`;if(t[0]===`[`)return`value at ${t}`;return t}}return t};var $t=class extends Error{name=`ToJsonSchemaError`;code;context;constructor(e,t){super(x(t,{quoteKeys:false,indent:4}));this.code=e;this.context=t}hasCode(e){return this.code===e}};const en={dialect:`https://json-schema.org/draft/2020-12/schema`,useRefs:false,fallback:{arrayObject:e=>A.throw(`arrayObject`,e),arrayPostfix:e=>A.throw(`arrayPostfix`,e),defaultValue:e=>A.throw(`defaultValue`,e),domain:e=>A.throw(`domain`,e),morph:e=>A.throw(`morph`,e),patternIntersection:e=>A.throw(`patternIntersection`,e),predicate:e=>A.throw(`predicate`,e),proto:e=>A.throw(`proto`,e),symbolKey:e=>A.throw(`symbolKey`,e),unit:e=>A.throw(`unit`,e),date:e=>A.throw(`date`,e)}};const A={Error:$t,throw:(...e)=>{throw new A.Error(...e)},throwInternalOperandError:(e,t)=>m(`Unexpected JSON Schema input for ${e}: ${x(t)}`),defaultConfig:en};C.config??={};const tn=(e,t)=>{if(!t)return e;const n={...e};let r;for(r in t){const i={...e.keywords};if(r===`keywords`){for(const e in t[r]){const n=t.keywords[e];if(n===void 0)continue;i[e]=typeof n===`string`?{description:n}:n}n.keywords=i}else if(r===`toJsonSchema`)n[r]=nn(e.toJsonSchema,t.toJsonSchema);else if(qt(r))n[r]={...e[r],...t[r]};else n[r]=t[r]}return n};const nn=((e,t)=>{if(!e)return t??{};if(!t)return e;const n={...e};let r;for(r in t)if(r===`fallback`)n.fallback=rn(e.fallback,t.fallback);else n[r]=t[r];return n});const rn=(e,t)=>{e=an(e);t=an(t);const n={};let r;for(r in A.defaultConfig.fallback)n[r]=t[r]??t.default??e[r]??e.default??A.defaultConfig.fallback[r];return n};const an=e=>typeof e===`function`?{default:e}:e??{};var on=class e extends le{[T]=`error`;path;data;nodeConfig;input;ctx;constructor({prefixPath:e,relativePath:t,...n},r){super();this.input=n;this.ctx=r;me(this,n);const i=r.data;if(n.code===`union`)n.errors=n.errors.flatMap(n=>{const r=n.hasCode(`union`)?n.errors:[n];if(!e&&!t)return r;return r.map(n=>n.transform(n=>({...n,path:s(e,n.path,t)})))});this.nodeConfig=r.config[this.code];const a=[...n.path??r.path];if(t)a.push(...t);if(e)a.unshift(...e);this.path=new Ct(...a);this.data=`data`in n?n.data:i}transform(t){return new e(t({data:this.data,path:this.path,...this.input}),this.ctx)}hasCode(e){return this.code===e}get propString(){return St(this.path)}get expected(){if(this.input.expected)return this.input.expected;const e=this.meta?.expected??this.nodeConfig.expected;return typeof e===`function`?e(this.input):e}get actual(){if(this.input.actual)return this.input.actual;const e=this.meta?.actual??this.nodeConfig.actual;return typeof e===`function`?e(this.data):e}get problem(){if(this.input.problem)return this.input.problem;const e=this.meta?.problem??this.nodeConfig.problem;return typeof e===`function`?e(this):e}get message(){if(this.input.message)return this.input.message;const e=this.meta?.message??this.nodeConfig.message;return typeof e===`function`?e(this):e}get flat(){return this.hasCode(`intersection`)?[...this.errors]:[this]}toJSON(){return{data:this.data,path:this.path,...this.input,expected:this.expected,actual:this.actual,problem:this.problem,message:this.message}}toString(){return this.message}throw(){throw this}};var sn=class e extends n{[T]=`errors`;ctx;constructor(e){super();this.ctx=e}byPath=Object.create(null);get flatByPath(){return _(this.byPath,(e,t)=>[e,t.flat])}get flatProblemsByPath(){return _(this.byPath,(e,t)=>[e,t.flat.map(e=>e.problem)])}byAncestorPath=Object.create(null);count=0;mutable=this;throw(){throw this.toTraversalError()}toTraversalError(){return new cn(this)}add(e){if(this.includes(e))return;this._add(e)}transform(t){const n=new e(this.ctx);for(const e of this)n.add(t(e));return n}merge(e){for(const t of e){if(this.includes(t))continue;this._add(new on({...t,path:[...this.ctx.path,...t.path]},this.ctx))}}affectsPath(e){if(this.length===0)return false;return e.stringifyAncestors().some(e=>e in this.byPath)||e.stringify()in this.byAncestorPath}get summary(){return this.toString()}get issues(){return this}toJSON(){return[...this.map(e=>e.toJSON())]}toString(){return this.join(`
`)}_add(e){const t=this.byPath[e.propString];if(t){if(t.hasCode(`union`)&&t.errors.length===0)return;const n=e.hasCode(`union`)&&e.errors.length===0?e:new on({code:`intersection`,errors:t.hasCode(`intersection`)?[...t.errors,e]:[t,e]},this.ctx);const r=this.indexOf(t);this.mutable[r===-1?this.length:r]=n;this.byPath[e.propString]=n;this.addAncestorPaths(e)}else{this.byPath[e.propString]=e;this.addAncestorPaths(e);this.mutable.push(e)}this.count++}addAncestorPaths(e){for(const t of e.path.stringifyAncestors())this.byAncestorPath[t]=a(this.byAncestorPath[t],e)}};var cn=class extends Error{name=`TraversalError`;constructor(e){if(e.length===1)super(e.summary);else super(`
`+e.map(e=>`  • ${ln(e)}`).join(`
`));Object.defineProperty(this,`arkErrors`,{value:e,enumerable:false})}};const ln=e=>e.toString().split(`
`).join(`
  `);var un=class{path=[];errors=new sn(this);root;config;queuedMorphs=[];branches=[];seen={};constructor(e,t){this.root=e;this.config=t}get data(){let e=this.root;for(const t of this.path)e=e?.[t];return e}get propString(){return St(this.path)}reject(e){this.error(e);return false}mustBe(e){this.error(e);return false}error(e){const t=typeof e===`object`?e.code?e:{...e,code:`predicate`}:{code:`predicate`,expected:e};return this.errorFromContext(t)}hasError(){return this.currentErrorCount!==0}get currentBranch(){return this.branches.at(-1)}queueMorphs(e){const t={path:new Ct(...this.path),morphs:e};if(this.currentBranch)this.currentBranch.queuedMorphs.push(t);else this.queuedMorphs.push(t)}finalize(e){if(this.queuedMorphs.length){if(typeof this.root===`object`&&this.root!==null&&this.config.clone)this.root=this.config.clone(this.root);this.applyQueuedMorphs()}if(this.hasError())return e?e(this.errors):this.errors;return this.root}get currentErrorCount(){return this.currentBranch?this.currentBranch.error?1:0:this.errors.count}get failFast(){return this.branches.length!==0}pushBranch(){this.branches.push({error:void 0,queuedMorphs:[]})}popBranch(){return this.branches.pop()}get external(){return this}errorFromNodeContext(e){return this.errorFromContext(e)}errorFromContext(e){const t=new on(e,this);if(this.currentBranch)this.currentBranch.error=t;else this.errors.add(t);return t}applyQueuedMorphs(){while(this.queuedMorphs.length){const e=this.queuedMorphs;this.queuedMorphs=[];for(const{path:t,morphs:n}of e){if(this.errors.affectsPath(t))continue;this.applyMorphsAtPath(t,n)}}}applyMorphsAtPath(e,t){const n=e.at(-1);let r;if(n!==void 0){r=this.root;for(let t=0;t<e.length-1;t++)r=r[e[t]]}this.path=[...e];for(const e of t){const t=D(e);const i=e(r===void 0?this.root:r[n],this);if(i instanceof on){this.errors.add(i);break}if(i instanceof sn){if(!t)this.errors.merge(i);break}if(r===void 0)this.root=i;else r[n]=i;this.applyQueuedMorphs()}}};const j=(e,t,n)=>{if(!n)return t();n.path.push(e);const r=t();n.path.pop();return r};var dn=class extends Fe{attachments;$;onFail;includesTransform;includesContextualPredicate;isCyclic;allowsRequiresContext;rootApplyStrategy;contextFreeMorph;rootApply;referencesById;shallowReferences;flatRefs;flatMorphs;allows;get shallowMorphs(){return[]}constructor(e,t){super((e,t,n=this.onFail)=>{if(t){this.traverseApply(e,t);return t.hasError()?t.errors:t.data}return this.rootApply(e,n)},{attach:e});this.attachments=e;this.$=t;this.onFail=this.meta.onFail??this.$.resolvedConfig.onFail;this.includesTransform=this.hasKind(`morph`)||this.hasKind(`structure`)&&this.structuralMorph!==void 0;this.includesContextualPredicate=this.hasKind(`predicate`)&&this.inner.predicate.length!==1;this.isCyclic=this.kind===`alias`;this.referencesById={[this.id]:this};this.shallowReferences=this.hasKind(`structure`)?[this,...this.children]:this.children.reduce((e,t)=>yn(e,t.shallowReferences),[this]);const n=this.isStructural();this.flatRefs=[];this.flatMorphs=[];for(let e=0;e<this.children.length;e++){this.includesTransform||=this.children[e].includesTransform;this.includesContextualPredicate||=this.children[e].includesContextualPredicate;this.isCyclic||=this.children[e].isCyclic;if(!n){const t=this.children[e].flatRefs;for(let e=0;e<t.length;e++){const n=t[e];if(!this.flatRefs.some(e=>_n(e,n))){this.flatRefs.push(n);for(const e of n.node.branches)if(e.hasKind(`morph`)||e.hasKind(`intersection`)&&e.structure?.structuralMorph!==void 0)this.flatMorphs.push({path:n.path,propString:n.propString,node:e})}}}Object.assign(this.referencesById,this.children[e].referencesById)}this.flatRefs.sort((e,t)=>e.path.length>t.path.length?1:e.path.length<t.path.length?-1:e.propString>t.propString?1:e.propString<t.propString?-1:e.node.expression<t.node.expression?-1:1);this.allowsRequiresContext=this.includesContextualPredicate||this.isCyclic;this.rootApplyStrategy=!this.allowsRequiresContext&&this.flatMorphs.length===0?this.shallowMorphs.length===0?`allows`:this.shallowMorphs.every(e=>e.length===1||e.name===`$arkStructuralMorph`)?this.hasKind(`union`)?this.branches.some(e=>e.shallowMorphs.length>1)?`contextual`:`branchedOptimistic`:this.shallowMorphs.length>1?`contextual`:`optimistic`:`contextual`:`contextual`;this.rootApply=this.createRootApply();this.allows=this.allowsRequiresContext?e=>this.traverseAllows(e,new un(e,this.$.resolvedConfig)):e=>this.traverseAllows(e)}createRootApply(){switch(this.rootApplyStrategy){case`allows`:return(e,t)=>{if(this.allows(e))return e;const n=new un(e,this.$.resolvedConfig);this.traverseApply(e,n);return n.finalize(t)};case`contextual`:return(e,t)=>{const n=new un(e,this.$.resolvedConfig);this.traverseApply(e,n);return n.finalize(t)};case`optimistic`:this.contextFreeMorph=this.shallowMorphs[0];const e=this.$.resolvedConfig.clone;return(t,n)=>{if(this.allows(t))return this.contextFreeMorph(e&&(typeof t===`object`&&t!==null||typeof t===`function`)?e(t):t);const r=new un(t,this.$.resolvedConfig);this.traverseApply(t,r);return r.finalize(n)};case`branchedOptimistic`:return this.createBranchedOptimisticRootApply();default:this.rootApplyStrategy;return m(`Unexpected rootApplyStrategy ${this.rootApplyStrategy}`)}}compiledMeta=gn(this.metaJson);cacheGetter(e,t){Object.defineProperty(this,e,{value:t});return t}get description(){return this.cacheGetter(`description`,this.meta?.description??this.$.resolvedConfig[this.kind].description(this))}get references(){return Object.values(this.referencesById)}precedence=Jt(this.kind);precompilation;assert=(e,t)=>this(e,t,e=>e.throw());traverse(e,t){return this(e,t,null)}get in(){return this.cacheGetter(`in`,this.getIo(`in`))}get out(){return this.cacheGetter(`out`,this.getIo(`out`))}getIo(e){if(!this.includesTransform)return this;const t={};for(const[n,r]of this.innerEntries){const i=this.impl.keys[n];if(i.reduceIo)i.reduceIo(e,t,r);else if(i.child){const i=r;t[n]=y(i)?i.map(t=>t[e]):i[e]}else t[n]=r}return this.$.node(this.kind,t)}toJSON(){return this.json}toString(){return`Type<${this.expression}>`}equals(e){const t=D(e)?e:this.$.parseDefinition(e);return this.innerHash===t.innerHash}ifEquals(e){return this.equals(e)?this:void 0}hasKind(e){return this.kind===e}assertHasKind(e){if(this.kind!==e)ne(`${this.kind} node was not of asserted kind ${e}`);return this}hasKindIn(...e){return e.includes(this.kind)}assertHasKindIn(...e){if(!r(e,this.kind))ne(`${this.kind} node was not one of asserted kinds ${e}`);return this}isBasis(){return r(Rt,this.kind)}isConstraint(){return r(Vt,this.kind)}isStructural(){return r(zt,this.kind)}isRefinement(){return r(Bt,this.kind)}isRoot(){return r(Ht,this.kind)}isUnknown(){return this.hasKind(`intersection`)&&this.children.length===0}isNever(){return this.hasKind(`union`)&&this.children.length===0}hasUnit(e){return this.hasKind(`unit`)&&this.allows(e)}hasOpenIntersection(){return this.impl.intersectionIsOpen}get nestableExpression(){return this.expression}select(e){const t=fn.normalize(e);return this._select(t)}_select(e){let t=fn.applyBoundary[e.boundary??`references`](this);if(e.kind)t=t.filter(t=>t.kind===e.kind);if(e.where)t=t.filter(e.where);return fn.applyMethod[e.method??`filter`](t,this,e)}transform(e,t){return this._transform(e,this._createTransformContext(t))}_createTransformContext(e){return{root:this,selected:void 0,seen:{},path:[],parseOptions:{prereduced:e?.prereduced??false},undeclaredKeyHandling:void 0,...e}}_transform(e,t){const n=t.bindScope??this.$;if(t.seen[this.id])return this.$.lazilyResolve(t.seen[this.id]);if(t.shouldTransform?.(this,t)===false)return this;let r;t.seen[this.id]=()=>r;if(this.hasKind(`structure`)&&this.undeclared!==t.undeclaredKeyHandling)t={...t,undeclaredKeyHandling:this.undeclared};const i=_(this.inner,(n,r)=>{if(!this.impl.keys[n].child)return[n,r];const i=r;if(!y(i)){const r=i._transform(e,t);return r?[n,r]:[]}if(i.length===0)return[n,r];const a=i.flatMap(n=>{const r=n._transform(e,t);return r??[]});return a.length?[n,a]:[]});delete t.seen[this.id];const a=Object.assign(i,{meta:this.meta});const o=t.selected&&!t.selected.includes(this)?a:e(this.kind,a,t);if(o===null)return null;if(D(o))return r=o;const s=Object.keys(o);const c=s.length===0||s.length===1&&s[0]===`meta`;if(c&&!fe(this.inner))return null;if((this.kind===`required`||this.kind===`optional`||this.kind===`index`)&&!(`value`in o))return t.undeclaredKeyHandling?{...o,value:C.intrinsic.unknown}:null;if(this.kind===`morph`)o.in??=C.intrinsic.unknown;return r=n.node(this.kind,o,t.parseOptions)}configureReferences(t,n=`references`){const r=fn.normalize(n);const i=typeof t===`string`?(e,n)=>({...n,meta:{...n.meta,description:t}}):typeof t===`function`?(e,n)=>({...n,meta:t(n.meta)}):(e,n)=>({...n,meta:{...n.meta,...t}});if(r.boundary===`self`)return this.$.node(this.kind,i(this.kind,{...this.inner,meta:this.meta}));const a=this._select(r);const o=a&&e(a);const s=r.boundary===`child`?(e,t)=>t.root.children.includes(e):r.boundary===`shallow`?e=>e.kind!==`structure`:()=>true;return this.$.finalize(this.transform(i,{shouldTransform:s,selected:o}))}};const fn={applyBoundary:{self:e=>[e],child:e=>[...e.children],shallow:e=>[...e.shallowReferences],references:e=>[...e.references]},applyMethod:{filter:e=>e,assertFilter:(e,t,n)=>{if(e.length===0)ne(pn(t,n));return e},find:e=>e[0],assertFind:(e,t,n)=>{if(e.length===0)ne(pn(t,n));return e[0]}},normalize:e=>typeof e===`function`?{boundary:`references`,method:`filter`,where:e}:typeof e===`string`?ae(e,fn.applyBoundary)?{method:`filter`,boundary:e}:{boundary:`references`,method:`filter`,kind:e}:{boundary:`references`,method:`filter`,...e}};const pn=(e,t)=>`${e} had no references matching ${x(t)}.`;const mn=e=>St(e,{stringifyNonKey:e=>e.expression});const hn=/"(\$ark\.[^"]+)"/g;const gn=e=>JSON.stringify(e).replaceAll(hn,`$1`);const M=(e,t)=>({path:e,node:t,propString:mn(e)});const _n=(e,t)=>e.propString===t.propString&&e.node.equals(t.node);const vn=(e,t)=>c(e,t,{isEqual:_n});const yn=(e,t)=>c(e,t,{isEqual:(e,t)=>e.equals(t)});var N=class e extends Array{static init(t,n,r,i){return new e({kind:t,l:n,r,path:i?.path??[],optional:i?.optional??false})}add(e,t,n,r){this.push({kind:e,l:t,r:n,path:r?.path??[],optional:r?.optional??false});return this}get summary(){return this.describeReasons()}describeReasons(){if(this.length===1){const{path:e,l:t,r:n}=this[0];const r=St(e);return Sn(`Intersection${r&&` at ${r}`} of ${bn(t,n)}`)}return`The following intersections result in unsatisfiable types:\n• ${this.map(({path:e,l:t,r:n})=>`${e}: ${bn(t,n)}`).join(`
• `)}`}throw(){return h(this.describeReasons())}invert(){const t=this.map(e=>({...e,l:e.r,r:e.l}));if(!(t instanceof e))return new e(...t);return t}withPrefixKey(e,t){return this.map(n=>({...n,path:[e,...n.path],optional:n.optional||t===`optional`}))}toNeverIfDisjoint(){return C.intrinsic.never}};const bn=(e,t)=>`${xn(e)} and ${xn(t)}`;const xn=e=>D(e)?e.expression:y(e)?e.map(xn).join(` | `)||`never`:String(e);const Sn=e=>`${e} results in an unsatisfiable type`;const Cn={};const P=(e,t,n)=>F(e,t,{$:n,invert:false,pipe:false});const wn=(e,t,n)=>F(e,t,{$:n,invert:false,pipe:true});const F=((e,t,n)=>{const r=n.pipe?`|>`:`&`;const i=`${e.hash}${r}${t.hash}`;if(Cn[i]!==void 0)return Cn[i];if(!n.pipe){const n=`${t.hash}${r}${e.hash}`;if(Cn[n]!==void 0){const e=Cn[n];const t=e instanceof N?e.invert():e;Cn[i]=t;return t}}const a=!n.pipe||!e.includesTransform&&!t.includesTransform;if(a&&e.equals(t))return e;let o=a?Tn(e,t,n):e.hasKindIn(...Ht)?En(e,t,n):Tn(e,t,n);if(D(o)){if(e.equals(o))o=e;else if(t.equals(o))o=t}Cn[i]=o;return o});const Tn=(e,t,n)=>{const r=e.precedence<t.precedence?e.kind:t.kind;const i=e.impl.intersections[t.kind]??t.impl.intersections[e.kind];if(i===void 0)return null;else if(r===e.kind)return i(e,t,n);else{let r=i(t,e,{...n,invert:!n.invert});if(r instanceof N)r=r.invert();return r}};const En=(e,t,n)=>e.includesTransform||t.includesTransform?n.invert?Dn(t,e,n):Dn(e,t,n):Tn(e,t,n);const Dn=(e,t,n)=>e.distribute(e=>On(e,t,n),r=>{const i=r.filter(D);if(i.length===0)return N.init(`union`,e.branches,t.branches);if(i.length<e.branches.length||!e.branches.every((e,t)=>e.in.equals(i[t].in)))return n.$.parseSchema(i);let a;if(i.length===1){const e=i[0];if(!a)return e;return n.$.node(`morph`,{...e.inner,in:e.in.configure(a,`self`)})}const o={branches:i};if(a)o.meta=a;return n.$.parseSchema(o)});const On=(e,t,n)=>{const r=e.hasKind(`morph`);if(r){const r=[...e.morphs];if(e.lastMorphIfNode){const i=F(e.lastMorphIfNode,t,n);if(i instanceof N)return i;r[r.length-1]=i}else r.push(t);return n.$.node(`morph`,{morphs:r,in:e.inner.in})}if(t.hasKind(`morph`)){const r=F(e,t.in,n);if(r instanceof N)return r;return n.$.node(`morph`,{morphs:[t],in:r})}return n.$.node(`morph`,{morphs:[t],in:e})};var kn=class extends dn{constructor(e,t){super(e,t);Object.defineProperty(this,T,{value:`constraint`,enumerable:false})}impliedSiblings;intersect(e){return P(this,e,this.$)}};var An=class extends kn{traverseApply=(e,t)=>{if(!this.traverseAllows(e,t))t.errorFromNodeContext(this.errorContext)};compile(e){if(e.traversalKind===`Allows`)e.return(this.compiledCondition);else e.if(this.compiledNegation,()=>e.line(`${e.ctx}.errorFromNodeContext(${this.compiledErrorContext})`))}get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return Qt(this.errorContext)}};const I=e=>(t,n)=>{if(y(t)){if(t.length===0)return;const r=t.map(t=>n.$.node(e,t));if(e===`predicate`)return r;return r.sort((e,t)=>e.hash<t.hash?-1:1)}const r=n.$.node(e,t);return r.hasOpenIntersection()?[r]:r};const jn=e=>{const t=e.r.shift();if(!t){let t=e.l.length===0&&e.kind===`structure`?C.intrinsic.unknown.internal:e.ctx.$.node(e.kind,Object.assign(e.baseInner,Nn(e.l)),{prereduced:true});for(const n of e.roots){if(t instanceof N)return t;t=F(n,t,e.ctx)}return t}let n=false;for(let r=0;r<e.l.length;r++){const i=F(e.l[r],t,e.ctx);if(i===null)continue;if(i instanceof N)return i;if(!n){if(i.isRoot()){e.roots.push(i);e.l.splice(r);return jn(e)}e.l[r]=i;n=true}else if(!e.l.includes(i))return m(`Unexpectedly encountered multiple distinct intersection results for refinement ${i}`)}if(!n)e.l.push(t);if(e.kind===`intersection`){if(t.impliedSiblings)for(const n of t.impliedSiblings)c(e.r,n)}return jn(e)};const Mn=e=>{const t=Object.entries(e).flatMap(([e,t])=>e in Wt?t:[]).sort((e,t)=>e.precedence<t.precedence?-1:e.precedence>t.precedence?1:e.kind===`predicate`&&t.kind===`predicate`?0:e.hash<t.hash?-1:1);return t};const Nn=e=>{const t={};for(const n of e)if(n.hasOpenIntersection())t[n.kind]=a(t[n.kind],n);else{if(t[n.kind])return m(`Unexpected intersection of closed refinements of kind ${n.kind}`);t[n.kind]=n}return t};const Pn=(...e)=>h(Fn(...e));const Fn=(e,t,n)=>{const r=n.hasKind(`morph`)?`a morph`:n.isUnknown()?`unknown`:n.exclude(t).defaultShortDescription;return`${Ue(e)} operand must be ${t.description} (was ${r})`};const In=(e,t,n)=>new Rn(e,t,n,n,null);var Ln=class extends Fe{};var Rn=class extends Fe{[T]=`generic`;paramDefs;bodyDef;$;arg$;baseInstantiation;hkt;description;constructor(e,t,n,r,i){super((...e)=>{const n=_(this.names,(t,n)=>{const r=this.arg$.parse(e[t]);if(!r.extends(this.constraints[t]))h(zn(n,this.constraints[t].expression,r.expression));return[n,r]});if(this.defIsLazy()){const e=this.bodyDef(n);return this.$.parse(e)}return this.$.parse(t,{args:n})});this.paramDefs=e;this.bodyDef=t;this.$=n;this.arg$=r;this.hkt=i;this.description=i?new i().description??`a generic type for ${i.constructor.name}`:`a generic type`;this.baseInstantiation=this(...this.constraints)}defIsLazy(){return this.bodyDef instanceof Ln}cacheGetter(e,t){Object.defineProperty(this,e,{value:t});return t}get json(){return this.cacheGetter(`json`,{params:this.params.map(e=>e[1].isUnknown()?e[0]:[e[0],e[1].json]),body:mt(this.bodyDef)})}get params(){return this.cacheGetter(`params`,this.paramDefs.map(e=>typeof e===`string`?[e,C.intrinsic.unknown]:[e[0],this.$.parse(e[1])]))}get names(){return this.cacheGetter(`names`,this.params.map(e=>e[0]))}get constraints(){return this.cacheGetter(`constraints`,this.params.map(e=>e[1]))}get internal(){return this}get referencesById(){return this.baseInstantiation.internal.referencesById}get references(){return this.baseInstantiation.internal.references}};const zn=(e,t,n)=>`${e} must be assignable to ${t} (was ${n})`;const Bn=k({kind:`predicate`,hasAssociatedError:true,collapsibleKey:`predicate`,keys:{predicate:{}},normalize:e=>typeof e===`function`?{predicate:e}:e,defaults:{description:e=>`valid according to ${e.predicate.name||`an anonymous predicate`}`},intersectionIsOpen:true,intersections:{predicate:()=>null}});var Vn=class extends kn{serializedPredicate=w(this.predicate);compiledCondition=`${this.serializedPredicate}(data, ctx)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=null;expression=this.serializedPredicate;traverseAllows=this.predicate;errorContext={code:`predicate`,description:this.description,meta:this.meta};compiledErrorContext=Qt(this.errorContext);traverseApply=(e,t)=>{if(!this.predicate(e,t.external)&&!t.hasError())t.errorFromNodeContext(this.errorContext)};compile(e){if(e.traversalKind===`Allows`){e.return(this.compiledCondition);return}e.if(`${this.compiledNegation} && !ctx.hasError()`,()=>e.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`))}reduceJsonSchema(e,t){return t.fallback.predicate({code:`predicate`,base:e,predicate:this.predicate})}};const Hn={implementation:Bn,Node:Vn};const Un=k({kind:`divisor`,collapsibleKey:`rule`,keys:{rule:{parse:e=>Number.isInteger(e)?e:h(Kn(e))}},normalize:e=>typeof e===`number`?{rule:e}:e,hasAssociatedError:true,defaults:{description:e=>e.rule===1?`an integer`:e.rule===2?`even`:`a multiple of ${e.rule}`},intersections:{divisor:(e,t,n)=>n.$.node(`divisor`,{rule:Math.abs(e.rule*t.rule/qn(e.rule,t.rule))})},obviatesBasisDescription:true});var Wn=class extends An{traverseAllows=e=>e%this.rule===0;compiledCondition=`data % ${this.rule} === 0`;compiledNegation=`data % ${this.rule} !== 0`;impliedBasis=C.intrinsic.number.internal;expression=`% ${this.rule}`;reduceJsonSchema(e){e.type=`integer`;if(this.rule===1)return e;e.multipleOf=this.rule;return e}};const Gn={implementation:Un,Node:Wn};const Kn=e=>`divisor must be an integer (was ${e})`;const qn=(e,t)=>{let n;let r=e;let i=t;while(i!==0){n=i;i=r%i;r=n}return r};var Jn=class extends An{boundOperandKind=rr[this.kind];compiledActual=this.boundOperandKind===`value`?`data`:this.boundOperandKind===`length`?`data.length`:`data.valueOf()`;comparator=ir(this.kind,this.exclusive);numericLimit=this.rule.valueOf();expression=`${this.comparator} ${this.rule}`;compiledCondition=`${this.compiledActual} ${this.comparator} ${this.numericLimit}`;compiledNegation=`${this.compiledActual} ${Yn[this.comparator]} ${this.numericLimit}`;stringLimit=this.boundOperandKind===`date`?ar(this.numericLimit):`${this.numericLimit}`;limitKind=this.comparator[`0`]===`<`?`upper`:`lower`;isStricterThan(e){const t=this.limitKind===`upper`?this.numericLimit<e.numericLimit:this.numericLimit>e.numericLimit;return t||this.numericLimit===e.numericLimit&&this.exclusive===true&&!e.exclusive}overlapsRange(e){if(this.isStricterThan(e))return false;if(this.numericLimit===e.numericLimit&&(this.exclusive||e.exclusive))return false;return true}overlapIsUnit(e){return this.numericLimit===e.numericLimit&&!this.exclusive&&!e.exclusive}};const Yn={"<":`>=`,"<=":`>`,">":`<=`,">=":`<`};const Xn={min:`max`,minLength:`maxLength`,after:`before`};const Zn={parse:e=>e||void 0};const Qn=e=>t=>{if(typeof t===`number`)return{rule:t};const{exclusive:n,...r}=t;return n?{...r,rule:e===`minLength`?r.rule+1:r.rule-1}:r};const $n=e=>t=>{if(typeof t===`number`||typeof t===`string`||t instanceof Date)return{rule:t};const{exclusive:n,...r}=t;if(!n)return r;const i=typeof r.rule===`number`?r.rule:typeof r.rule===`string`?new Date(r.rule).valueOf():r.rule.valueOf();return n?{...r,rule:e===`after`?i+1:i-1}:r};const er=e=>typeof e===`string`||typeof e===`number`?new Date(e):e;const tr=(e,t)=>`${e} bound must be a positive integer (was ${t})`;const nr=e=>t=>{if(!Number.isInteger(t)||t<0)h(tr(e,t));return t};const rr={min:`value`,max:`value`,minLength:`length`,maxLength:`length`,after:`date`,before:`date`};const ir=(e,t)=>`${ae(e,Xn)?`>`:`<`}${t?``:`=`}`;const ar=e=>typeof e===`string`?e:new Date(e).toLocaleString();const or=e=>`Bounded expression ${e} must be exactly one of number, string, Array, or Date`;const sr=k({kind:`after`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{parse:er,serialize:e=>e.toISOString()}},normalize:$n(`after`),defaults:{description:e=>`${e.collapsibleLimitString} or later`,actual:_t},intersections:{after:(e,t)=>e.isStricterThan(t)?e:t}});var cr=class extends Jn{impliedBasis=C.intrinsic.Date.internal;collapsibleLimitString=_t(this.rule);traverseAllows=e=>e>=this.rule;reduceJsonSchema(e,t){return t.fallback.date({code:`date`,base:e,after:this.rule})}};const lr={implementation:sr,Node:cr};const ur=k({kind:`before`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{parse:er,serialize:e=>e.toISOString()}},normalize:$n(`before`),defaults:{description:e=>`${e.collapsibleLimitString} or earlier`,actual:_t},intersections:{before:(e,t)=>e.isStricterThan(t)?e:t,after:(e,t,n)=>e.overlapsRange(t)?e.overlapIsUnit(t)?n.$.node(`unit`,{unit:e.rule}):null:N.init(`range`,e,t)}});var dr=class extends Jn{collapsibleLimitString=_t(this.rule);traverseAllows=e=>e<=this.rule;impliedBasis=C.intrinsic.Date.internal;reduceJsonSchema(e,t){return t.fallback.date({code:`date`,base:e,before:this.rule})}};const fr={implementation:ur,Node:dr};const pr=k({kind:`exactLength`,collapsibleKey:`rule`,keys:{rule:{parse:nr(`exactLength`)}},normalize:e=>typeof e===`number`?{rule:e}:e,hasAssociatedError:true,defaults:{description:e=>`exactly length ${e.rule}`,actual:e=>`${e.length}`},intersections:{exactLength:(e,t,n)=>N.init(`unit`,n.$.node(`unit`,{unit:e.rule}),n.$.node(`unit`,{unit:t.rule}),{path:[`length`]}),minLength:(e,t)=>e.rule>=t.rule?e:N.init(`range`,e,t),maxLength:(e,t)=>e.rule<=t.rule?e:N.init(`range`,e,t)}});var mr=class extends An{traverseAllows=e=>e.length===this.rule;compiledCondition=`data.length === ${this.rule}`;compiledNegation=`data.length !== ${this.rule}`;impliedBasis=C.intrinsic.lengthBoundable.internal;expression=`== ${this.rule}`;reduceJsonSchema(e){switch(e.type){case`string`:e.minLength=this.rule;e.maxLength=this.rule;return e;case`array`:e.minItems=this.rule;e.maxItems=this.rule;return e;default:return A.throwInternalOperandError(`exactLength`,e)}}};const hr={implementation:pr,Node:mr};const gr=k({kind:`max`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{},exclusive:Zn},normalize:e=>typeof e===`number`?{rule:e}:e,defaults:{description:e=>{if(e.rule===0)return e.exclusive?`negative`:`non-positive`;return`${e.exclusive?`less than`:`at most`} ${e.rule}`}},intersections:{max:(e,t)=>e.isStricterThan(t)?e:t,min:(e,t,n)=>e.overlapsRange(t)?e.overlapIsUnit(t)?n.$.node(`unit`,{unit:e.rule}):null:N.init(`range`,e,t)},obviatesBasisDescription:true});var _r=class extends Jn{impliedBasis=C.intrinsic.number.internal;traverseAllows=this.exclusive?e=>e<this.rule:e=>e<=this.rule;reduceJsonSchema(e){if(this.exclusive)e.exclusiveMaximum=this.rule;else e.maximum=this.rule;return e}};const vr={implementation:gr,Node:_r};const yr=k({kind:`maxLength`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{parse:nr(`maxLength`)}},reduce:(e,t)=>e.rule===0?t.node(`exactLength`,e):void 0,normalize:Qn(`maxLength`),defaults:{description:e=>`at most length ${e.rule}`,actual:e=>`${e.length}`},intersections:{maxLength:(e,t)=>e.isStricterThan(t)?e:t,minLength:(e,t,n)=>e.overlapsRange(t)?e.overlapIsUnit(t)?n.$.node(`exactLength`,{rule:e.rule}):null:N.init(`range`,e,t)}});var br=class extends Jn{impliedBasis=C.intrinsic.lengthBoundable.internal;traverseAllows=e=>e.length<=this.rule;reduceJsonSchema(e){switch(e.type){case`string`:e.maxLength=this.rule;return e;case`array`:e.maxItems=this.rule;return e;default:return A.throwInternalOperandError(`maxLength`,e)}}};const xr={implementation:yr,Node:br};const Sr=k({kind:`min`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{},exclusive:Zn},normalize:e=>typeof e===`number`?{rule:e}:e,defaults:{description:e=>{if(e.rule===0)return e.exclusive?`positive`:`non-negative`;return`${e.exclusive?`more than`:`at least`} ${e.rule}`}},intersections:{min:(e,t)=>e.isStricterThan(t)?e:t},obviatesBasisDescription:true});var Cr=class extends Jn{impliedBasis=C.intrinsic.number.internal;traverseAllows=this.exclusive?e=>e>this.rule:e=>e>=this.rule;reduceJsonSchema(e){if(this.exclusive)e.exclusiveMinimum=this.rule;else e.minimum=this.rule;return e}};const wr={implementation:Sr,Node:Cr};const Tr=k({kind:`minLength`,collapsibleKey:`rule`,hasAssociatedError:true,keys:{rule:{parse:nr(`minLength`)}},reduce:e=>e.rule===0?C.intrinsic.unknown:void 0,normalize:Qn(`minLength`),defaults:{description:e=>e.rule===1?`non-empty`:`at least length ${e.rule}`,actual:e=>e.length===0?``:`${e.length}`},intersections:{minLength:(e,t)=>e.isStricterThan(t)?e:t}});var Er=class extends Jn{impliedBasis=C.intrinsic.lengthBoundable.internal;traverseAllows=e=>e.length>=this.rule;reduceJsonSchema(e){switch(e.type){case`string`:e.minLength=this.rule;return e;case`array`:e.minItems=this.rule;return e;default:return A.throwInternalOperandError(`minLength`,e)}}};const Dr={implementation:Tr,Node:Er};const Or={min:wr.implementation,max:vr.implementation,minLength:Dr.implementation,maxLength:xr.implementation,exactLength:hr.implementation,after:lr.implementation,before:fr.implementation};const kr={min:wr.Node,max:vr.Node,minLength:Dr.Node,maxLength:xr.Node,exactLength:hr.Node,after:lr.Node,before:fr.Node};const Ar=k({kind:`pattern`,collapsibleKey:`rule`,keys:{rule:{},flags:{}},normalize:e=>typeof e===`string`?{rule:e}:e instanceof RegExp?e.flags?{rule:e.source,flags:e.flags}:{rule:e.source}:e,obviatesBasisDescription:true,obviatesBasisExpression:true,hasAssociatedError:true,intersectionIsOpen:true,defaults:{description:e=>`matched by ${e.rule}`},intersections:{pattern:()=>null}});var jr=class extends An{instance=new RegExp(this.rule,this.flags);expression=`${this.instance}`;traverseAllows=this.instance.test.bind(this.instance);compiledCondition=`${this.expression}.test(data)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=C.intrinsic.string.internal;reduceJsonSchema(e,t){if(e.pattern)return t.fallback.patternIntersection({code:`patternIntersection`,base:e,pattern:this.rule});e.pattern=this.rule;return e}};const Mr={implementation:Ar,Node:jr};const Nr=(e,t)=>{const n=Pr(e);if(t&&!t.includes(n))return h(`Root of kind ${n} should be one of ${t}`);return n};const Pr=e=>{if(E(e,`root`))return e.kind;if(typeof e===`string`)return e[0]===`$`?`alias`:e in p?`domain`:`proto`;if(typeof e===`function`)return`proto`;if(typeof e!==`object`||e===null)return h(Fr(e));if(`morphs`in e)return`morph`;if(`branches`in e||y(e))return`union`;if(`unit`in e)return`unit`;if(`reference`in e)return`alias`;const t=Object.keys(e);if(t.length===0||t.some(e=>e in Wt))return`intersection`;if(`proto`in e)return`proto`;if(`domain`in e)return`domain`;return h(Fr(e))};const Fr=e=>`${x(e)} is not a valid type schema`;const Ir={};const Lr=e=>y(e)?e.map(e=>e.collapsibleJson):e.collapsibleJson;const L={};C.nodesByRegisteredId=L;const Rr=e=>{Ir[e]??=0;return`${e}${++Ir[e]}`};const zr=e=>{const t=Pa[e.kind];const n=t.applyConfig?.(e.def,e.$.resolvedConfig)??e.def;const r={};const{meta:i,...a}=n;const o=i===void 0?{}:typeof i===`string`?{description:i}:i;const s=ie(a).sort(([e],[t])=>qt(e)?qt(t)?Jt(e)-Jt(t):1:qt(t)?-1:e<t?-1:1).filter(([e,t])=>{if(e.startsWith(`meta.`)){const n=e.slice(5);o[n]=t;return false}return true});for(const n of s){const i=n[0];const a=t.keys[i];if(!a)return h(`Key ${i} is not valid on ${e.kind} schema`);const o=a.parse?a.parse(n[1],e):n[1];if(o!==v&&(o!==void 0||a.preserveUndefined))r[i]=o}if(t.reduce&&!e.prereduced){const n=t.reduce(r,e.$);if(n){if(n instanceof N)return n.throw();return Hr(n,o)}}const c=Br({id:e.id,kind:e.kind,inner:r,meta:o,$:e.$});return c};const Br=({id:e,kind:t,inner:n,meta:r,$:i,ignoreCache:a})=>{const o=Pa[t];const s=ie(n);const c=[];let l={};for(const[e,t]of s){const n=o.keys[e];const r=n.serialize??(n.child?Lr:O);l[e]=r(t);if(n.child===true){const e=t;if(y(e))c.push(...e);else c.push(e)}else if(typeof n.child===`function`)c.push(...n.child(t))}if(o.finalizeInnerJson)l=o.finalizeInnerJson(l);let u={...l};let d={};if(!fe(r)){d=_(r,(e,t)=>[e,e===`examples`?t:O(t)]);u.meta=Ur(d,`description`,true)}l=Ur(l,o.collapsibleKey,false);const f=JSON.stringify({kind:t,...l});u=Ur(u,o.collapsibleKey,false);const p=Ur(u,o.collapsibleKey,true);const ee=JSON.stringify({kind:t,...u});if(i.nodesByHash[ee]&&!a)return i.nodesByHash[ee];const te={id:e,kind:t,impl:o,inner:n,innerEntries:s,innerJson:l,innerHash:f,meta:r,metaJson:d,json:u,hash:ee,collapsibleJson:p,children:c};if(t!==`intersection`){for(const e in n)if(e!==`in`&&e!==`out`)te[e]=n[e]}const m=new Fa[t](te,i);return i.nodesByHash[ee]=m};const Vr=(e,t)=>{if(e.id===t)return e;if(D(L[t]))m(`Unexpected attempt to overwrite node id ${t}`);return Br({id:t,kind:e.kind,inner:e.inner,meta:e.meta,$:e.$,ignoreCache:true})};const Hr=(e,t,n)=>{if(n&&D(L[n]))m(`Unexpected attempt to overwrite node id ${n}`);return Br({id:n??Rr(t.alias??e.kind),kind:e.kind,inner:e.inner,meta:t,$:e.$})};const Ur=(e,t,n)=>{const r=Object.keys(e);if(r.length===1&&r[0]===t){const r=e[t];if(n)return r;if(d(r,`object`)&&(Object.keys(r).length===1||Array.isArray(r)))return r}return e};const Wr=(e,t,n)=>{if(e.key!==t.key)return null;const r=e.key;let i=F(e.value,t.value,n);const a=e.required||t.required?`required`:`optional`;if(i instanceof N)if(a===`optional`)i=C.intrinsic.never.internal;else return i.withPrefixKey(e.key,e.required&&t.required?`required`:`optional`);if(a===`required`)return n.$.node(`required`,{key:r,value:i});const o=e.hasDefault()?t.hasDefault()?e.default===t.default?e.default:h(Kr(e.default,t.default)):e.default:t.hasDefault()?t.default:v;return n.$.node(`optional`,{key:r,value:i,default:o})};var Gr=class extends kn{required=this.kind===`required`;optional=this.kind===`optional`;impliedBasis=C.intrinsic.object.internal;serializedKey=Mt(this.key);compiledKey=typeof this.key===`string`?this.key:this.serializedKey;flatRefs=a(this.value.flatRefs.map(e=>M([this.key,...e.path],e.node)),M([this.key],this.value));_transform(e,t){t.path.push(this.key);const n=super._transform(e,t);t.path.pop();return n}hasDefault(){return`default`in this.inner}traverseAllows=(e,t)=>{if(this.key in e)return j(this.key,()=>this.value.traverseAllows(e[this.key],t),t);return this.optional};traverseApply=(e,t)=>{if(this.key in e)j(this.key,()=>this.value.traverseApply(e[this.key],t),t);else if(this.hasKind(`required`))t.errorFromNodeContext(this.errorContext)};compile(e){e.if(`${this.serializedKey} in data`,()=>e.traverseKey(this.serializedKey,`data${e.prop(this.key)}`,this.value));if(this.hasKind(`required`))e.else(()=>e.traversalKind===`Apply`?e.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`):e.return(false));if(e.traversalKind===`Allows`)e.return(true)}};const Kr=(e,t)=>`Invalid intersection of default values ${x(e)} & ${x(t)}`;const qr=k({kind:`optional`,hasAssociatedError:false,intersectionIsOpen:true,keys:{key:{},value:{child:true,parse:(e,t)=>t.$.parseSchema(e)},default:{preserveUndefined:true}},normalize:e=>e,reduce:(e,t)=>{if(t.resolvedConfig.exactOptionalPropertyTypes===false){if(!e.value.allows(void 0))return t.node(`optional`,{...e,value:e.value.or(V.undefined)},{prereduced:true})}},defaults:{description:e=>`${e.compiledKey}?: ${e.value.description}`},intersections:{optional:Wr}});var Jr=class extends Gr{constructor(...e){super(...e);if(`default`in this.inner)$r(this.value,this.inner.default,this.key)}get outProp(){if(!this.hasDefault())return this;const{default:e,...t}=this.inner;return this.cacheGetter(`outProp`,this.$.node(`required`,t,{prereduced:true}))}expression=this.hasDefault()?`${this.compiledKey}: ${this.value.expression} = ${x(this.inner.default)}`:`${this.compiledKey}?: ${this.value.expression}`;defaultValueMorph=Zr(this);defaultValueMorphRef=this.defaultValueMorph&&w(this.defaultValueMorph)};const Yr={implementation:qr,Node:Jr};const Xr={};const Zr=e=>{if(!e.hasDefault())return;const t=`{${e.compiledKey}: ${e.value.id} = ${O(e.default)}}`;return Xr[t]??=Qr(e.key,e.value,e.default)};const Qr=(e,t,n)=>{if(typeof n===`function`)return t.includesTransform?(r,i)=>{j(e,()=>t(r[e]=n(),i),i);return r}:t=>{t[e]=n();return t};const r=t.includesTransform?t.assert(n):n;return d(r,`object`)?(r,i)=>{j(e,()=>t(r[e]=n,i),i);return r}:t=>{t[e]=r;return t}};const $r=(e,t,n)=>{const r=Ne(t);if(d(t,`object`)&&!r)h(ei(n));const i=e.in(r?t():t);if(i instanceof sn){if(n===null)h(`Default ${i.summary}`);const e=i.transform(e=>e.transform(e=>({...e,prefixPath:[n]})));h(`Default for ${e.summary}`)}return t};const ei=e=>{const t=e===null?``:typeof e===`number`?`for value at [${e}] `:`for ${Mt(e)} `;return`Non-primitive default ${t}must be specified as a function like () => ({my: 'object'})`};var ti=class extends dn{constructor(e,t){super(e,t);Object.defineProperty(this,T,{value:`root`,enumerable:false})}get internal(){return this}get"~standard"(){return{vendor:`arktype`,version:1,validate:e=>{const t=this(e);if(t instanceof sn)return t;return{value:t}}}}as(){return this}brand(e){if(e===``)return h(ni);return this}readonly(){return this}branches=this.hasKind(`union`)?this.inner.branches:[this];distribute(e,t){const n=this.branches.map(e);return t?.(n)??n}get shortDescription(){return this.meta.description??this.defaultShortDescription}toJsonSchema(e={}){const t=nn(this.$.resolvedConfig.toJsonSchema,e);t.useRefs||=this.isCyclic;const n=typeof t.dialect===`string`?{$schema:t.dialect}:{};Object.assign(n,this.toJsonSchemaRecurse(t));if(t.useRefs)n.$defs=_(this.references,(e,n)=>n.isRoot()&&!n.alwaysExpandJsonSchema?[n.id,n.toResolvedJsonSchema(t)]:[]);return n}toJsonSchemaRecurse(e){if(e.useRefs&&!this.alwaysExpandJsonSchema)return{$ref:`#/$defs/${this.id}`};return this.toResolvedJsonSchema(e)}get alwaysExpandJsonSchema(){return this.isBasis()||this.kind===`alias`||this.hasKind(`union`)&&this.isBoolean}toResolvedJsonSchema(e){const t=this.innerToJsonSchema(e);return Object.assign(t,this.metaJson)}intersect(e){const t=this.$.parseDefinition(e);const n=this.rawIntersect(t);if(n instanceof N)return n;return this.$.finalize(n)}rawIntersect(e){return P(this,e,this.$)}toNeverIfDisjoint(){return this}and(e){const t=this.intersect(e);return t instanceof N?t.throw():t}rawAnd(e){const t=this.rawIntersect(e);return t instanceof N?t.throw():t}or(e){const t=this.$.parseDefinition(e);return this.$.finalize(this.rawOr(t))}rawOr(e){const t=[...this.branches,...e.branches];return this.$.node(`union`,t)}map(e){return this.$.schema(this.applyStructuralOperation(`map`,[e]))}pick(...e){return this.$.schema(this.applyStructuralOperation(`pick`,e))}omit(...e){return this.$.schema(this.applyStructuralOperation(`omit`,e))}required(){return this.$.schema(this.applyStructuralOperation(`required`,[]))}partial(){return this.$.schema(this.applyStructuralOperation(`partial`,[]))}_keyof;keyof(){if(this._keyof)return this._keyof;const e=this.applyStructuralOperation(`keyof`,[]).reduce((e,t)=>e.intersect(t).toNeverIfDisjoint(),C.intrinsic.unknown.internal);if(e.branches.length===0)h(Sn(`keyof ${this.expression}`));return this._keyof=this.$.finalize(e)}get props(){if(this.branches.length!==1)return h(oi(this.expression));return[...this.applyStructuralOperation(`props`,[])[0]]}merge(e){const t=this.$.parseDefinition(e);return this.$.schema(t.distribute(e=>this.applyStructuralOperation(`merge`,[ai(e)??h(si(`merge`,e.expression))])))}applyStructuralOperation(e,t){return this.distribute(n=>{if(n.equals(C.intrinsic.object)&&e!==`merge`)return n;const r=ai(n);if(!r)h(si(e,n.expression));if(e===`keyof`)return r.keyof();if(e===`get`)return r.get(...t);if(e===`props`)return r.props;const i=e===`required`?`require`:e===`partial`?`optionalize`:e;return this.$.node(`intersection`,{...n.inner,structure:r[i](...t)})})}get(...e){if(e[0]===void 0)return this;return this.$.schema(this.applyStructuralOperation(`get`,e))}extract(e){const t=this.$.parseDefinition(e);return this.$.schema(this.branches.filter(e=>e.extends(t)))}exclude(e){const t=this.$.parseDefinition(e);return this.$.schema(this.branches.filter(e=>!e.extends(t)))}array(){return this.$.schema(this.isUnknown()?{proto:Array}:{proto:Array,sequence:this},{prereduced:true})}overlaps(e){const t=this.intersect(e);return!(t instanceof N)}extends(e){const t=this.intersect(e);return!(t instanceof N)&&this.equals(t)}ifExtends(e){return this.extends(e)?this:void 0}subsumes(e){const t=this.$.parseDefinition(e);return t.extends(this)}configure(e,t=`shallow`){return this.configureReferences(e,t)}describe(e,t=`shallow`){return this.configure({description:e},t)}optional(){return[this,`?`]}default(e){$r(this,e,null);return[this,`=`,e]}from(e){return this.assert(e)}_pipe(...e){const t=e.reduce((e,t)=>e.rawPipeOnce(t),this);return this.$.finalize(t)}tryPipe(...e){const t=e.reduce((e,t)=>e.rawPipeOnce(E(t,`root`)?t:((e,n)=>{try{return t(e,n)}catch(e){return n.error({code:`predicate`,predicate:t,actual:`aborted due to error:\n    ${e}\n`})}})),this);return this.$.finalize(t)}pipe=Object.assign(this._pipe.bind(this),{try:this.tryPipe.bind(this)});to(e){return this.$.finalize(this.toNode(this.$.parseDefinition(e)))}toNode(e){const t=wn(this,e,this.$);if(t instanceof N)return t.throw();return t}rawPipeOnce(e){if(E(e,`root`))return this.toNode(e);return this.distribute(t=>t.hasKind(`morph`)?this.$.node(`morph`,{in:t.inner.in,morphs:[...t.morphs,e]}):this.$.node(`morph`,{in:t,morphs:[e]}),this.$.parseSchema)}narrow(e){return this.constrainOut(`predicate`,e)}constrain(e,t){return this._constrain(`root`,e,t)}constrainIn(e,t){return this._constrain(`in`,e,t)}constrainOut(e,t){return this._constrain(`out`,e,t)}_constrain(e,t,n){const r=this.$.node(t,n);if(r.isRoot())return r.isUnknown()?this:m(`Unexpected constraint node ${r}`);const i=e===`root`?this:this[e];if(i.hasKind(`morph`)||r.impliedBasis&&!i.extends(r.impliedBasis))return Pn(t,r.impliedBasis,this);const a=this.$.node(`intersection`,{[r.kind]:r});const o=e===`out`?wn(this,a,this.$):P(this,a,this.$);if(o instanceof N)o.throw();return this.$.finalize(o)}onUndeclaredKey(e){const t=typeof e===`string`?e:e.rule;const n=typeof e===`string`?false:e.deep;return this.$.finalize(this.transform((e,n)=>e===`structure`?t===`ignore`?de(n,{undeclared:1}):{...n,undeclared:t}:n,n?void 0:{shouldTransform:e=>!r(zt,e.kind)}))}hasEqualMorphs(e){if(!this.includesTransform&&!e.includesTransform)return true;if(!u(this.shallowMorphs,e.shallowMorphs))return false;if(!u(this.flatMorphs,e.flatMorphs,{isEqual:(e,t)=>e.propString===t.propString&&(e.node.hasKind(`morph`)&&t.node.hasKind(`morph`)?e.node.hasEqualMorphs(t.node):e.node.hasKind(`intersection`)&&t.node.hasKind(`intersection`)?e.node.structure?.structuralMorphRef===t.node.structure?.structuralMorphRef:false)}))return false;return true}onDeepUndeclaredKey(e){return this.onUndeclaredKey({rule:e,deep:true})}filter(e){return this.constrainIn(`predicate`,e)}divisibleBy(e){return this.constrain(`divisor`,e)}matching(e){return this.constrain(`pattern`,e)}atLeast(e){return this.constrain(`min`,e)}atMost(e){return this.constrain(`max`,e)}moreThan(e){return this.constrain(`min`,ri(e))}lessThan(e){return this.constrain(`max`,ri(e))}atLeastLength(e){return this.constrain(`minLength`,e)}atMostLength(e){return this.constrain(`maxLength`,e)}moreThanLength(e){return this.constrain(`minLength`,ri(e))}lessThanLength(e){return this.constrain(`maxLength`,ri(e))}exactlyLength(e){return this.constrain(`exactLength`,e)}atOrAfter(e){return this.constrain(`after`,e)}atOrBefore(e){return this.constrain(`before`,e)}laterThan(e){return this.constrain(`after`,ri(e))}earlierThan(e){return this.constrain(`before`,ri(e))}};const ni=`Expected a non-empty brand name after #`;const ri=e=>typeof e===`object`&&!(e instanceof Date)?{...e,exclusive:true}:{rule:e,exclusive:true};const ii=(e,t)=>E(t,`root`)?E(e,`root`)?e.extends(t):t.allows(e):E(e,`root`)?e.hasUnit(t):t===e;const ai=e=>{if(e.hasKind(`morph`))return null;if(e.hasKind(`intersection`))return e.inner.structure??(e.basis?.domain===`object`?e.$.bindReference(C.intrinsic.emptyStructure):null);if(e.isBasis()&&e.domain===`object`)return e.$.bindReference(C.intrinsic.emptyStructure);return null};const oi=e=>`Props cannot be extracted from a union. Use .distribute to extract props from each branch instead. Received:
${e}`;const si=(e,t)=>`${e} operand must be an object (was ${t})`;const ci=(e,t)=>_(Yt(e),(e,n)=>[n,t]);const li=e=>typeof e===`string`?{reference:e}:e;const ui=e=>e instanceof N?C.intrinsic.never.internal:e;const di=k({kind:`alias`,hasAssociatedError:false,collapsibleKey:`reference`,keys:{reference:{serialize:e=>e.startsWith(`$`)?e:`$ark.${e}`},resolve:{}},normalize:li,defaults:{description:e=>e.reference},intersections:{alias:(e,t,n)=>n.$.lazilyResolve(()=>ui(F(e.resolution,t.resolution,n)),`${e.reference}${n.pipe?`=>`:`&`}${t.reference}`),...ci(`alias`,(e,t,n)=>{if(t.isUnknown())return e;if(t.isNever())return t;if(t.isBasis()&&!t.overlaps(C.intrinsic.object))return N.init(`assignability`,C.intrinsic.object,t);return n.$.lazilyResolve(()=>ui(F(e.resolution,t,n)),`${e.reference}${n.pipe?`=>`:`&`}${t.id}`)})}});var fi=class extends ti{expression=this.reference;structure=void 0;get resolution(){const e=this._resolve();return L[this.id]=e}_resolve(){if(this.resolve)return this.resolve();if(this.reference[0]===`$`)return this.$.resolveRoot(this.reference.slice(1));const e=this.reference;let t=L[e];const n=[];while(E(t,`context`)){if(n.includes(t.id))return h(pi(t.id,n));n.push(t.id);t=L[t.id]}if(!E(t,`root`))return m(`Unexpected resolution for reference ${this.reference}
Seen: [${n.join(`->`)}] 
Resolution: ${x(t)}`);return t}get resolutionId(){if(this.reference.includes(`&`)||this.reference.includes(`=>`))return this.resolution.id;if(this.reference[0]!==`$`)return this.reference;const e=this.reference.slice(1);const t=this.$.resolutions[e];if(typeof t===`string`)return t;if(E(t,`root`))return t.id;return m(`Unexpected resolution for reference ${this.reference}: ${x(t)}`)}get defaultShortDescription(){return p.object}innerToJsonSchema(e){return this.resolution.toJsonSchemaRecurse(e)}traverseAllows=(e,t)=>{const n=t.seen[this.reference];if(n?.includes(e))return true;t.seen[this.reference]=a(n,e);return this.resolution.traverseAllows(e,t)};traverseApply=(e,t)=>{const n=t.seen[this.reference];if(n?.includes(e))return;t.seen[this.reference]=a(n,e);this.resolution.traverseApply(e,t)};compile(e){const t=this.resolutionId;e.if(`ctx.seen.${t} && ctx.seen.${t}.includes(data)`,()=>e.return(true));e.if(`!ctx.seen.${t}`,()=>e.line(`ctx.seen.${t} = []`));e.line(`ctx.seen.${t}.push(data)`);e.return(e.invoke(t))}};const pi=(e,t)=>`Alias '${e}' has a shallow resolution cycle: ${[...t,e].join(`->`)}`;const mi={implementation:di,Node:fi};var hi=class extends ti{traverseApply=(e,t)=>{if(!this.traverseAllows(e,t))t.errorFromNodeContext(this.errorContext)};get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return Qt(this.errorContext)}compile(e){if(e.traversalKind===`Allows`)e.return(this.compiledCondition);else e.if(this.compiledNegation,()=>e.line(`${e.ctx}.errorFromNodeContext(${this.compiledErrorContext})`))}};const gi=k({kind:`domain`,hasAssociatedError:true,collapsibleKey:`domain`,keys:{domain:{},numberAllowsNaN:{}},normalize:e=>typeof e===`string`?{domain:e}:oe(e,`numberAllowsNaN`)&&e.domain!==`number`?h(vi.writeBadAllowNanMessage(e.domain)):e,applyConfig:(e,t)=>e.numberAllowsNaN===void 0&&e.domain===`number`&&t.numberAllowsNaN?{...e,numberAllowsNaN:true}:e,defaults:{description:e=>p[e.domain],actual:e=>Number.isNaN(e)?`NaN`:p[f(e)]},intersections:{domain:(e,t)=>e.domain===`number`&&t.domain===`number`?e.numberAllowsNaN?t:e:N.init(`domain`,e,t)}});var _i=class extends hi{requiresNaNCheck=this.domain===`number`&&!this.numberAllowsNaN;traverseAllows=this.requiresNaNCheck?e=>typeof e===`number`&&!Number.isNaN(e):e=>f(e)===this.domain;compiledCondition=this.domain===`object`?`((typeof data === "object" && data !== null) || typeof data === "function")`:`typeof data === "${this.domain}"${this.requiresNaNCheck?` && !Number.isNaN(data)`:``}`;compiledNegation=this.domain===`object`?`((typeof data !== "object" || data === null) && typeof data !== "function")`:`typeof data !== "${this.domain}"${this.requiresNaNCheck?` || Number.isNaN(data)`:``}`;expression=this.numberAllowsNaN?`number | NaN`:this.domain;get nestableExpression(){return this.numberAllowsNaN?`(${this.expression})`:this.expression}get defaultShortDescription(){return p[this.domain]}innerToJsonSchema(e){if(this.domain===`bigint`||this.domain===`symbol`)return e.fallback.domain({code:`domain`,base:{},domain:this.domain});return{type:this.domain}}};const vi={implementation:gi,Node:_i,writeBadAllowNanMessage:e=>`numberAllowsNaN may only be specified with domain "number" (was ${e})`};const yi=k({kind:`intersection`,hasAssociatedError:true,normalize:e=>{if(D(e))return e;const{structure:t,...n}=e;const r=!!t;const i=t??{};const a=_(n,(e,t)=>{if(ae(e,Gt)){if(r)h(`Flattened structure key ${e} cannot be specified alongside a root 'structure' key.`);i[e]=t;return[]}return[e,t]});if(E(i,`constraint`)||!fe(i))a.structure=i;return a},finalizeInnerJson:({structure:e,...t})=>d(e,`object`)?{...e,...t}:t,keys:{domain:{child:true,parse:(e,t)=>t.$.node(`domain`,e)},proto:{child:true,parse:(e,t)=>t.$.node(`proto`,e)},structure:{child:true,parse:(e,t)=>t.$.node(`structure`,e),serialize:e=>{if(!e.sequence?.minLength)return e.collapsibleJson;const{sequence:t,...n}=e.collapsibleJson;const{minVariadicLength:r,...i}=t;const a=i.variadic&&Object.keys(i).length===1?i.variadic:i;return{...n,sequence:a}}},divisor:{child:true,parse:I(`divisor`)},max:{child:true,parse:I(`max`)},min:{child:true,parse:I(`min`)},maxLength:{child:true,parse:I(`maxLength`)},minLength:{child:true,parse:I(`minLength`)},exactLength:{child:true,parse:I(`exactLength`)},before:{child:true,parse:I(`before`)},after:{child:true,parse:I(`after`)},pattern:{child:true,parse:I(`pattern`)},predicate:{child:true,parse:I(`predicate`)}},reduce:(e,t)=>Ci({},e,{$:t,invert:false,pipe:false}),defaults:{description:e=>{if(e.children.length===0)return`unknown`;if(e.structure)return e.structure.description;const t=[];if(e.basis&&!e.refinements.some(e=>e.impl.obviatesBasisDescription))t.push(e.basis.description);if(e.refinements.length){const n=e.refinements.toSorted((e,t)=>e.kind===`min`&&t.kind===`max`?-1:0).map(e=>e.description);t.push(...n)}if(e.inner.predicate)t.push(...e.inner.predicate.map(e=>e.description));return t.join(` and `)},expected:e=>`  ◦ ${e.errors.map(e=>e.expected).join(`
  ◦ `)}`,problem:e=>`(${e.actual}) must be...\n${e.expected}`},intersections:{intersection:(e,t,n)=>Ci(e.inner,t.inner,n),...ci(`intersection`,(e,t,n)=>{if(e.children.length===0)return t;const{domain:r,proto:i,...a}=e.inner;const o=i??r;const s=o?F(o,t,n):t;return s instanceof N?s:e?.basis?.equals(s)?e:e.$.node(`intersection`,{...a,[s.kind]:s},{prereduced:true})})}});var bi=class extends ti{basis=this.inner.domain??this.inner.proto??null;refinements=this.children.filter(e=>e.isRefinement());structure=this.inner.structure;expression=Si(this);get shallowMorphs(){return this.inner.structure?.structuralMorph?[this.inner.structure.structuralMorph]:[]}get defaultShortDescription(){return this.basis?.defaultShortDescription??`present`}innerToJsonSchema(e){return this.children.reduce((t,n)=>n.isBasis()?n.toJsonSchemaRecurse(e):n.reduceJsonSchema(t,e),{})}traverseAllows=(e,t)=>this.children.every(n=>n.traverseAllows(e,t));traverseApply=(e,t)=>{const n=t.currentErrorCount;if(this.basis){this.basis.traverseApply(e,t);if(t.currentErrorCount>n)return}if(this.refinements.length){for(let r=0;r<this.refinements.length-1;r++){this.refinements[r].traverseApply(e,t);if(t.failFast&&t.currentErrorCount>n)return}this.refinements.at(-1).traverseApply(e,t);if(t.currentErrorCount>n)return}if(this.structure){this.structure.traverseApply(e,t);if(t.currentErrorCount>n)return}if(this.inner.predicate){for(let r=0;r<this.inner.predicate.length-1;r++){this.inner.predicate[r].traverseApply(e,t);if(t.failFast&&t.currentErrorCount>n)return}this.inner.predicate.at(-1).traverseApply(e,t)}};compile(e){if(e.traversalKind===`Allows`){for(const t of this.children)e.check(t);e.return(true);return}e.initializeErrorCount();if(this.basis){e.check(this.basis);if(this.children.length>1)e.returnIfFail()}if(this.refinements.length){for(let t=0;t<this.refinements.length-1;t++){e.check(this.refinements[t]);e.returnIfFailFast()}e.check(this.refinements.at(-1));if(this.structure||this.inner.predicate)e.returnIfFail()}if(this.structure){e.check(this.structure);if(this.inner.predicate)e.returnIfFail()}if(this.inner.predicate){for(let t=0;t<this.inner.predicate.length-1;t++){e.check(this.inner.predicate[t]);e.returnIfFail()}e.check(this.inner.predicate.at(-1))}}};const xi={implementation:yi,Node:bi};const Si=e=>{let t=e.structure?.expression||`${e.basis&&!e.refinements.some(e=>e.impl.obviatesBasisExpression)?e.basis.nestableExpression+` `:``}${e.refinements.map(e=>e.expression).join(` & `)}`||`unknown`;if(t===`Array == 0`)t=`[]`;return t};const Ci=(e,t,n)=>{const r={};const i=e.proto??e.domain;const a=t.proto??t.domain;const o=i?a?F(i,a,n):i:a;if(o instanceof N)return o;if(o)r[o.kind]=o;return jn({kind:`intersection`,baseInner:r,l:Mn(e),r:Mn(t),roots:[],ctx:n})};const wi=k({kind:`morph`,hasAssociatedError:false,keys:{in:{child:true,parse:(e,t)=>t.$.parseSchema(e)},morphs:{parse:e,serialize:e=>e.map(e=>E(e,`root`)?e.json:w(e))},declaredIn:{child:false,serialize:e=>e.json},declaredOut:{child:false,serialize:e=>e.json}},normalize:e=>e,defaults:{description:e=>`a morph from ${e.in.description} to ${e.out?.description??`unknown`}`},intersections:{morph:(e,t,n)=>{if(!e.hasEqualMorphs(t))return h(Di(e.expression,t.expression));const r=F(e.in,t.in,n);if(r instanceof N)return r;const i={morphs:e.morphs};if(e.declaredIn||t.declaredIn){const r=F(e.in,t.in,n);if(r instanceof N)return r.throw();else i.declaredIn=r}if(e.declaredOut||t.declaredOut){const r=F(e.out,t.out,n);if(r instanceof N)return r.throw();else i.declaredOut=r}return r.distribute(e=>n.$.node(`morph`,{...i,in:e}),n.$.parseSchema)},...ci(`morph`,(e,t,n)=>{const r=e.inner.in?F(e.inner.in,t,n):t;return r instanceof N?r:r.equals(e.inner.in)?e:n.$.node(`morph`,{...e.inner,in:r})})}});var Ti=class extends ti{serializedMorphs=this.morphs.map(w);compiledMorphs=`[${this.serializedMorphs}]`;lastMorph=this.inner.morphs.at(-1);lastMorphIfNode=E(this.lastMorph,`root`)?this.lastMorph:void 0;introspectableIn=this.inner.in;introspectableOut=this.lastMorphIfNode?Object.assign(this.referencesById,this.lastMorphIfNode.referencesById)&&this.lastMorphIfNode.out:void 0;get shallowMorphs(){return Array.isArray(this.inner.in?.shallowMorphs)?[...this.inner.in.shallowMorphs,...this.morphs]:this.morphs}get in(){return this.declaredIn??this.inner.in?.in??C.intrinsic.unknown.internal}get out(){return this.declaredOut??this.introspectableOut??C.intrinsic.unknown.internal}declareIn(e){return this.$.node(`morph`,{...this.inner,declaredIn:e})}declareOut(e){return this.$.node(`morph`,{...this.inner,declaredOut:e})}expression=`(In: ${this.in.expression}) => ${this.lastMorphIfNode?`To`:`Out`}<${this.out.expression}>`;get defaultShortDescription(){return this.in.meta.description??this.in.defaultShortDescription}innerToJsonSchema(e){return e.fallback.morph({code:`morph`,base:this.in.toJsonSchemaRecurse(e),out:this.introspectableOut?.toJsonSchemaRecurse(e)??null})}compile(e){if(e.traversalKind===`Allows`){if(!this.introspectableIn)return;e.return(e.invoke(this.introspectableIn));return}if(this.introspectableIn)e.line(e.invoke(this.introspectableIn));e.line(`ctx.queueMorphs(${this.compiledMorphs})`)}traverseAllows=(e,t)=>!this.introspectableIn||this.introspectableIn.traverseAllows(e,t);traverseApply=(e,t)=>{if(this.introspectableIn)this.introspectableIn.traverseApply(e,t);t.queueMorphs(this.morphs)};hasEqualMorphs(e){return u(this.morphs,e.morphs,{isEqual:(e,t)=>e===t||E(e,`root`)&&E(t,`root`)&&e.equals(t)})}};const Ei={implementation:wi,Node:Ti};const Di=(e,t)=>`The intersection of distinct morphs at a single path is indeterminate:
Left: ${e}
Right: ${t}`;const Oi=k({kind:`proto`,hasAssociatedError:true,collapsibleKey:`proto`,keys:{proto:{serialize:e=>De(e)??O(e)},dateAllowsInvalid:{}},normalize:e=>{const t=typeof e===`string`?{proto:be[e]}:typeof e===`function`?D(e)?e:{proto:e}:typeof e.proto===`string`?{...e,proto:be[e.proto]}:e;if(typeof t.proto!==`function`)h(Ai.writeInvalidSchemaMessage(t.proto));if(oe(t,`dateAllowsInvalid`)&&t.proto!==Date)h(Ai.writeBadInvalidDateMessage(t.proto));return t},applyConfig:(e,t)=>{if(e.dateAllowsInvalid===void 0&&e.proto===Date&&t.dateAllowsInvalid)return{...e,dateAllowsInvalid:true};return e},defaults:{description:e=>e.builtinName?Ee[e.builtinName]:`an instance of ${e.proto.name}`,actual:e=>e instanceof Date&&e.toString()===`Invalid Date`?`an invalid Date`:Se(e)},intersections:{proto:(e,t)=>e.proto===Date&&t.proto===Date?e.dateAllowsInvalid?t:e:ke(e.proto,t.proto)?e:ke(t.proto,e.proto)?t:N.init(`proto`,e,t),domain:(e,t)=>t.domain===`object`?e:N.init(`domain`,C.intrinsic.object.internal,t)}});var ki=class extends hi{builtinName=De(this.proto);serializedConstructor=this.json.proto;requiresInvalidDateCheck=this.proto===Date&&!this.dateAllowsInvalid;traverseAllows=this.requiresInvalidDateCheck?e=>e instanceof Date&&e.toString()!==`Invalid Date`:e=>e instanceof this.proto;compiledCondition=`data instanceof ${this.serializedConstructor}${this.requiresInvalidDateCheck?` && data.toString() !== "Invalid Date"`:``}`;compiledNegation=`!(${this.compiledCondition})`;innerToJsonSchema(e){switch(this.builtinName){case`Array`:return{type:`array`};case`Date`:return e.fallback.date?.({code:`date`,base:{}})??e.fallback.proto({code:`proto`,base:{},proto:this.proto});default:return e.fallback.proto({code:`proto`,base:{},proto:this.proto})}}expression=this.dateAllowsInvalid?`Date | InvalidDate`:this.proto.name;get nestableExpression(){return this.dateAllowsInvalid?`(${this.expression})`:this.expression}domain=`object`;get defaultShortDescription(){return this.description}};const Ai={implementation:Oi,Node:ki,writeBadInvalidDateMessage:e=>`dateAllowsInvalid may only be specified with constructor Date (was ${e.name})`,writeInvalidSchemaMessage:e=>`instanceOf operand must be a function (was ${f(e)})`};const ji=k({kind:`union`,hasAssociatedError:true,collapsibleKey:`branches`,keys:{ordered:{},branches:{child:true,parse:(e,t)=>{const n=[];for(const r of e){const e=E(r,`root`)?r.branches:t.$.parseSchema(r).branches;for(const r of e)if(r.hasKind(`morph`)){const e=n.findIndex(e=>e.hasKind(`morph`)&&e.hasEqualMorphs(r));if(e===-1)n.push(r);else{const i=n[e];n[e]=t.$.node(`morph`,{...i.inner,in:i.in.rawOr(r.in)})}}else n.push(r)}if(!t.def.ordered)n.sort((e,t)=>e.hash<t.hash?-1:1);return n}}},normalize:e=>y(e)?{branches:e}:e,reduce:(e,t)=>{const n=Gi(e);if(n.length===1)return n[0];if(n.length===e.branches.length)return;return t.node(`union`,{...e,branches:n},{prereduced:true})},defaults:{description:e=>e.distribute(e=>e.description,R),expected:e=>{const t=l(e.errors,`propString`);const n=Object.entries(t).map(([e,t])=>{const n=[];for(const e of t)c(n,e.expected);const r=R(n);const i=t.every(e=>e.actual===t[0].actual)?t[0].actual:x(t[0].data);return`${e&&`${e} `}must be ${r}${i&&` (was ${i})`}`});return R(n)},problem:e=>e.expected,message:e=>e.problem},intersections:{union:(e,t,n)=>{if(e.isNever!==t.isNever)return N.init(`presence`,e,t);let r;if(e.ordered){if(t.ordered)h(Yi(e.expression,t.expression));r=Wi(t.branches,e.branches,n);if(r instanceof N)r.invert()}else r=Wi(e.branches,t.branches,n);if(r instanceof N)return r;return n.$.parseSchema(e.ordered||t.ordered?{branches:r,ordered:true}:{branches:r})},...ci(`union`,(e,t,n)=>{const r=Wi(e.branches,[t],n);if(r instanceof N)return r;if(r.length===1)return r[0];return n.$.parseSchema(e.ordered?{branches:r,ordered:true}:{branches:r})})}});var Mi=class extends ti{isBoolean=this.branches.length===2&&this.branches[0].hasUnit(false)&&this.branches[1].hasUnit(true);get branchGroups(){const e=[];let t=-1;for(const n of this.branches){if(n.hasKind(`unit`)&&n.domain===`boolean`){if(t===-1){t=e.length;e.push(n)}else e[t]=C.intrinsic.boolean;continue}e.push(n)}return e}unitBranches=this.branches.filter(e=>e.in.hasKind(`unit`));discriminant=this.discriminate();discriminantJson=this.discriminant?Vi(this.discriminant):null;expression=this.distribute(e=>e.nestableExpression,Ui);createBranchedOptimisticRootApply(){return(e,t)=>{const n=this.traverseOptimistic(e);if(n!==v)return n;const r=new un(e,this.$.resolvedConfig);this.traverseApply(e,r);return r.finalize(t)}}get shallowMorphs(){return this.branches.reduce((e,t)=>c(e,t.shallowMorphs),[])}get defaultShortDescription(){return this.distribute(e=>e.defaultShortDescription,R)}innerToJsonSchema(e){if(this.branchGroups.length===1&&this.branchGroups[0].equals(C.intrinsic.boolean))return{type:`boolean`};const t=this.branchGroups.map(t=>t.toJsonSchemaRecurse(e));if(t.every(e=>Object.keys(e).length===1&&oe(e,`const`)))return{enum:t.map(e=>e.const)};return{anyOf:t}}traverseAllows=(e,t)=>this.branches.some(n=>n.traverseAllows(e,t));traverseApply=(e,t)=>{const n=[];for(let r=0;r<this.branches.length;r++){t.pushBranch();this.branches[r].traverseApply(e,t);if(!t.hasError()){if(this.branches[r].includesTransform)return t.queuedMorphs.push(...t.popBranch().queuedMorphs);return t.popBranch()}n.push(t.popBranch().error)}t.errorFromNodeContext({code:`union`,errors:n,meta:this.meta})};traverseOptimistic=e=>{for(let t=0;t<this.branches.length;t++){const n=this.branches[t];if(n.traverseAllows(e)){if(n.contextFreeMorph)return n.contextFreeMorph(e);return e}}return v};compile(e){if(!this.discriminant||this.unitBranches.length===this.branches.length&&this.branches.length===2)return this.compileIndiscriminable(e);let t=this.discriminant.optionallyChainedPropString;if(this.discriminant.kind===`domain`)t=`typeof ${t} === "object" ? ${t} === null ? "null" : "object" : typeof ${t} === "function" ? "object" : typeof ${t}`;const n=this.discriminant.cases;const r=Object.keys(n);const{optimistic:i}=e;e.optimistic=false;e.block(`switch(${t})`,()=>{for(const t in n){const r=n[t];const a=t===`default`?t:`case ${t}`;e.line(`${a}: return ${r===true?i?e.data:r:i?`${e.invoke(r)} ? ${r.contextFreeMorph?`${w(r.contextFreeMorph)}(${e.data})`:e.data} : "${v}"`:e.invoke(r)}`)}return e});if(e.traversalKind===`Allows`){e.return(i?`"${v}"`:false);return}const a=R(this.discriminant.kind===`domain`?r.map(e=>{const t=e.slice(1,-1);return t===`function`?p.object:p[t]}):r);const o=this.discriminant.path.map(e=>typeof e===`symbol`?w(e):JSON.stringify(e));const s=JSON.stringify(a);const c=this.discriminant.kind===`domain`?`${Ri}[${t}]`:`${zi}(${t})`;e.line(`ctx.errorFromNodeContext({
	code: "predicate",
	expected: ${s},
	actual: ${c},
	relativePath: [${o}],
	meta: ${this.compiledMeta}
})`)}compileIndiscriminable(e){if(e.traversalKind===`Apply`){e.const(`errors`,`[]`);for(const t of this.branches)e.line(`ctx.pushBranch()`).line(e.invoke(t)).if(`!ctx.hasError()`,()=>e.return(t.includesTransform?`ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)`:`ctx.popBranch()`)).line(`errors.push(ctx.popBranch().error)`);e.line(`ctx.errorFromNodeContext({ code: "union", errors, meta: ${this.compiledMeta} })`)}else{const{optimistic:t}=e;e.optimistic=false;for(const n of this.branches)e.if(`${e.invoke(n)}`,()=>e.return(t?n.contextFreeMorph?`${w(n.contextFreeMorph)}(${e.data})`:e.data:true));e.return(t?`"${v}"`:false)}}get nestableExpression(){return this.isBoolean?`boolean`:`(${this.expression})`}discriminate(){if(this.branches.length<2||this.isCyclic)return null;if(this.unitBranches.length===this.branches.length){const e=_(this.unitBranches,(e,t)=>[`${t.in.serializedValue}`,t.hasKind(`morph`)?t:true]);return{kind:`unit`,path:[],optionallyChainedPropString:`data`,cases:e}}const e=[];for(let t=0;t<this.branches.length-1;t++){const n=this.branches[t];for(let r=t+1;r<this.branches.length;r++){const i=this.branches[r];const a=P(n.in,i.in,n.$);if(!(a instanceof N))continue;for(const n of a){if(!n.kind||n.optional)continue;let i;let a;if(n.kind===`domain`){const e=n.l;const t=n.r;i=`"${typeof e===`string`?e:e.domain}"`;a=`"${typeof t===`string`?t:t.domain}"`}else if(n.kind===`unit`){i=n.l.serializedValue;a=n.r.serializedValue}else continue;const o=e.find(e=>u(e.path,n.path)&&e.kind===n.kind);if(!o)e.push({kind:n.kind,cases:{[i]:{branchIndices:[t],condition:n.l},[a]:{branchIndices:[r],condition:n.r}},path:n.path});else{if(o.cases[i])o.cases[i].branchIndices=c(o.cases[i].branchIndices,t);else o.cases[i]??={branchIndices:[t],condition:n.l};if(o.cases[a])o.cases[a].branchIndices=c(o.cases[a].branchIndices,r);else o.cases[a]??={branchIndices:[r],condition:n.r}}}}}const t=this.ordered?Fi(e,this.branches):e;if(!t.length)return null;const n=Ni(t,this);const r={};for(const e in n.best.cases){const t=Pi(n,e);if(t===null){r[e]=true;continue}if(t.length===this.branches.length)return null;if(this.ordered)t.sort((e,t)=>e.originalIndex-t.originalIndex);const i=t.map(e=>e.branch);const a=i.length===1?i[0]:this.$.node(`union`,this.ordered?{branches:i,ordered:true}:i);Object.assign(this.referencesById,a.referencesById);r[e]=a}if(n.defaultEntries.length){const e=n.defaultEntries.map(e=>e.branch);r.default=this.$.node(`union`,this.ordered?{branches:e,ordered:true}:e,{prereduced:true});Object.assign(this.referencesById,r.default.referencesById)}return Object.assign(n.location,{cases:r})}};const Ni=(e,t)=>{const n=e.sort((e,t)=>Object.keys(t.cases).length-Object.keys(e.cases).length)[0];const r={kind:n.kind,path:n.path,optionallyChainedPropString:Li(n.path)};const i=t.branches.map((e,t)=>({originalIndex:t,branch:e}));return{best:n,location:r,defaultEntries:i,node:t}};const Pi=(e,t)=>{const n=e.best.cases[t];const r=Ii(n.condition,e.location.path,e.node.$);let i=[];const a=[];for(let t=0;t<e.defaultEntries.length;t++){const o=e.defaultEntries[t];if(n.branchIndices.includes(o.originalIndex)){const t=qi(e.node.branches[o.originalIndex],e.location);if(t===null)i=null;else i?.push({originalIndex:o.originalIndex,branch:t})}else if(o.branch.hasKind(`alias`)&&r.hasKind(`domain`)&&r.domain===`object`)i?.push(o);else{if(o.branch.in.overlaps(r)){const t=qi(o.branch,e.location);i?.push({originalIndex:o.originalIndex,branch:t})}a.push(o)}}e.defaultEntries=a;return i};const Fi=(e,t)=>{const n=e.filter(e=>{const n=Object.values(e.cases).map(e=>e.branchIndices);for(let e=0;e<n.length-1;e++){const r=n[e];for(let i=e+1;i<n.length;i++){const e=n[i];for(const n of r)for(const r of e)if(n>r){if(t[n].overlaps(t[r]))return false}}}return true});return n};const Ii=(e,t,n)=>{let r=e===`undefined`?n.node(`unit`,{unit:void 0}):e===`null`?n.node(`unit`,{unit:null}):e===`boolean`?n.units([true,false]):e;for(let e=t.length-1;e>=0;e--){const a=t[e];r=n.node(`intersection`,typeof a===`number`?{proto:`Array`,sequence:[...i(a).map(e=>({})),r]}:{domain:`object`,required:[{key:a,value:r}]})}return r};const Li=e=>e.reduce((e,t)=>e+Nt(t,true),`data`);const Ri=w(ee);const zi=w(x);const Bi={implementation:ji,Node:Mi};const Vi=e=>({kind:e.kind,path:e.path.map(e=>typeof e===`string`?e:Mt(e)),cases:_(e.cases,(e,t)=>[e,t===true?t:t.hasKind(`union`)&&t.discriminantJson?t.discriminantJson:t.json])});const Hi={delimiter:` | `,finalDelimiter:` | `};const Ui=e=>R(e,Hi);const R=(e,t)=>{const n=t?.delimiter??`, `;const r=t?.finalDelimiter??` or `;if(e.length===0)return`never`;if(e.length===1)return e[0];if(e.length===2&&e[0]===`false`&&e[1]===`true`||e[0]===`true`&&e[1]===`false`)return`boolean`;const i={};const a=e.filter(e=>i[e]?false:i[e]=true);const o=a.pop();return`${a.join(n)}${a.length?r:``}${o}`};const Wi=(e,t,n)=>{const r=t.map(()=>[]);for(let i=0;i<e.length;i++){let a={};for(let o=0;o<t.length;o++){if(r[o]===null)continue;if(e[i].equals(t[o])){r[o]=null;a={};break}const s=F(e[i],t[o],n);if(s instanceof N)continue;if(s.equals(e[i])){r[o].push(e[i]);a={};break}if(s.equals(t[o]))r[o]=null;else a[o]=s}for(const e in a)r[e][i]=a[e]}const i=r.flatMap((e,n)=>e?.flatMap(e=>e.branches)??t[n]);return i.length===0?N.init(`union`,e,t):i};const Gi=({branches:e,ordered:t})=>{if(e.length<2)return e;const n=e.map(()=>true);for(let r=0;r<e.length;r++)for(let i=r+1;i<e.length&&n[r]&&n[i];i++){if(e[r].equals(e[i])){n[i]=false;continue}const a=P(e[r].in,e[i].in,e[0].$);if(a instanceof N)continue;if(!t)Ki(e[r],e[i]);if(a.equals(e[r].in))n[r]=!!t;else if(a.equals(e[i].in))n[i]=false}return e.filter((e,t)=>n[t])};const Ki=(e,t)=>{if(!e.includesTransform&&!t.includesTransform)return;if(!u(e.shallowMorphs,t.shallowMorphs))h(Ji(e.expression,t.expression));if(!u(e.flatMorphs,t.flatMorphs,{isEqual:(e,t)=>e.propString===t.propString&&(e.node.hasKind(`morph`)&&t.node.hasKind(`morph`)?e.node.hasEqualMorphs(t.node):e.node.hasKind(`intersection`)&&t.node.hasKind(`intersection`)?e.node.structure?.structuralMorphRef===t.node.structure?.structuralMorphRef:false)}))h(Ji(e.expression,t.expression))};const qi=(e,t)=>e.transform((e,t)=>{if(e===`domain`||e===`unit`)return null;return t},{shouldTransform:(e,n)=>{const r=Li(n.path);if(!t.optionallyChainedPropString.startsWith(r))return false;if(e.hasKind(`domain`)&&e.domain===`object`)return true;if((e.hasKind(`domain`)||t.kind===`unit`)&&r===t.optionallyChainedPropString)return true;return e.children.length!==0&&e.kind!==`index`}});const Ji=(e,t)=>`An unordered union of a type including a morph and a type with overlapping input is indeterminate:
Left: ${e}
Right: ${t}`;const Yi=(e,t)=>`The intersection of two ordered unions is indeterminate:
Left: ${e}
Right: ${t}`;const Xi=k({kind:`unit`,hasAssociatedError:true,keys:{unit:{preserveUndefined:true,serialize:e=>e instanceof Date?e.toISOString():O(e)}},normalize:e=>e,defaults:{description:e=>x(e.unit),problem:({expected:e,actual:t})=>`${e===t?`must be reference equal to ${e} (serialized to the same value)`:`must be ${e} (was ${t})`}`},intersections:{unit:(e,t)=>N.init(`unit`,e,t),...ci(`unit`,(e,t)=>{if(t.allows(e.unit))return e;const n=t.hasKind(`intersection`)?t.basis:t;if(n){const t=n.hasKind(`domain`)?n:C.intrinsic.object;if(e.domain!==t.domain){const n=e.domain===`undefined`||e.domain===`null`||e.domain===`boolean`?e.domain:C.intrinsic[e.domain];return N.init(`domain`,n,t)}}return N.init(`assignability`,e,t.hasKind(`intersection`)?t.children.find(t=>!t.allows(e.unit)):t)})}});var Zi=class extends hi{compiledValue=this.json.unit;serializedValue=typeof this.unit===`string`||this.unit instanceof Date?JSON.stringify(this.compiledValue):`${this.compiledValue}`;compiledCondition=$i(this.unit,this.serializedValue);compiledNegation=$i(this.unit,this.serializedValue,`negated`);expression=x(this.unit);domain=f(this.unit);get defaultShortDescription(){return this.domain===`object`?p.object:this.description}innerToJsonSchema(e){return this.unit===null?{type:`null`}:C.intrinsic.jsonPrimitive.allows(this.unit)?{const:this.unit}:e.fallback.unit({code:`unit`,base:{},unit:this.unit})}traverseAllows=this.unit instanceof Date?e=>e instanceof Date&&e.toISOString()===this.compiledValue:Number.isNaN(this.unit)?e=>Number.isNaN(e):e=>e===this.unit};const Qi={implementation:Xi,Node:Zi};const $i=(e,t,n)=>{if(e instanceof Date){const e=`data instanceof Date && data.toISOString() === ${t}`;return n?`!(${e})`:e}if(Number.isNaN(e))return`${n?`!`:``}Number.isNaN(data)`;return`data ${n?`!`:`=`}== ${t}`};const ea=k({kind:`index`,hasAssociatedError:false,intersectionIsOpen:true,keys:{signature:{child:true,parse:(e,t)=>{const n=t.$.parseSchema(e);if(!n.extends(C.intrinsic.key))return h(ia(n.expression));const r=n.branches.filter(e=>e.hasKind(`unit`));if(r.length)return h(ra(r.map(e=>x(e.unit))));return n}},value:{child:true,parse:(e,t)=>t.$.parseSchema(e)}},normalize:e=>e,defaults:{description:e=>`[${e.signature.expression}]: ${e.value.description}`},intersections:{index:(e,t,n)=>{if(e.signature.equals(t.signature)){const r=F(e.value,t.value,n);const i=r instanceof N?C.intrinsic.never.internal:r;return n.$.node(`index`,{signature:e.signature,value:i})}if(e.signature.extends(t.signature)&&e.value.subsumes(t.value))return t;if(t.signature.extends(e.signature)&&t.value.subsumes(e.value))return e;return null}}});var ta=class extends kn{impliedBasis=C.intrinsic.object.internal;expression=`[${this.signature.expression}]: ${this.value.expression}`;flatRefs=a(this.value.flatRefs.map(e=>M([this.signature,...e.path],e.node)),M([this.signature],this.value));traverseAllows=(e,t)=>pe(e).every(e=>{if(this.signature.traverseAllows(e[0],t))return j(e[0],()=>this.value.traverseAllows(e[1],t),t);return true});traverseApply=(e,t)=>{for(const n of pe(e))if(this.signature.traverseAllows(n[0],t))j(n[0],()=>this.value.traverseApply(n[1],t),t)};_transform(e,t){t.path.push(this.signature);const n=super._transform(e,t);t.path.pop();return n}compile(){}};const na={implementation:ea,Node:ta};const ra=e=>`Index keys ${e.join(`, `)} should be specified as named props.`;const ia=e=>`Indexed key definition '${e}' must be a string or symbol`;const aa=k({kind:`required`,hasAssociatedError:true,intersectionIsOpen:true,keys:{key:{},value:{child:true,parse:(e,t)=>t.$.parseSchema(e)}},normalize:e=>e,defaults:{description:e=>`${e.compiledKey}: ${e.value.description}`,expected:e=>e.missingValueDescription,actual:()=>`missing`},intersections:{required:Wr,optional:Wr}});var oa=class extends Gr{expression=`${this.compiledKey}: ${this.value.expression}`;errorContext=Object.freeze({code:`required`,missingValueDescription:this.value.defaultShortDescription,relativePath:[this.key],meta:this.meta});compiledErrorContext=Qt(this.errorContext)};const sa={implementation:aa,Node:oa};const ca=k({kind:`sequence`,hasAssociatedError:false,collapsibleKey:`variadic`,keys:{prefix:{child:true,parse:(e,t)=>{if(e.length===0)return void 0;return e.map(e=>t.$.parseSchema(e))}},optionals:{child:true,parse:(e,t)=>{if(e.length===0)return void 0;return e.map(e=>t.$.parseSchema(e))}},defaultables:{child:e=>e.map(e=>e[0]),parse:(e,t)=>{if(e.length===0)return void 0;return e.map(e=>{const n=t.$.parseSchema(e[0]);$r(n,e[1],null);return[n,e[1]]})},serialize:e=>e.map(e=>[e[0].collapsibleJson,O(e[1])])},variadic:{child:true,parse:(e,t)=>t.$.parseSchema(e,t)},minVariadicLength:{parse:e=>e===0?void 0:e},postfix:{child:true,parse:(e,t)=>{if(e.length===0)return void 0;return e.map(e=>t.$.parseSchema(e))}}},normalize:e=>{if(typeof e===`string`)return{variadic:e};if(`variadic`in e||`prefix`in e||`defaultables`in e||`optionals`in e||`postfix`in e||`minVariadicLength`in e){if(e.postfix?.length){if(!e.variadic)return h(ga);if(e.optionals?.length||e.defaultables?.length)return h(ha)}if(e.minVariadicLength&&!e.variadic)return h(`minVariadicLength may not be specified without a variadic element`);return e}return{variadic:e}},reduce:(e,t)=>{let n=e.minVariadicLength??0;const r=e.prefix?.slice()??[];const i=e.defaultables?.slice()??[];const a=e.optionals?.slice()??[];const o=e.postfix?.slice()??[];if(e.variadic){while(a.at(-1)?.equals(e.variadic))a.pop();if(a.length===0&&i.length===0)while(r.at(-1)?.equals(e.variadic)){r.pop();n++}while(o[0]?.equals(e.variadic)){o.shift();n++}}else if(a.length===0&&i.length===0)r.push(...o.splice(0));if(n!==e.minVariadicLength||e.prefix&&e.prefix.length!==r.length)return t.node(`sequence`,{...e,prefix:r,defaultables:i,optionals:a,postfix:o,minVariadicLength:n},{prereduced:true})},defaults:{description:e=>{if(e.isVariadicOnly)return`${e.variadic.nestableExpression}[]`;const t=e.tuple.map(e=>e.kind===`defaultables`?`${e.node.nestableExpression} = ${x(e.default)}`:e.kind===`optionals`?`${e.node.nestableExpression}?`:e.kind===`variadic`?`...${e.node.nestableExpression}[]`:e.node.expression).join(`, `);return`[${t}]`}},intersections:{sequence:(e,t,n)=>{const r=_a({l:e.tuple,r:t.tuple,disjoint:new N,result:[],fixedVariants:[],ctx:n});const i=r.disjoint.length===0?[r,...r.fixedVariants]:r.fixedVariants;return i.length===0?r.disjoint:i.length===1?n.$.node(`sequence`,ma(i[0].result)):n.$.node(`union`,i.map(e=>({proto:Array,sequence:ma(e.result)})))}}});var la=class extends kn{impliedBasis=C.intrinsic.Array.internal;tuple=pa(this.inner);prefixLength=this.prefix?.length??0;defaultablesLength=this.defaultables?.length??0;optionalsLength=this.optionals?.length??0;postfixLength=this.postfix?.length??0;defaultablesAndOptionals=[];prevariadic=this.tuple.filter(e=>{if(e.kind===`defaultables`||e.kind===`optionals`){this.defaultablesAndOptionals.push(e.node);return true}return e.kind===`prefix`});variadicOrPostfix=o(this.variadic&&[this.variadic],this.postfix);flatRefs=this.addFlatRefs();addFlatRefs(){vn(this.flatRefs,this.prevariadic.flatMap((e,t)=>a(e.node.flatRefs.map(e=>M([`${t}`,...e.path],e.node)),M([`${t}`],e.node))));vn(this.flatRefs,this.variadicOrPostfix.flatMap(e=>a(e.flatRefs.map(e=>M([C.intrinsic.nonNegativeIntegerString.internal,...e.path],e.node)),M([C.intrinsic.nonNegativeIntegerString.internal],e))));return this.flatRefs}isVariadicOnly=this.prevariadic.length+this.postfixLength===0;minVariadicLength=this.inner.minVariadicLength??0;minLength=this.prefixLength+this.minVariadicLength+this.postfixLength;minLengthNode=this.minLength===0?null:this.$.node(`minLength`,this.minLength);maxLength=this.variadic?null:this.tuple.length;maxLengthNode=this.maxLength===null?null:this.$.node(`maxLength`,this.maxLength);impliedSiblings=this.minLengthNode?this.maxLengthNode?[this.minLengthNode,this.maxLengthNode]:[this.minLengthNode]:this.maxLengthNode?[this.maxLengthNode]:[];defaultValueMorphs=da(this);defaultValueMorphsReference=this.defaultValueMorphs.length?w(this.defaultValueMorphs):void 0;elementAtIndex(e,t){if(t<this.prevariadic.length)return this.tuple[t];const n=e.length-this.postfixLength;if(t>=n)return{kind:`postfix`,node:this.postfix[t-n]};return{kind:`variadic`,node:this.variadic??m(`Unexpected attempt to access index ${t} on ${this}`)}}traverseAllows=(e,t)=>{for(let n=0;n<e.length;n++)if(!this.elementAtIndex(e,n).node.traverseAllows(e[n],t))return false;return true};traverseApply=(e,t)=>{let n=0;for(;n<e.length;n++)j(n,()=>this.elementAtIndex(e,n).node.traverseApply(e[n],t),t)};get element(){return this.cacheGetter(`element`,this.$.node(`union`,this.children))}compile(e){if(this.prefix)for(const[t,n]of this.prefix.entries())e.traverseKey(`${t}`,`data[${t}]`,n);for(const[t,n]of this.defaultablesAndOptionals.entries()){const r=`${t+this.prefixLength}`;e.if(`${r} >= ${e.data}.length`,()=>e.traversalKind===`Allows`?e.return(true):e.return());e.traverseKey(r,`data[${r}]`,n)}if(this.variadic){if(this.postfix)e.const(`firstPostfixIndex`,`${e.data}.length${this.postfix?`- ${this.postfix.length}`:``}`);e.for(`i < ${this.postfix?`firstPostfixIndex`:`data.length`}`,()=>e.traverseKey(`i`,`data[i]`,this.variadic),this.prevariadic.length);if(this.postfix)for(const[t,n]of this.postfix.entries()){const r=`firstPostfixIndex + ${t}`;e.traverseKey(r,`data[${r}]`,n)}}if(e.traversalKind===`Allows`)e.return(true)}_transform(e,t){t.path.push(C.intrinsic.nonNegativeIntegerString.internal);const n=super._transform(e,t);t.path.pop();return n}expression=this.description;reduceJsonSchema(e,t){if(this.prevariadic.length)e.prefixItems=this.prevariadic.map(e=>{const n=e.node.toJsonSchemaRecurse(t);if(e.kind===`defaultables`){const r=typeof e.default===`function`?e.default():e.default;n.default=C.intrinsic.jsonData.allows(r)?r:t.fallback.defaultValue({code:`defaultValue`,base:n,value:r})}return n});if(this.minLength)e.minItems=this.minLength;if(this.variadic){const n=Object.assign(e,{items:this.variadic.toJsonSchemaRecurse(t)});if(this.maxLength)n.maxItems=this.maxLength;if(this.postfix){const r=this.postfix.map(e=>e.toJsonSchemaRecurse(t));e=t.fallback.arrayPostfix({code:`arrayPostfix`,base:n,elements:r})}}else{e.items=false;delete e.maxItems}return e}};const ua={};const da=e=>{if(!e.defaultables)return[];const t=[];let n=`[`;const r=e.prefixLength+e.defaultablesLength-1;for(let i=e.prefixLength;i<=r;i++){const[r,a]=e.defaultables[i-e.prefixLength];t.push(Qr(i,r,a));n+=`${i}: ${r.id} = ${O(a)}, `}n+=`]`;return ua[n]??=t};const fa={implementation:ca,Node:la};const pa=e=>{const t=[];if(e.prefix)for(const n of e.prefix)t.push({kind:`prefix`,node:n});if(e.defaultables)for(const[n,r]of e.defaultables)t.push({kind:`defaultables`,node:n,default:r});if(e.optionals)for(const n of e.optionals)t.push({kind:`optionals`,node:n});if(e.variadic)t.push({kind:`variadic`,node:e.variadic});if(e.postfix)for(const n of e.postfix)t.push({kind:`postfix`,node:n});return t};const ma=e=>e.reduce((e,t)=>{if(t.kind===`variadic`)e.variadic=t.node;else if(t.kind===`defaultables`)e.defaultables=a(e.defaultables,[[t.node,t.default]]);else e[t.kind]=a(e[t.kind],t.node);return e},{});const ha=`A postfix required element cannot follow an optional or defaultable element`;const ga=`A postfix element requires a variadic element`;const _a=e=>{const[t,...n]=e.l;const[r,...i]=e.r;if(!t||!r)return e;const a=n.at(-1)?.kind===`postfix`;const o=i.at(-1)?.kind===`postfix`;const s=t.kind===`prefix`||r.kind===`prefix`?`prefix`:t.kind===`postfix`||r.kind===`postfix`?`postfix`:t.kind===`variadic`&&r.kind===`variadic`?`variadic`:a||o?`prefix`:t.kind===`defaultables`||r.kind===`defaultables`?`defaultables`:`optionals`;if(t.kind===`prefix`&&r.kind===`variadic`&&o){const t=_a({...e,fixedVariants:[],r:i.map(e=>({...e,kind:`prefix`}))});if(t.disjoint.length===0)e.fixedVariants.push(t)}else if(r.kind===`prefix`&&t.kind===`variadic`&&a){const t=_a({...e,fixedVariants:[],l:n.map(e=>({...e,kind:`prefix`}))});if(t.disjoint.length===0)e.fixedVariants.push(t)}const c=F(t.node,r.node,e.ctx);if(c instanceof N)if(s===`prefix`||s===`postfix`){e.disjoint.push(...c.withPrefixKey(s===`prefix`?e.result.length:`-${n.length+1}`,`required`));e.result=[...e.result,{kind:s,node:C.intrinsic.never.internal}]}else if(s===`optionals`||s===`defaultables`)return e;else return _a({...e,fixedVariants:[],l:n.map(e=>({...e,kind:`prefix`})),r:n.map(e=>({...e,kind:`prefix`}))});else if(s===`defaultables`){if(t.kind===`defaultables`&&r.kind===`defaultables`&&t.default!==r.default)h(Kr(t.default,r.default));e.result=[...e.result,{kind:s,node:c,default:t.kind===`defaultables`?t.default:r.kind===`defaultables`?r.default:m(`Unexpected defaultable intersection from ${t.kind} and ${r.kind} elements.`)}]}else e.result=[...e.result,{kind:s,node:c}];const l=e.l.length;const u=e.r.length;if(t.kind!==`variadic`||l>=u&&(r.kind===`variadic`||u===1))e.l=n;if(r.kind!==`variadic`||u>=l&&(t.kind===`variadic`||l===1))e.r=i;return _a(e)};const va=e=>t=>{if(t.props.length||t.index){const n=t.index?.map(t=>t[e])??[];for(const r of t.props)n.push(r[e]);if(t.undeclared)n.push(`+ (undeclared): ${t.undeclared}`);const r=`{ ${n.join(`, `)} }`;return t.sequence?`${r} & ${t.sequence.description}`:r}return t.sequence?.description??`{}`};const ya=va(`description`);const ba=va(`expression`);const xa=(e,t,n)=>{const r=e.required?`required`:`optional`;if(!t.signature.allows(e.key))return null;const i=P(e.value,t.value,n);if(i instanceof N)return r===`optional`?n.node(`optional`,{key:e.key,value:C.intrinsic.never.internal}):i.withPrefixKey(e.key,e.kind);return null};const Sa=k({kind:`structure`,hasAssociatedError:false,normalize:e=>e,applyConfig:(e,t)=>{if(!e.undeclared&&t.onUndeclaredKey!==`ignore`)return{...e,undeclared:t.onUndeclaredKey};return e},keys:{required:{child:true,parse:I(`required`),reduceIo:(e,t,n)=>{t.required=a(t.required,n.map(t=>t[e]));return}},optional:{child:true,parse:I(`optional`),reduceIo:(e,t,n)=>{if(e===`in`){t.optional=n.map(e=>e.in);return}for(const e of n)t[e.outProp.kind]=a(t[e.outProp.kind],e.outProp.out)}},index:{child:true,parse:I(`index`)},sequence:{child:true,parse:I(`sequence`)},undeclared:{parse:e=>e===`ignore`?void 0:e,reduceIo:(e,t,n)=>{if(n!==`delete`)return;if(e===`in`)delete t.undeclared;else t.undeclared=`reject`}}},defaults:{description:ya},intersections:{structure:(e,t,n)=>{const r={...e.inner};const i={...t.inner};const a=new N;if(e.undeclared){const r=e.keyof();for(const e of t.requiredKeys)if(!r.allows(e))a.add(`presence`,C.intrinsic.never.internal,t.propsByKey[e].value,{path:[e]});if(i.optional)i.optional=i.optional.filter(e=>r.allows(e.key));if(i.index)i.index=i.index.flatMap(e=>{if(e.signature.extends(r))return e;const t=P(r,e.signature,n.$);if(t instanceof N)return[];const a=ja(t,e.value,n.$);if(a.required)i.required=o(i.required,a.required);if(a.optional)i.optional=o(i.optional,a.optional);return a.index??[]})}if(t.undeclared){const i=t.keyof();for(const t of e.requiredKeys)if(!i.allows(t))a.add(`presence`,e.propsByKey[t].value,C.intrinsic.never.internal,{path:[t]});if(r.optional)r.optional=r.optional.filter(e=>i.allows(e.key));if(r.index)r.index=r.index.flatMap(e=>{if(e.signature.extends(i))return e;const t=P(i,e.signature,n.$);if(t instanceof N)return[];const a=ja(t,e.value,n.$);if(a.required)r.required=o(r.required,a.required);if(a.optional)r.optional=o(r.optional,a.optional);return a.index??[]})}const s={};if(e.undeclared||t.undeclared)s.undeclared=e.undeclared===`reject`||t.undeclared===`reject`?`reject`:`delete`;const c=jn({kind:`structure`,baseInner:s,l:Mn(r),r:Mn(i),roots:[],ctx:n});if(c instanceof N)a.push(...c);if(a.length)return a;return c}},reduce:(e,t)=>{if(e.index){if(!(e.required||e.optional))return;let n=false;const r=e.required??[];const i=e.optional??[];const a=[...i];for(const o of e.index){for(const e of r){const n=xa(e,o,t);if(n instanceof N)return n}for(const[e,r]of i.entries()){const i=xa(r,o,t);if(i instanceof N)return i;if(i===null)continue;a[e]=i;n=true}}if(n)return t.node(`structure`,{...e,optional:a},{prereduced:true})}}});var Ca=class extends kn{impliedBasis=C.intrinsic.object.internal;impliedSiblings=this.children.flatMap(e=>e.impliedSiblings??[]);props=o(this.required,this.optional);propsByKey=_(this.props,(e,t)=>[t.key,t]);propsByKeyReference=w(this.propsByKey);expression=ba(this);requiredKeys=this.required?.map(e=>e.key)??[];optionalKeys=this.optional?.map(e=>e.key)??[];literalKeys=[...this.requiredKeys,...this.optionalKeys];_keyof;keyof(){if(this._keyof)return this._keyof;let e=this.$.units(this.literalKeys).branches;if(this.index)for(const{signature:t}of this.index)e=e.concat(t.branches);return this._keyof=this.$.node(`union`,e)}map(e){return this.$.node(`structure`,this.props.flatMap(e).reduce((e,t)=>{const n=this.propsByKey[t.key];if(D(t)){if(t.kind!==`required`&&t.kind!==`optional`)return h(`Map result must have kind "required" or "optional" (was ${t.kind})`);e[t.kind]=a(e[t.kind],t);return e}const r=t.kind??n?.kind??`required`;const i=_(t,(e,t)=>e in Yr.implementation.keys?[e,t]:[]);e[r]=a(e[r],this.$.node(r,i));return e},{}))}assertHasKeys(e){const t=e.filter(e=>!ii(e,this.keyof()));if(t.length)return h(Na(this.expression,t))}get(e,...t){let n;let r=false;const i=ka(e);if((typeof i===`string`||typeof i===`symbol`)&&this.propsByKey[i]){n=this.propsByKey[i].value;r=this.propsByKey[i].required}if(this.index){for(const e of this.index)if(ii(i,e.signature))n=n?.and(e.value)??e.value}if(this.sequence&&ii(i,C.intrinsic.nonNegativeIntegerString))if(E(i,`root`)){if(this.sequence.variadic)n=n?.and(this.sequence.element)??this.sequence.element}else{const e=Number.parseInt(i);if(e<this.sequence.prevariadic.length){const t=this.sequence.prevariadic[e].node;n=n?.and(t)??t;r||=e<this.sequence.prefixLength}else if(this.sequence.variadic){const e=this.$.node(`union`,this.sequence.variadicOrPostfix);n=n?.and(e)??e}}if(!n){if(this.sequence?.variadic&&E(i,`root`)&&i.extends(C.intrinsic.number))return h(Aa(i.expression,this.sequence.expression));return h(Na(this.expression,[i]))}const a=n.get(...t);return r?a:a.or(C.intrinsic.undefined)}pick(...e){this.assertHasKeys(e);return this.$.node(`structure`,this.filterKeys(`pick`,e))}omit(...e){this.assertHasKeys(e);return this.$.node(`structure`,this.filterKeys(`omit`,e))}optionalize(){const{required:e,...t}=this.inner;return this.$.node(`structure`,{...t,optional:this.props.map(e=>e.hasKind(`required`)?this.$.node(`optional`,e.inner):e)})}require(){const{optional:e,...t}=this.inner;return this.$.node(`structure`,{...t,required:this.props.map(e=>e.hasKind(`optional`)?{key:e.key,value:e.value}:e)})}merge(e){const t=this.filterKeys(`omit`,[e.keyof()]);if(e.required)t.required=a(t.required,e.required);if(e.optional)t.optional=a(t.optional,e.optional);if(e.index)t.index=a(t.index,e.index);if(e.sequence)t.sequence=e.sequence;if(e.undeclared)t.undeclared=e.undeclared;else delete t.undeclared;return this.$.node(`structure`,t)}filterKeys(e,t){const n=Lt(this.inner);const r=n=>{const r=t.some(e=>ii(n,e));return e===`pick`?r:!r};if(n.required)n.required=n.required.filter(e=>r(e.key));if(n.optional)n.optional=n.optional.filter(e=>r(e.key));if(n.index)n.index=n.index.filter(e=>r(e.signature));return n}traverseAllows=(e,t)=>this._traverse(`Allows`,e,t);traverseApply=(e,t)=>this._traverse(`Apply`,e,t);_traverse=(e,t,n)=>{const r=n?.currentErrorCount??0;for(let i=0;i<this.props.length;i++)if(e===`Allows`){if(!this.props[i].traverseAllows(t,n))return false}else{this.props[i].traverseApply(t,n);if(n.failFast&&n.currentErrorCount>r)return false}if(this.sequence)if(e===`Allows`){if(!this.sequence.traverseAllows(t,n))return false}else{this.sequence.traverseApply(t,n);if(n.failFast&&n.currentErrorCount>r)return false}if(this.index||this.undeclared===`reject`){const i=Object.keys(t);i.push(...Object.getOwnPropertySymbols(t));for(let a=0;a<i.length;a++){const o=i[a];if(this.index){for(const i of this.index)if(i.signature.traverseAllows(o,n))if(e===`Allows`){const e=j(o,()=>i.value.traverseAllows(t[o],n),n);if(!e)return false}else{j(o,()=>i.value.traverseApply(t[o],n),n);if(n.failFast&&n.currentErrorCount>r)return false}}if(this.undeclared===`reject`&&!this.declaresKey(o)){if(e===`Allows`)return false;n.errorFromNodeContext({code:`predicate`,expected:`removed`,actual:``,relativePath:[o],meta:this.meta});if(n.failFast)return false}}}if(this.structuralMorph&&n&&!n.hasError())n.queueMorphs([this.structuralMorph]);return true};get defaultable(){return this.cacheGetter(`defaultable`,this.optional?.filter(e=>e.hasDefault())??[])}declaresKey=e=>e in this.propsByKey||this.index?.some(t=>t.signature.allows(e))||this.sequence!==void 0&&C.intrinsic.nonNegativeIntegerString.allows(e);_compileDeclaresKey(e){const t=[];if(this.props.length)t.push(`k in ${this.propsByKeyReference}`);if(this.index)for(const n of this.index)t.push(e.invoke(n.signature,{kind:`Allows`,arg:`k`}));if(this.sequence)t.push(`$ark.intrinsic.nonNegativeIntegerString.allows(k)`);return t.join(` || `)||`false`}get structuralMorph(){return this.cacheGetter(`structuralMorph`,Ea(this))}structuralMorphRef=this.structuralMorph&&w(this.structuralMorph);compile(e){if(e.traversalKind===`Apply`)e.initializeErrorCount();for(const t of this.props){e.check(t);if(e.traversalKind===`Apply`)e.returnIfFailFast()}if(this.sequence){e.check(this.sequence);if(e.traversalKind===`Apply`)e.returnIfFailFast()}if(this.index||this.undeclared===`reject`){e.const(`keys`,`Object.keys(data)`);e.line(`keys.push(...Object.getOwnPropertySymbols(data))`);e.for(`i < keys.length`,()=>this.compileExhaustiveEntry(e))}if(e.traversalKind===`Allows`)return e.return(true);if(this.structuralMorphRef)e.if(`ctx && !ctx.hasError()`,()=>{e.line(`ctx.queueMorphs([`);Da(e,this);return e.line(`])`)})}compileExhaustiveEntry(e){e.const(`k`,`keys[i]`);if(this.index)for(const t of this.index)e.if(`${e.invoke(t.signature,{arg:`k`,kind:`Allows`})}`,()=>e.traverseKey(`k`,`data[k]`,t.value));if(this.undeclared===`reject`)e.if(`!(${this._compileDeclaresKey(e)})`,()=>{if(e.traversalKind===`Allows`)return e.return(false);return e.line(`ctx.errorFromNodeContext({ code: "predicate", expected: "removed", actual: "", relativePath: [k], meta: ${this.compiledMeta} })`).if(`ctx.failFast`,()=>e.return())});return e}reduceJsonSchema(e,t){switch(e.type){case`object`:return this.reduceObjectJsonSchema(e,t);case`array`:const n=this.sequence?.reduceJsonSchema(e,t)??e;if(this.props.length||this.index)return t.fallback.arrayObject({code:`arrayObject`,base:n,object:this.reduceObjectJsonSchema({type:`object`},t)});return n;default:return A.throwInternalOperandError(`structure`,e)}}reduceObjectJsonSchema(e,t){if(this.props.length){e.properties={};for(const n of this.props){const r=n.value.toJsonSchemaRecurse(t);if(typeof n.key===`symbol`){t.fallback.symbolKey({code:`symbolKey`,base:e,key:n.key,value:r,optional:n.optional});continue}if(n.hasDefault()){const e=typeof n.default===`function`?n.default():n.default;r.default=C.intrinsic.jsonData.allows(e)?e:t.fallback.defaultValue({code:`defaultValue`,base:r,value:e})}e.properties[n.key]=r}if(this.requiredKeys.length&&e.properties)e.required=this.requiredKeys.filter(t=>typeof t===`string`&&t in e.properties)}if(this.index)for(const n of this.index){const r=n.value.toJsonSchemaRecurse(t);if(n.signature.equals(C.intrinsic.string)){e.additionalProperties=r;continue}for(const i of n.signature.branches){if(!i.extends(C.intrinsic.string)){e=t.fallback.symbolKey({code:`symbolKey`,base:e,key:null,value:r,optional:false});continue}let n={type:`string`};if(i.hasKind(`morph`))n=t.fallback.morph({code:`morph`,base:i.in.toJsonSchemaRecurse(t),out:i.out.toJsonSchemaRecurse(t)});if(!i.hasKind(`intersection`))return m(`Unexpected index branch kind ${i.kind}.`);const{pattern:a}=i.inner;if(a){const i=Object.assign(n,{pattern:a[0].rule});for(let e=1;e<a.length;e++)n=t.fallback.patternIntersection({code:`patternIntersection`,base:i,pattern:a[e].rule});e.patternProperties??={};e.patternProperties[i.pattern]=r}}}if(this.undeclared&&!e.additionalProperties)e.additionalProperties=false;return e}};const wa={};const Ta=e=>{let t=``;for(let n=0;n<e.defaultable.length;n++)t+=e.defaultable[n].defaultValueMorphRef;if(e.sequence?.defaultValueMorphsReference)t+=e.sequence?.defaultValueMorphsReference;if(e.undeclared===`delete`){t+=`delete !(`;if(e.required)for(const n of e.required)t+=n.compiledKey+` | `;if(e.optional)for(const n of e.optional)t+=n.compiledKey+` | `;if(e.index)for(const n of e.index)t+=n.signature.id+` | `;if(e.sequence)if(e.sequence.maxLength===null)t+=V.nonNegativeIntegerString.id;else for(let n=0;n<e.sequence.tuple.length;n++)t+=n+` | `;t+=`)`}return t};const Ea=e=>{const t=Ta(e);if(!t)return void 0;if(wa[t])return wa[t];const n=(t,n)=>{for(let r=0;r<e.defaultable.length;r++)if(!(e.defaultable[r].key in t))e.defaultable[r].defaultValueMorph(t,n);if(e.sequence?.defaultables)for(let r=t.length-e.sequence.prefixLength;r<e.sequence.defaultables.length;r++)e.sequence.defaultValueMorphs[r](t,n);if(e.undeclared===`delete`){for(const n in t)if(!e.declaresKey(n))delete t[n]}return t};return wa[t]=n};const Da=(e,t)=>{const n=t.defaultable.some(e=>e.defaultValueMorph.length===2)||t.sequence?.defaultValueMorphs.some(e=>e.length===2);const r=`(data${n?`, ctx`:``})`;return e.block(`${r} => `,e=>{for(let n=0;n<t.defaultable.length;n++){const{serializedKey:i,defaultValueMorphRef:a}=t.defaultable[n];e.if(`!(${i} in data)`,e=>e.line(`${a}${r}`))}if(t.sequence?.defaultables)e.for(`i < ${t.sequence.defaultables.length}`,e=>e.set(`data[i]`,5),`data.length - ${t.sequence.prefixLength}`);if(t.undeclared===`delete`)e.forIn(`data`,e=>e.if(`!(${t._compileDeclaresKey(e)})`,e=>e.line(`delete data[k]`)));return e.return(`data`)})};const Oa={implementation:Sa,Node:Ca};const ka=e=>{if(E(e,`root`)&&e.hasKind(`unit`))e=e.unit;if(typeof e===`number`)e=`${e}`;return e};const Aa=(e,t)=>`${e} is not allowed as an array index on ${t}. Use the 'nonNegativeIntegerString' keyword instead.`;const ja=(e,n,r)=>{const[i,o]=t(e.branches,e=>e.hasKind(`unit`));if(!i.length)return{index:r.node(`index`,{signature:e,value:n})};const s={};for(const e of i){const t=r.node(`required`,{key:e.unit,value:n});s[t.kind]=a(s[t.kind],t)}if(o.length)s.index=r.node(`index`,{signature:o,value:n});return s};const Ma=e=>E(e,`root`)?e.expression:x(e);const Na=(e,t)=>`Key${t.length===1?``:`s`} ${t.map(Ma).join(`, `)} ${t.length===1?`does`:`do`} not exist on ${e}`;const Pa={...Or,alias:mi.implementation,domain:vi.implementation,unit:Qi.implementation,proto:Ai.implementation,union:Bi.implementation,morph:Ei.implementation,intersection:xi.implementation,divisor:Gn.implementation,pattern:Mr.implementation,predicate:Hn.implementation,required:sa.implementation,optional:Yr.implementation,index:na.implementation,sequence:fa.implementation,structure:Oa.implementation};C.defaultConfig=he(Object.assign(_(Pa,(e,t)=>[e,t.defaults]),{jitless:Ie(),clone:Ae,onUndeclaredKey:`ignore`,exactOptionalPropertyTypes:true,numberAllowsNaN:false,dateAllowsInvalid:false,onFail:null,keywords:{},toJsonSchema:A.defaultConfig}));C.resolvedConfig=tn(C.defaultConfig,C.config);const Fa={...kr,alias:mi.Node,domain:vi.Node,unit:Qi.Node,proto:Ai.Node,union:Bi.Node,morph:Ei.Node,intersection:xi.Node,divisor:Gn.Node,pattern:Mr.Node,predicate:Hn.Node,required:sa.Node,optional:Yr.Node,index:na.Node,sequence:fa.Node,structure:Oa.Node};var Ia=class extends se{get[T](){return`module`}};const La=(e,t)=>new Ia(_(e,(e,n)=>[e,E(n,`module`)?La(n,t):t.bindReference(n)]));const Ra=e=>y(e)?e:`branches`in e&&y(e.branches)?e.branches:void 0;const za=(e,t)=>h(`Node of kind ${t} is not valid as a ${e} definition`);const Ba=e=>`#${e} duplicates public alias ${e}`;const Va={};C.ambient??={};let Ha;const Ua=`function $`;const Wa=e=>Ga(e,Ka(e));const Ga=(e,t)=>{const n=t.write(Ua,4);const r=t.compile()();for(const t of e){if(t.precompilation)continue;t.traverseAllows=r[`${t.id}Allows`].bind(r);if(t.isRoot()&&!t.allowsRequiresContext)t.allows=t.traverseAllows;t.traverseApply=r[`${t.id}Apply`].bind(r);if(r[`${t.id}Optimistic`])t.traverseOptimistic=r[`${t.id}Optimistic`].bind(r);t.precompilation=n}};const Ka=e=>new jt().return(e.reduce((e,t)=>{const n=new It({kind:`Allows`}).indent();t.compile(n);const r=n.write(`${t.id}Allows`);const i=new It({kind:`Apply`}).indent();t.compile(i);const a=i.write(`${t.id}Apply`);const o=`${e}${r},\n${a},\n`;if(!t.hasKind(`union`))return o;const s=new It({kind:`Allows`,optimistic:true}).indent();t.compile(s);const c=s.write(`${t.id}Optimistic`);return`${o}${c},\n`},`{
`)+`}`);var qa=class{config;resolvedConfig;name;get[T](){return`scope`}referencesById={};references=[];resolutions={};exportedNames=[];aliases={};resolved=false;nodesByHash={};intrinsic;constructor(e,t){this.config=tn(C.config,t);this.resolvedConfig=tn(C.resolvedConfig,t);this.name=this.resolvedConfig.name??`anonymousScope${Object.keys(Va).length}`;if(this.name in Va)h(`A Scope already named ${this.name} already exists`);Va[this.name]=this;const n=Object.entries(e).map(e=>this.preparseOwnAliasEntry(...e));for(const[e,t]of n){let n=e;if(e[0]===`#`){n=e.slice(1);if(n in this.aliases)h(Ba(n));this.aliases[n]=t}else{if(n in this.aliases)h(Ba(e));this.aliases[n]=t;this.exportedNames.push(n)}if(!E(t,`module`)&&!E(t,`generic`)&&!Ne(t)){const e=this.preparseOwnDefinitionFormat(t,{alias:n});this.resolutions[n]=E(e,`root`)?this.bindReference(e):this.createParseContext(e).id}}Ha??=this.node(`union`,{branches:[`string`,`number`,`object`,`bigint`,`symbol`,{unit:true},{unit:false},{unit:void 0},{unit:null}]},{prereduced:true});this.nodesByHash[Ha.hash]=this.node(`intersection`,{},{prereduced:true});this.intrinsic=C.intrinsic?_(C.intrinsic,(e,t)=>e.startsWith(`json`)?[]:[e,this.bindReference(t)]):{}}cacheGetter(e,t){Object.defineProperty(this,e,{value:t});return t}get internal(){return this}_json;get json(){if(!this._json)this.export();return this._json}defineSchema(e){return e}generic=(...e)=>{const t=this;return(n,r)=>new Rn(e,r?new Ln(n):n,t,t,r??null)};units=(e,t)=>{const n=[];for(const t of e)if(!n.includes(t))n.push(t);const r=n.map(e=>this.node(`unit`,{unit:e},t));return this.node(`union`,r,{...t,prereduced:true})};lazyResolutions=[];lazilyResolve(e,t){const n=this.node(`alias`,{reference:t??`synthetic`,resolve:e},{prereduced:true});if(!this.resolved)this.lazyResolutions.push(n);return n}schema=(e,t)=>this.finalize(this.parseSchema(e,t));parseSchema=(e,t)=>this.node(Nr(e),e,t);preparseNode(e,t,n){let r=typeof e===`string`?e:Nr(t,e);if(D(t)&&t.kind===r)return t;if(r===`alias`&&!n?.prereduced){const{reference:e}=mi.implementation.normalize(t,this);if(e.startsWith(`$`)){const n=this.resolveRoot(e.slice(1));t=n;r=n.kind}}else if(r===`union`&&d(t,`object`)){const e=Ra(t);if(e?.length===1){t=e[0];r=Nr(t)}}if(D(t)&&t.kind===r)return t;const i=Pa[r];const a=i.normalize?.(t,this)??t;if(D(a))return a.kind===r?a:za(r,a.kind);return{...n,$:this,kind:r,def:a,prefix:n.alias??r}}bindReference(e){let t;if(D(e))t=e.$===this?e:new e.constructor(e.attachments,this);else t=e.$===this?e:new Rn(e.params,e.bodyDef,e.$,this,e.hkt);if(!this.resolved)Object.assign(this.referencesById,t.referencesById);return t}resolveRoot(e){return this.maybeResolveRoot(e)??h(to(e))}maybeResolveRoot(e){const t=this.maybeResolve(e);if(E(t,`generic`))return;return t}maybeResolveSubalias(e){return Za(this.aliases,e)??Za(this.ambient,e)}get ambient(){return C.ambient}maybeResolve(e){const t=this.resolutions[e];if(t){if(typeof t!==`string`)return this.bindReference(t);const n=L[t];if(E(n,`root`))return this.resolutions[e]=n;if(E(n,`context`)){if(n.phase===`resolving`)return this.node(`alias`,{reference:`$${e}`},{prereduced:true});if(n.phase===`resolved`)return m(`Unexpected resolved context for was uncached by its scope: ${x(n)}`);n.phase=`resolving`;const t=this.bindReference(this.parseOwnDefinitionFormat(n.def,n));n.phase=`resolved`;L[t.id]=t;L[n.id]=t;return this.resolutions[e]=t}return m(`Unexpected nodesById entry for ${t}: ${x(n)}`)}let n=this.aliases[e]??this.ambient?.[e];if(!n)return this.maybeResolveSubalias(e);n=this.normalizeRootScopeValue(n);if(E(n,`generic`))return this.resolutions[e]=this.bindReference(n);if(E(n,`module`)){if(!n.root)h(ro(e));return this.resolutions[e]=this.bindReference(n.root)}return this.resolutions[e]=this.parse(n,{alias:e})}createParseContext(e){const t=e.id??Rr(e.prefix);return L[t]=Object.assign(e,{[T]:`context`,$:this,id:t,phase:`unresolved`})}traversal(e){return new un(e,this.resolvedConfig)}import(...e){return new Ia(_(this.export(...e),(e,t)=>[`#${e}`,t]))}precompilation;_exportedResolutions;_exports;export(...e){if(!this._exports){this._exports={};for(const e of this.exportedNames){const t=this.aliases[e];this._exports[e]=E(t,`module`)?La(t,this):Ya(this.maybeResolve(e))}for(const e of this.lazyResolutions)e.resolution;this._exportedResolutions=eo(this,this._exports);this._json=Xa(this._exportedResolutions);Object.assign(this.resolutions,this._exportedResolutions);this.references=Object.values(this.referencesById);if(!this.resolvedConfig.jitless){const e=Ka(this.references);this.precompilation=e.write(Ua,4);Ga(this.references,e)}this.resolved=true}const t=e.length?e:this.exportedNames;return new Ia(_(t,(e,t)=>[t,this._exports[t]]))}resolve(e){return this.export()[e]}node=(e,t,n={})=>{const r=this.preparseNode(e,t,n);if(D(r))return this.bindReference(r);const i=this.createParseContext(r);const a=zr(i);const o=this.bindReference(a);return L[i.id]=o};parse=(e,t={})=>this.finalize(this.parseDefinition(e,t));parseDefinition(e,t={}){if(E(e,`root`))return this.bindReference(e);const n=this.preparseOwnDefinitionFormat(e,t);if(E(n,`root`))return this.bindReference(n);const r=this.createParseContext(n);L[r.id]=r;let i=this.bindReference(this.parseOwnDefinitionFormat(e,r));if(i.isCyclic)i=Vr(i,r.id);L[r.id]=i;return i}finalize(e){Ya(e);if(!e.precompilation&&!this.resolvedConfig.jitless)Wa(e.references);return e}};var Ja=class extends qa{parseOwnDefinitionFormat(e,t){return zr(t)}preparseOwnDefinitionFormat(e,t){return this.preparseNode(Nr(e),e,t)}preparseOwnAliasEntry(e,t){return[e,t]}normalizeRootScopeValue(e){return e}};const Ya=e=>{const t=e.references.filter(e=>e.hasKind(`alias`));for(const n of t){Object.assign(n.referencesById,n.resolution.referencesById);for(const t of e.references)if(n.id in t.referencesById)Object.assign(t.referencesById,n.referencesById)}return e};const Xa=e=>_(e,(e,t)=>[e,E(t,`root`)||E(t,`generic`)?t.json:E(t,`module`)?Xa(t):m(`Unexpected resolution ${x(t)}`)]);const Za=(e,t)=>{const n=t.indexOf(`.`);if(n===-1)return;const r=t.slice(0,n);const i=e[r];if(i===void 0)return;if(!E(i,`module`))return h(no(r));const a=t.slice(n+1);const o=i[a];if(o===void 0)return Za(i,a);if(E(o,`root`)||E(o,`generic`))return o;if(E(o,`module`))return o.root??h(ro(t));m(`Unexpected resolution for alias '${t}': ${x(o)}`)};const Qa=(e,t)=>new Ja(e,t);const $a=new Ja({});const eo=(e,t)=>{const n={};for(const r in t){const i=t[r];if(E(i,`module`)){const t=eo(e,i);const a=_(t,(e,t)=>[`${r}.${e}`,t]);Object.assign(n,a)}else if(E(i,`root`)||E(i,`generic`))n[r]=i;else m(`Unexpected scope resolution ${x(i)}`)}return n};const to=e=>`'${e}' is unresolvable`;const no=e=>`'${e}' must reference a module to be accessed using dot syntax`;const ro=e=>`Reference to submodule '${e}' must specify an alias`;$a.export();const z=$a.schema;const io=$a.node;const ao=$a.defineSchema;const B=$a.generic;const oo=`^(?:0|[1-9]\\d*)$`;const so=new RegExp(oo);const co=w(so);const lo=Qa({bigint:`bigint`,boolean:[{unit:false},{unit:true}],false:{unit:false},never:[],null:{unit:null},number:`number`,object:`object`,string:`string`,symbol:`symbol`,true:{unit:true},unknown:{},undefined:{unit:void 0},Array,Date},{prereducedAliases:true}).export();C.intrinsic={...lo};const uo=Qa({integer:{domain:`number`,divisor:1},lengthBoundable:[`string`,Array],key:[`string`,`symbol`],nonNegativeIntegerString:{domain:`string`,pattern:oo}},{prereducedAliases:true}).export();Object.assign(C.intrinsic,uo);const fo=Qa({jsonPrimitive:[`string`,`number`,{unit:true},{unit:false},{unit:null}],jsonObject:{domain:`object`,index:{signature:`string`,value:`$jsonData`}},jsonData:[`$jsonPrimitive`,`$jsonObject`]},{prereducedAliases:true}).export();const V={...lo,...uo,...fo,emptyStructure:io(`structure`,{},{prereduced:true})};C.intrinsic={...V};const po=e=>Array.isArray(e)?e:[e];const H=(e,t,n)=>{if(e===void 0)return t===void 0?[]:Array.isArray(t)?t:[t];if(n?.prepend)if(Array.isArray(t))e.unshift(...t);else e.unshift(t);else if(Array.isArray(t))e.push(...t);else e.push(t);return e};const mo=(e,t)=>U(e)===t;const U=e=>{const t=typeof e;return t===`object`?e===null?`null`:`object`:t===`function`?`object`:t};const ho={boolean:`boolean`,null:`null`,undefined:`undefined`,bigint:`a bigint`,number:`a number`,object:`an object`,string:`a string`,symbol:`a symbol`};const go={...ho,function:`a function`};var _o=class extends Error{};const vo=e=>yo(e,_o);const yo=(e,t=Error)=>{throw new t(e)};var bo=class extends Error{name=`ParseError`};const W=e=>yo(e,bo);const xo=e=>` ${e}`;const So=(e,t)=>{const n={};const r=Array.isArray(e);let i=false;for(const[a,o]of Object.entries(e).entries()){const e=r?t(a,o[1]):t(...o,a);i||=typeof e[0]===`number`;const s=Array.isArray(e[0])||e.length===0?e:[e];for(const[e,t]of s)if(typeof e===`object`)n[e.group]=H(n[e.group],t);else n[e]=t}return i?Object.values(n):n};const Co=(e,t)=>e in t;const wo=class{};const To=e=>Object.keys(e).length===0;const Eo=e=>[...Object.entries(e),...Object.getOwnPropertySymbols(e).map(t=>[t,e[t]])];const Do=xo(`represents an uninitialized value`);const Oo=e=>Object.values(e).filter(t=>{if(typeof t===`number`)return true;return typeof e[t]!==`number`});const ko={Array,Boolean,Date,Error,Function,Map,Number,Promise,RegExp,Set,String,WeakMap,WeakSet};const Ao=globalThis.File??Blob;const jo={ArrayBuffer,Blob,File:Ao,FormData,Headers,Request,Response,URL};const Mo={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array};const No={...ko,...jo,...Mo,String,Number,Boolean};const Po=e=>{let t=Object.getPrototypeOf(e);while(t?.constructor&&(!Co(t.constructor.name,No)||!(e instanceof No[t.constructor.name])))t=Object.getPrototypeOf(t);const n=t?.constructor?.name;if(n===void 0||n===`Object`)return void 0;return n};const Fo=e=>typeof e===`object`&&e!==null?Po(e)??`object`:U(e);const Io=Array.isArray;const Lo={Array:`an array`,Function:`a function`,Date:`a Date`,RegExp:`a RegExp`,Error:`an Error`,Map:`a Map`,Set:`a Set`,String:`a String object`,Number:`a Number object`,Boolean:`a Boolean object`,Promise:`a Promise`,WeakMap:`a WeakMap`,WeakSet:`a WeakSet`};const Ro={ArrayBuffer:`an ArrayBuffer instance`,Blob:`a Blob instance`,File:`a File instance`,FormData:`a FormData instance`,Headers:`a Headers instance`,Request:`a Request instance`,Response:`a Response instance`,URL:`a URL instance`};const zo={Int8Array:`an Int8Array`,Uint8Array:`a Uint8Array`,Uint8ClampedArray:`a Uint8ClampedArray`,Int16Array:`an Int16Array`,Uint16Array:`a Uint16Array`,Int32Array:`an Int32Array`,Uint32Array:`a Uint32Array`,Float32Array:`a Float32Array`,Float64Array:`a Float64Array`,BigInt64Array:`a BigInt64Array`,BigUint64Array:`a BigUint64Array`};const Bo={...Lo,...Ro,...zo};const Vo=e=>{let t=Object.getPrototypeOf(e);const n=[];while(t!==null){n.push(t.constructor);t=Object.getPrototypeOf(t)}return n};const Ho=e=>{let t=Do;return()=>t===Do?t=e():t};const Uo=e=>typeof e===`function`&&e.length===0;var Wo=class{constructor(e,...[t]){return Object.assign(Object.setPrototypeOf(e.bind(t?.bind??this),this.constructor.prototype),t?.attach)}};const Go=Ho(()=>{try{return new Function(`return false`)()}catch{return true}});const Ko=xo(`brand`);const qo=xo(`arkInferred`);const Jo=xo(`args`);var G=class{constructor(){}};const Yo=()=>{try{const e=new Error;const t=e.stack?.split(`
`)[2]?.trim()||``;const n=t.match(/\(?(.+?)(?::\d+:\d+)?\)?$/)?.[1]||`unknown`;return n.replace(/^file:\/\//,``)}catch{return`unknown`}};const Xo=globalThis.process?.env??{};const Zo={fileName:Yo,env:Xo};const Qo=e=>new RegExp($o(e),typeof e===`string`?``:e.flags);const $o=e=>{const t=typeof e===`string`?e:e.source;return`^(?:${t})$`};const K={negativeLookahead:e=>`(?!${e})`,nonCapturingGroup:e=>`(?:${e})`};const es=`\\`;const ts={" ":1,"\n":1,"	":1};const ns=/^-0\.?0*$/.source;const rs=/[1-9]\d*/.source;const os=/\.\d+/.source;const ss=/\.\d*[1-9]/.source;const cs=e=>Qo(K.negativeLookahead(ns)+K.nonCapturingGroup(`-?`+K.nonCapturingGroup(K.nonCapturingGroup(`0|`+rs)+K.nonCapturingGroup(e.decimalPattern)+`?`)+(e.allowDecimalOnly?`|`+e.decimalPattern:``)+`?`));const ls=cs({decimalPattern:ss,allowDecimalOnly:false});const us=ls.test.bind(ls);const ds=cs({decimalPattern:os,allowDecimalOnly:true});const fs=ds.test.bind(ds);const ps=/^-?\d*\.?\d*$/;const ms=e=>e.length!==0&&ps.test(e);const hs=Qo(K.negativeLookahead(`^-0$`)+`-?`+K.nonCapturingGroup(K.nonCapturingGroup(`0|`+rs)));const gs=hs.test.bind(hs);const _s=/^-?\d+$/;const vs=_s.test.bind(_s);const ys={number:`a number`,bigint:`a bigint`,integer:`an integer`};const bs=(e,t)=>`'${e}' was parsed as ${ys[t]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;const xs=(e,t)=>t===`number`?us(e):gs(e);const Ss=(e,t)=>t===`number`?Number(e):Number.parseInt(e);const Cs=(e,t)=>t===`number`?ms(e):vs(e);const ws=(e,t)=>Ds(e,`number`,t);const Ts=(e,t)=>Ds(e,`number`,{...t,strict:true});const Es=(e,t)=>Ds(e,`integer`,t);const Ds=(e,t,n)=>{const r=Ss(e,t);if(!Number.isNaN(r)){if(Cs(e,t)){if(n?.strict)return xs(e,t)?r:W(bs(e,t));return r}}return n?.errorOnFail?W(n?.errorOnFail===true?`Failed to parse ${ys[t]} from '${e}'`:n?.errorOnFail):void 0};const Os=e=>{if(e[e.length-1]!==`n`)return;const t=e.slice(0,-1);let n;try{n=BigInt(t)}catch{return}if(hs.test(t))return n;if(_s.test(t))return W(bs(e,`bigint`))};const ks=`0.46.0`;const As={version:ks,filename:Zo.fileName(),FileConstructor:Ao};const js=As;const Ms=new Map;const Ns=Object.create(null);const Ps=e=>{const t=Ms.get(e);if(t)return t;let n=Is(e);if(Ns[n])n=`${n}${Ns[n]++}`;else Ns[n]=1;js[n]=e;Ms.set(e,n);return n};const Fs=e=>/^[$A-Z_a-z][\w$]*$/.test(e);const Is=e=>{switch(typeof e){case`object`:{if(e===null)break;const t=Po(e)??`object`;return t[0].toLowerCase()+t.slice(1)}case`function`:return Fs(e.name)?e.name:`fn`;case`symbol`:return e.description&&Fs(e.description)?e.description:`symbol`}return vo(`Unexpected attempt to register serializable value of type ${U(e)}`)};const Ls=e=>typeof e===`string`?JSON.stringify(e):typeof e===`bigint`?`${e}n`:`${e}`;const Rs=(e,t)=>{switch(U(e)){case`object`:const n=e;const r=n.constructor.name;return r===`Object`||r===`Array`?t?.quoteKeys===false?zs(n,t?.indent??0,``):JSON.stringify(Bs(n,q,[]),null,t?.indent):zs(n,t?.indent??0,``);case`symbol`:return q.onSymbol(e);default:return Ls(e)}};const zs=(e,t,n)=>{if(typeof e===`function`)return q.onFunction(e);if(typeof e!==`object`||e===null)return Ls(e);const r=n+` `.repeat(t);if(Array.isArray(e)){if(e.length===0)return`[]`;const i=e.map(e=>zs(e,t,r)).join(`,
`+r);return t?`[\n${r}${i}\n${n}]`:`[${i}]`}const i=e.constructor.name;if(i===`Object`){const i=Eo(e).map(([e,n])=>{const i=typeof e===`symbol`?q.onSymbol(e):Fs(e)?e:JSON.stringify(e);const a=zs(n,t,r);return`${r}${i}: ${a}`});if(i.length===0)return`{}`;return t?`{\n${i.join(`,
`)}\n${n}}`:`{${i.join(`, `)}}`}if(e instanceof Date)return Vs(e);if(`expression`in e&&typeof e.expression===`string`)return e.expression;return i};const q={onCycle:()=>`(cycle)`,onSymbol:e=>`Symbol(${Ps(e)})`,onFunction:e=>`Function(${Ps(e)})`};const Bs=(e,t,n)=>{switch(U(e)){case`object`:{const r=e;if(`toJSON`in r&&typeof r.toJSON===`function`)return r.toJSON();if(typeof r===`function`)return q.onFunction(r);if(n.includes(r))return`(cycle)`;const i=[...n,r];if(Array.isArray(r))return r.map(e=>Bs(e,t,i));if(r instanceof Date)return r.toDateString();const a={};for(const e in r)a[e]=Bs(r[e],t,i);for(const e of Object.getOwnPropertySymbols(r))a[t.onSymbol?.(e)??e.toString()]=Bs(r[e],t,i);return a}case`symbol`:return q.onSymbol(e);case`bigint`:return t.onBigInt?.(e)??`${e}n`;case`undefined`:return t.onUndefined??`undefined`;case`string`:return e.replaceAll(`\\`,`\\\\`);default:return e}};const Vs=e=>{const t=e.getFullYear();const n=e.getMonth();const r=e.getDate();const i=e.getHours();const a=e.getMinutes();const o=e.getSeconds();const s=e.getMilliseconds();if(n===0&&r===1&&i===0&&a===0&&o===0&&s===0)return`${t}`;const c=`${Hs[n]} ${r}, ${t}`;if(i===0&&a===0&&o===0&&s===0)return c;let l=e.toLocaleTimeString();const u=l.endsWith(` AM`)||l.endsWith(` PM`)?l.slice(-3):``;if(u)l=l.slice(0,-u.length);if(s)l+=`.${Ws(s,3)}`;else if(Us.test(l))l=l.slice(0,-3);return`${l+u}, ${c}`};const Hs=[`January`,`February`,`March`,`April`,`May`,`June`,`July`,`August`,`September`,`October`,`November`,`December`];const Us=/:\d\d:00$/;const Ws=(e,t)=>String(e).padStart(t,`0`);var Gs=class{chars;i;def;constructor(e){this.def=e;this.chars=[...e];this.i=0}shift(){return this.chars[this.i++]??``}get lookahead(){return this.chars[this.i]??``}get nextLookahead(){return this.chars[this.i+1]??``}get length(){return this.chars.length}shiftUntil(e){let t=``;while(this.lookahead){if(e(this,t))if(t[t.length-1]===es)t=t.slice(0,-1);else break;t+=this.shift()}return t}shiftUntilLookahead(e){return typeof e===`string`?this.shiftUntil(t=>t.lookahead===e):this.shiftUntil(t=>t.lookahead in e)}shiftUntilNonWhitespace(){return this.shiftUntil(()=>!(this.lookahead in ts))}jumpToIndex(e){this.i=e<0?this.length+e:e}jumpForward(e){this.i+=e}get location(){return this.i}get unscanned(){return this.chars.slice(this.i,this.length).join(``)}get scanned(){return this.chars.slice(0,this.i).join(``)}sliceChars(e,t){return this.chars.slice(e,t).join(``)}lookaheadIs(e){return this.lookahead===e}lookaheadIsIn(e){return this.lookahead in e}};const Ks=xo(`implementedTraits`);const qs=e=>t=>{if(!mo(t,`object`))return false;if(Ks in t.constructor&&t.constructor[Ks].includes(e))return true;return Vo(t).includes(e)};var Js=class extends wo{static get[Symbol.hasInstance](){return qs(this)}traitsOf(){return Ks in this.constructor?this.constructor[Ks]:[]}};const Ys=e=>typeof e===`string`&&e[0]===`d`&&(e[1]===`'`||e[1]===`"`)&&e.at(-1)===e[1];const Xs=e=>e.toString()!==`Invalid Date`;const Zs=e=>e.slice(2,-1);const Qs=e=>`'${e}' could not be parsed by the Date constructor`;const $s=(e,t)=>ec(e,t);const ec=(e,t)=>{const n=new Date(e);if(Xs(n))return n;const r=ws(e);if(r!==void 0){const e=new Date(r);if(Xs(e))return e}return t?W(t===true?Qs(e):t):void 0};const tc=(e,t)=>{const n=e.scanner.shiftUntil(ac[ic[t]]);if(e.scanner.lookahead===``)return e.error(sc(n,t));e.scanner.shift();if(t===`/`){try{new RegExp(n)}catch(e){W(String(e))}e.root=e.ctx.$.node(`intersection`,{domain:`string`,pattern:n},{prereduced:true})}else if(Co(t,nc))e.root=e.ctx.$.node(`unit`,{unit:n});else{const t=$s(n,Qs(n));e.root=e.ctx.$.node(`unit`,{meta:n,unit:t})}};const nc={"'":1,'"':1};const rc={"/":1,"'":1,'"':1};const ic={"d'":`'`,'d"':`"`,"'":`'`,'"':`"`,"/":`/`};const ac={"'":e=>e.lookahead===`'`,'"':e=>e.lookahead===`"`,"/":e=>e.lookahead===`/`};const oc={'"':`double-quote`,"'":`single-quote`,"/":`forward slash`};const sc=(e,t)=>`${t}${e} requires a closing ${oc[ic[t]]}`;const cc=e=>`Private type references should not include '#'. Use '${e}' instead.`;const lc=`Optional definitions like 'string?' are only valid as properties in an object or tuple`;const uc=`Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple`;const dc={">":true,">=":true};const fc={"<":true,"<=":true};const pc={"<":`>`,">":`<`,"<=":`>=`,">=":`<=`,"==":`==`};const mc=e=>`Unmatched )${e===``?``:` before ${e}`}`;const hc=e=>`Missing ${e}`;const gc=(e,t)=>`Left bounds are only valid when paired with right bounds (try ...${t}${e})`;const _c=e=>`Left-bounded expressions must specify their limits using < or <= (was ${e})`;const vc=(e,t,n,r)=>`An expression may have at most one left bound (parsed ${e}${pc[t]}, ${n}${pc[r]})`;const yc=(e,t,n)=>bc(e,t,n,[]);const bc=(e,t,n,r)=>{const i=n.parseUntilFinalizer();r.push(i.root);if(i.finalizer===`>`){if(r.length!==t.params.length)return n.error(xc(e,t.names,r.map(e=>e.expression)));return r}if(i.finalizer===`,`)return bc(e,t,n,r);return i.error(hc(`>`))};const xc=(e,t,n)=>`${e}<${t.join(`, `)}> requires exactly ${t.length} args (got ${n.length}${n.length===0?``:`: ${n.join(`, `)}`})`;const Sc=e=>{const t=e.scanner.shiftUntilNextTerminator();if(t===`keyof`)e.addPrefix(`keyof`);else e.root=wc(e,t)};const Cc=(e,t,n)=>{n.scanner.shiftUntilNonWhitespace();const r=n.scanner.shift();if(r!==`<`)return n.error(xc(e,t.names,[]));const i=yc(e,t,n);return t(...i)};const wc=(e,t)=>Tc(e,t)??Ec(e,t)??e.error(t===``?e.scanner.lookahead===`#`?cc(e.shiftedByOne().scanner.shiftUntilNextTerminator()):Dc(e):to(t));const Tc=(e,t)=>{if(e.ctx.args?.[t]){const n=e.ctx.args[t];if(typeof n!==`string`)return n;return e.ctx.$.node(`alias`,{reference:n},{prereduced:true})}const n=e.ctx.$.maybeResolve(t);if(E(n,`root`))return n;if(n===void 0)return;if(E(n,`generic`))return Cc(t,n,e);return W(`Unexpected resolution ${Rs(n)}`)};const Ec=(e,t)=>{const n=Ts(t);if(n!==void 0)return e.ctx.$.node(`unit`,{unit:n});const r=Os(t);if(r!==void 0)return e.ctx.$.node(`unit`,{unit:r})};const Dc=e=>{const t=e.previousOperator();return t?Oc(t,e.scanner.unscanned):kc(e.scanner.unscanned)};const Oc=(e,t=``)=>`Token '${e}' requires a right operand${t?` before '${t}'`:``}`;const kc=e=>`Expected an expression${e?` before '${e}'`:``}`;const Ac=e=>e.scanner.lookahead===``?e.error(Dc(e)):e.scanner.lookahead===`(`?e.shiftedByOne().reduceGroupOpen():e.scanner.lookaheadIsIn(rc)?tc(e,e.scanner.shift()):e.scanner.lookaheadIsIn(ts)?Ac(e.shiftedByOne()):e.scanner.lookahead===`d`?e.scanner.nextLookahead in nc?tc(e,`${e.scanner.shift()}${e.scanner.shift()}`):Sc(e):Sc(e);var jc=class e extends Gs{shiftUntilNextTerminator(){this.shiftUntilNonWhitespace();return this.shiftUntil(()=>this.lookahead in e.terminatingChars)}static terminatingChars={"<":1,">":1,"=":1,"|":1,"&":1,")":1,"[":1,"%":1,",":1,":":1,"?":1,"#":1,...ts};static finalizingLookaheads={">":1,",":1,"":1,"=":1,"?":1};static lookaheadIsFinalizing=(t,n)=>t===`>`?n[0]===`=`?n[1]===`=`:n.trimStart()===``||Co(n.trimStart()[0],e.terminatingChars):t===`=`?n[0]!==`=`:t===`,`||t===`?`};const Mc=(e,t)=>{const n=Pc(e,t);if(e.root.hasKind(`unit`)){if(typeof e.root.unit===`number`){e.reduceLeftBound(e.root.unit,n);e.unsetRoot();return}if(e.root.unit instanceof Date){const t=`d'${e.root.description??e.root.unit.toISOString()}'`;e.unsetRoot();e.reduceLeftBound(t,n);return}}return Lc(e,n)};const Nc={"<":1,">":1,"=":1};const Pc=(e,t)=>e.scanner.lookaheadIs(`=`)?`${t}${e.scanner.shift()}`:t;const Fc=(e,t,n,r)=>{if(n.extends(C.intrinsic.number)){if(typeof t!==`number`)return W(Rc(e,t,r));return e===`==`?[`min`,`max`]:e[0]===`>`?[`min`]:[`max`]}if(n.extends(C.intrinsic.lengthBoundable)){if(typeof t!==`number`)return W(Rc(e,t,r));return e===`==`?[`exactLength`]:e[0]===`>`?[`minLength`]:[`maxLength`]}if(n.extends(C.intrinsic.Date))return e===`==`?[`after`,`before`]:e[0]===`>`?[`after`]:[`before`];return W(or(n.expression))};const Ic=e=>({rule:Ys(e.limit)?Zs(e.limit):e.limit,exclusive:e.comparator.length===1});const Lc=(e,t)=>{const n=e.unsetRoot();const r=e.scanner.location;e.parseOperand();const i=e.unsetRoot();const a=e.scanner.sliceChars(r,e.scanner.location);e.root=n;if(!i.hasKind(`unit`)||typeof i.unit!==`number`&&!(i.unit instanceof Date))return e.error(Rc(t,a,`right`));const o=i.unit;const s=t.length===1;const c=Fc(t,typeof o===`number`?o:a,n,`right`);for(const n of c)e.constrainRoot(n,t===`==`?{rule:o}:{rule:o,exclusive:s});if(!e.branches.leftBound)return;if(!Co(t,fc))return e.error(_c(t));const l=Fc(e.branches.leftBound.comparator,e.branches.leftBound.limit,n,`left`);e.constrainRoot(l[0],Ic(e.branches.leftBound));e.branches.leftBound=null};const Rc=(e,t,n)=>`Comparator ${n===`left`?pc[e]:e} must be ${n===`left`?`preceded`:`followed`} by a corresponding literal (was ${t})`;const zc=e=>{e.scanner.shiftUntilNonWhitespace();const t=e.scanner.shiftUntilNextTerminator();e.root=e.root.brand(t)};const Bc=e=>{const t=e.scanner.shiftUntilNextTerminator();const n=Es(t,{errorOnFail:Vc(t)});if(n===0)e.error(Vc(0));e.root=e.root.constrain(`divisor`,n)};const Vc=e=>`% operator must be followed by a non-zero integer literal (was ${e})`;const Hc=e=>{const t=e.scanner.shift();return t===``?e.finalize(``):t===`[`?e.scanner.shift()===`]`?e.setRoot(e.root.array()):e.error(Wc):t===`|`?e.scanner.lookahead===`>`?e.shiftedByOne().pushRootToBranch(`|>`):e.pushRootToBranch(t):t===`&`?e.pushRootToBranch(t):t===`)`?e.finalizeGroup():jc.lookaheadIsFinalizing(t,e.scanner.unscanned)?e.finalize(t):Co(t,Nc)?Mc(e,t):t===`%`?Bc(e):t===`#`?zc(e):t in ts?Hc(e):e.error(Uc(t))};const Uc=(e,t=``)=>`'${e}' is not allowed here${t&&` (should be ${t})`}`;const Wc=`Missing expected ']'`;const Gc=e=>{const t=e.unsetRoot();e.parseOperand();const n=e.unsetRoot();if(!n.hasKind(`unit`))return e.error(Kc(n.expression));const r=n.unit instanceof Date?()=>new Date(n.unit):n.unit;return[t,`=`,r]};const Kc=e=>`Default value '${e}' must a literal value`;const qc=(e,t)=>{const n=t.$.maybeResolveRoot(e);if(n)return n;if(e.endsWith(`[]`)){const n=t.$.maybeResolveRoot(e.slice(0,-2));if(n)return n.array()}const r=new Zc(new jc(e),t);const i=Jc(r);if(r.finalizer===`>`)W(Uc(`>`));return i};const Jc=e=>{e.parseOperand();let t=Yc(e).root;if(!t)return vo(`Root was unexpectedly unset after parsing string '${e.scanner.scanned}'`);if(e.finalizer===`=`)t=Gc(e);else if(e.finalizer===`?`)t=[t,`?`];e.scanner.shiftUntilNonWhitespace();if(e.scanner.lookahead)W(Uc(e.scanner.lookahead));return t};const Yc=e=>{while(e.finalizer===void 0)Xc(e);return e};const Xc=e=>e.hasRoot()?e.parseOperator():e.parseOperand();var Zc=class e{root;branches={prefixes:[],leftBound:null,intersection:null,union:null,pipe:null};finalizer;groups=[];scanner;ctx;constructor(e,t){this.scanner=e;this.ctx=t}error(e){return W(e)}hasRoot(){return this.root!==void 0}setRoot(e){this.root=e}unsetRoot(){const e=this.root;this.root=void 0;return e}constrainRoot(...e){this.root=this.root.constrain(e[0],e[1])}finalize(e){if(this.groups.length)return this.error(hc(`)`));this.finalizeBranches();this.finalizer=e}reduceLeftBound(e,t){const n=pc[t];if(!Co(n,dc))return this.error(_c(t));if(this.branches.leftBound)return this.error(vc(this.branches.leftBound.limit,this.branches.leftBound.comparator,e,n));this.branches.leftBound={comparator:n,limit:e}}finalizeBranches(){this.assertRangeUnset();if(this.branches.pipe){this.pushRootToBranch(`|>`);this.root=this.branches.pipe;return}if(this.branches.union){this.pushRootToBranch(`|`);this.root=this.branches.union;return}if(this.branches.intersection){this.pushRootToBranch(`&`);this.root=this.branches.intersection;return}this.applyPrefixes()}finalizeGroup(){this.finalizeBranches();const e=this.groups.pop();if(!e)return this.error(mc(this.scanner.unscanned));this.branches=e}addPrefix(e){this.branches.prefixes.push(e)}applyPrefixes(){while(this.branches.prefixes.length){const e=this.branches.prefixes.pop();this.root=e===`keyof`?this.root.keyof():vo(`Unexpected prefix '${e}'`)}}pushRootToBranch(e){this.assertRangeUnset();this.applyPrefixes();const t=this.root;this.root=void 0;this.branches.intersection=this.branches.intersection?.rawAnd(t)??t;if(e===`&`)return;this.branches.union=this.branches.union?.rawOr(this.branches.intersection)??this.branches.intersection;this.branches.intersection=null;if(e===`|`)return;this.branches.pipe=this.branches.pipe?.rawPipeOnce(this.branches.union)??this.branches.union;this.branches.union=null}parseUntilFinalizer(){return Yc(new e(this.scanner,this.ctx))}parseOperator(){return Hc(this)}parseOperand(){return Ac(this)}assertRangeUnset(){if(this.branches.leftBound)return this.error(gc(this.branches.leftBound.limit,this.branches.leftBound.comparator))}reduceGroupOpen(){this.groups.push(this.branches);this.branches={prefixes:[],leftBound:null,union:null,intersection:null,pipe:null}}previousOperator(){return this.branches.leftBound?.comparator??this.branches.prefixes.at(-1)??(this.branches.intersection?`&`:this.branches.union?`|`:this.branches.pipe?`|>`:void 0)}shiftedByOne(){this.scanner.shift();return this}};const Qc=`An empty string is not a valid generic parameter name`;const $c=(e,t,n)=>{e.shiftUntilNonWhitespace();const r=e.shiftUntilNextTerminator();if(r===``){if(e.lookahead===``&&t.length)return t;return W(Qc)}e.shiftUntilNonWhitespace();return tl(e,r,t,n)};const el=`extends `;const tl=(e,t,n,r)=>{e.shiftUntilNonWhitespace();if(e.unscanned.startsWith(el))e.jumpForward(8);else{if(e.lookahead===`,`)e.shift();n.push(t);return $c(e,n,r)}const i=Yc(new Zc(e,r));n.push([t,i.root]);return $c(e,n,r)};var nl=class extends Wo{$;constructor(e){super((...t)=>new rl(e)(...t),{bind:e});this.$=e}in(e){return new rl(this.$,e===void 0?void 0:this.$.parse(e))}at(e,t){return new rl(this.$).at(e,t)}case(e,t){return new rl(this.$).case(e,t)}};var rl=class extends Wo{$;in;key;branches=[];constructor(e,t){super(e=>this.caseEntries(Object.entries(e).map(([e,t])=>e===`default`?[e,t]:[this.$.parse(e),t])));this.$=e;this.in=t}at(e,t){if(this.key)W(ol);if(this.branches.length)W(al);this.key=e;return t?this.match(t):this}case(e,t){return this.caseEntry(this.$.parse(e),t)}caseEntry(e,t){const n=this.key?this.$.parse({[this.key]:e}):e;const r=n.pipe(t);this.branches.push(r);return this}match(e){return this(e)}strings(e){return this.caseEntries(Object.entries(e).map(([e,t])=>e===`default`?[e,t]:[this.$.node(`unit`,{unit:e}),t]))}caseEntries(e){for(let t=0;t<e.length;t++){const[n,r]=e[t];if(n===`default`){if(t!==e.length-1)W(`default may only be specified as the last key of a switch definition`);return this.default(r)}if(typeof r!==`function`)return W(`Value for case "${n}" must be a function (was ${U(r)})`);this.caseEntry(n,r)}return this}default(e){if(typeof e===`function`)this.case(V.unknown,e);const t={branches:this.branches,ordered:true};if(e===`never`||e===`assert`)t.meta={onFail:il};const n=this.$.node(`union`,t);if(!this.in)return this.$.finalize(n);let r=this.in.pipe(n);if(e===`never`||e===`assert`)r=r.configureReferences({onFail:il},`self`);return this.$.finalize(r)}};const il=e=>e.throw();const al=`A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')`;const ol=`At most one key matcher may be specified per expression`;const sl=(e,t)=>{if(Io(e)){if(e[1]===`=`)return[t.$.parseOwnDefinitionFormat(e[0],t),`=`,e[2]];if(e[1]===`?`)return[t.$.parseOwnDefinitionFormat(e[0],t),`?`]}return Gl(e,t)};const cl=`Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }`;const ll=`Only required keys may specify default values, e.g. { value: 'number = 0' }`;const ul=(e,t)=>{let n;const r={};const i=Eo(e);for(const[e,a]of i){const i=ml(e);if(i.kind===`spread`){if(!To(r))return W(pl);const e=t.$.parseOwnDefinitionFormat(a,t);if(e.equals(V.object))continue;if(!e.hasKind(`intersection`)||!e.basis?.equals(V.object))return W(hl(e.expression));n=e.structure;continue}if(i.kind===`undeclared`){if(a!==`reject`&&a!==`delete`&&a!==`ignore`)W(fl(a));r.undeclared=a;continue}const o=sl(a,t);const s=i;if(i.kind===`required`){if(!Io(o))dl(r,`required`,{key:i.normalized,value:o},t);else dl(r,`optional`,o[1]===`=`?{key:i.normalized,value:o[0],default:o[2]}:{key:i.normalized,value:o[0]},t);continue}if(Io(o)){if(o[1]===`?`)W(cl);if(o[1]===`=`)W(ll)}if(i.kind===`optional`){dl(r,`optional`,{key:i.normalized,value:o},t);continue}const c=t.$.parseOwnDefinitionFormat(s.normalized,t);const l=ja(c,o,t.$);if(l.index)r.index=H(r.index,l.index);if(l.required)r.required=H(r.required,l.required)}const a=t.$.node(`structure`,r);return t.$.parseSchema({domain:`object`,structure:n?.merge(a)??a})};const dl=(e,t,n,r)=>{e[t]=H(e[t],r.$.node(t,n))};const fl=e=>`Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${Rs(e)})`;const pl=`Spread operator may only be used as the first key in an object`;const ml=e=>typeof e===`symbol`?{kind:`required`,normalized:e}:e.at(-1)===`?`?e.at(-2)===es?{kind:`required`,normalized:`${e.slice(0,-2)}?`}:{kind:`optional`,normalized:e.slice(0,-1)}:e[0]===`[`&&e.at(-1)===`]`?{kind:`index`,normalized:e.slice(1,-1)}:e[0]===es&&e[1]===`[`&&e.at(-1)===`]`?{kind:`required`,normalized:e.slice(1)}:e===`...`?{kind:`spread`}:e===`+`?{kind:`undeclared`}:{kind:`required`,normalized:e===`\\...`?`...`:e===`\\+`?`+`:e};const hl=e=>`Spread operand must resolve to an object literal type (was ${e})`;const gl=(e,t)=>jl(e)?Al[e[0]](e,t):Ol(e)?Dl[e[1]](e,t):null;const _l=(e,t)=>t.$.parseOwnDefinitionFormat(e[1],t).keyof();const vl=(e,t)=>{if(e[2]===void 0)return W(Oc(e[1],``));const n=t.$.parseOwnDefinitionFormat(e[0],t);const r=t.$.parseOwnDefinitionFormat(e[2],t);if(e[1]===`|`)return t.$.node(`union`,{branches:[n,r]});const i=e[1]===`&`?P(n,r,t.$):wn(n,r,t.$);if(i instanceof N)return i.throw();return i};const yl=(e,t)=>t.$.parseOwnDefinitionFormat(e[0],t).array();const bl=(e,t)=>{if(typeof e[2]!==`function`)return W(xl(`=>`,e[2]));return t.$.parseOwnDefinitionFormat(e[0],t).pipe(e[2])};const xl=(e,t)=>`${e===`:`?`Narrow`:`Morph`} expression requires a function following '${e}' (was ${typeof t})`;const Sl=(e,t)=>{if(typeof e[2]!==`function`)return W(xl(`:`,e[2]));return t.$.parseOwnDefinitionFormat(e[0],t).constrain(`predicate`,e[2])};const Cl=(e,t)=>t.$.parseOwnDefinitionFormat(e[0],t).configureReferences(e[2],`shallow`);const wl=e=>e;const Tl=wl({"[]":yl,"?":()=>W(lc)});const El=wl({"|":vl,"&":vl,":":Sl,"=>":bl,"|>":vl,"@":Cl,"=":()=>W(uc)});const Dl={...Tl,...El};const Ol=e=>Dl[e[1]]!==void 0;const kl=e=>e;const Al=kl({keyof:_l,instanceof:(e,t)=>{if(typeof e[1]!==`function`)return W(Ml(Fo(e[1])));const n=e.slice(1).map(e=>typeof e===`function`?t.$.node(`proto`,{proto:e}):W(Ml(Fo(e))));return n.length===1?n[0]:t.$.node(`union`,{branches:n})},"===":(e,t)=>t.$.units(e.slice(1))});const jl=e=>Al[e[0]]!==void 0;const Ml=e=>`Expected a constructor following 'instanceof' operator (was ${e})`;const Nl=(e,t)=>{let n=[{}];let r=0;while(r<e.length){let i=false;if(e[r]===`...`&&r<e.length-1){i=true;r++}const a=sl(e[r],t);const[o,s,c]=!Io(a)?[a]:a;r++;if(i){if(!o.extends(C.intrinsic.Array))return W(zl(o.expression));n=n.flatMap(e=>o.distribute(t=>Rl(Lt(e),t)))}else n=n.map(e=>{if(s===`?`)return Fl(e,o);if(s===`=`)return Il(e,o,c);return Pl(e,o)})}return t.$.parseSchema(n.map(e=>To(e)?{proto:Array,exactLength:0}:{proto:Array,sequence:e}))};const Pl=(e,t)=>{if(e.defaultables||e.optionals)return W(e.variadic?ha:Vl);if(e.variadic)e.postfix=H(e.postfix,t);else e.prefix=H(e.prefix,t);return e};const Fl=(e,t)=>{if(e.variadic)return W(Hl);e.optionals=H(e.optionals,t);return e};const Il=(e,t,n)=>{if(e.variadic)return W(Hl);if(e.optionals)return W(Ul);e.defaultables=H(e.defaultables,[[t,n]]);return e};const Ll=(e,t)=>{if(e.postfix)W(Bl);if(e.variadic){if(!e.variadic.equals(t))W(Bl)}else e.variadic=t.internal;return e};const Rl=(e,t)=>{const n=t.select({method:`find`,kind:`sequence`});if(!n)return Ll(e,C.intrinsic.unknown);if(n.prefix)for(const t of n.prefix)Pl(e,t);if(n.optionals)for(const t of n.optionals)Fl(e,t);if(n.variadic)Ll(e,n.variadic);if(n.postfix)for(const t of n.postfix)Pl(e,t);return e};const zl=e=>`Spread element must be an array (was ${e})`;const Bl=`A tuple may have at most one variadic element`;const Vl=`A required element may not follow an optional element`;const Hl=`An optional element may not follow a variadic element`;const Ul=`A defaultable element may not follow an optional element without a default`;const Wl={};const Gl=(e,t)=>{if(typeof e===`string`){if(t.args&&Object.keys(t.args).some(t=>e.includes(t)))return qc(e,t);const n=Wl[t.$.name]??={};return n[e]??=qc(e,t)}return mo(e,`object`)?Kl(e,t):W(Jl(U(e)))};const Kl=(e,t)=>{const n=Po(e);switch(n){case void 0:if(E(e,`root`))return e;return ul(e,t);case`Array`:return ql(e,t);case`RegExp`:return t.$.node(`intersection`,{domain:`string`,pattern:e},{prereduced:true});case`Function`:{const t=Uo(e)?e():e;if(E(t,`root`))return t;return W(Jl(`Function`))}default:return W(Jl(n??Rs(e)))}};const ql=(e,t)=>gl(e,t)??Nl(e,t);const Jl=e=>`Type definitions must be strings or objects (was ${e})`;var Yl=class extends Wo{constructor(e){const t=Object.assign({errors:sn,hkt:G,$:e,raw:e.parse,module:e.constructor.module,scope:e.constructor.scope,define:e.define,match:e.match,generic:e.generic,schema:e.schema,keywords:e.ambient,unit:e.unit,enumerated:e.enumerated,instanceOf:e.instanceOf,valueOf:e.valueOf,or:e.or,and:e.and,merge:e.merge,pipe:e.pipe},e.ambientAttachments);super((...t)=>{if(t.length===1)return e.parse(t[0]);if(t.length===2&&typeof t[0]===`string`&&t[0][0]===`<`&&t[0].at(-1)===`>`){const n=t[0].slice(1,-1);const r=e.parseGenericParams(n,{});return new Rn(r,t[1],e,e,null)}return e.parse(t)},{bind:e,attach:t})}};const Xl=C;var Zl=class e extends qa{get ambientAttachments(){if(!Xl.typeAttachments)return;return this.cacheGetter(`ambientAttachments`,So(Xl.typeAttachments,(e,t)=>[e,this.bindReference(t)]))}preparseOwnAliasEntry(e,t){const n=e.indexOf(`<`);if(n===-1){if(E(t,`module`)||E(t,`generic`))return[e,t];const n=this.name===`ark`?e:e===`root`?this.name:`${this.name}.${e}`;const r=this.resolvedConfig.keywords?.[n];if(r)t=[t,`@`,r];return[e,t]}if(e.at(-1)!==`>`)W(`'>' must be the last character of a generic declaration in a scope`);const r=e.slice(0,n);const i=e.slice(n+1,-1);return[r,()=>{const e=this.parseGenericParams(i,{alias:r});const n=In(e,t,this);return n}]}parseGenericParams(e,t){return $c(new jc(e),[],this.createParseContext({...t,def:e,prefix:`generic`}))}normalizeRootScopeValue(e){if(Uo(e)&&!E(e,`generic`))return e();return e}preparseOwnDefinitionFormat(e,t){return{...t,def:e,prefix:t.alias??`type`}}parseOwnDefinitionFormat(e,t){const n=t.alias&&t.alias in this.aliases;if(!n&&!t.args)t.args={this:t.id};const r=Gl(e,t);if(Io(r)){if(r[1]===`=`)return W(uc);if(r[1]===`?`)return W(lc)}return r}unit=e=>this.units([e]);valueOf=e=>this.units(Oo(e));enumerated=(...e)=>this.units(e);instanceOf=e=>this.node(`proto`,{proto:e},{prereduced:true});or=(...e)=>this.schema(e.map(e=>this.parse(e)));and=(...e)=>e.reduce((e,t)=>e.and(this.parse(t)),this.intrinsic.unknown);merge=(...e)=>e.reduce((e,t)=>e.merge(this.parse(t)),this.intrinsic.object);pipe=(...e)=>this.intrinsic.unknown.pipe(...e);match=new nl(this);declare=()=>({type:this.type});define(e){return e}type=new Yl(this);static scope=((t,n={})=>new e(t,n));static module=((e,t={})=>this.scope(e,t).export())};const Ql=Object.assign(Zl.scope,{define:e=>e});const J=Zl;var $l=class extends G{description='merge an object\'s properties onto another like `Merge(User, { isAdmin: "true" })`'};const eu=B([`base`,V.object],[`props`,V.object])(e=>e.base.merge(e.props),$l);const tu=J.module({Key:V.key,Merge:eu});var nu=class extends G{};const ru=B(`element`)(e=>{const t=e.element.exclude(V.Array);const n=t.array();return t.rawOr(n).pipe(po).distribute(e=>e.assertHasKind(`morph`).declareOut(n),z)},nu);const iu=J.module({root:V.Array,readonly:`root`,index:V.nonNegativeIntegerString,liftFrom:ru},{name:`Array`});const au=z([`string`,js.FileConstructor]);const ou=au.rawOr(au.array());const su=z({meta:`an object representing parsed form data`,domain:`object`,index:{signature:`string`,value:ou}});const cu=J.module({root:[`instanceof`,FormData],value:au,parsed:su,parse:z({in:FormData,morphs:e=>{const t={};for(const[n,r]of e)if(n in t){const e=t[n];if(typeof e===`string`||e instanceof js.FileConstructor)t[n]=[e,r];else e.push(r)}else t[n]=r;return t},declaredOut:su})},{name:`FormData`});const lu=J.module({Int8:[`instanceof`,Int8Array],Uint8:[`instanceof`,Uint8Array],Uint8Clamped:[`instanceof`,Uint8ClampedArray],Int16:[`instanceof`,Int16Array],Uint16:[`instanceof`,Uint16Array],Int32:[`instanceof`,Int32Array],Uint32:[`instanceof`,Uint32Array],Float32:[`instanceof`,Float32Array],Float64:[`instanceof`,Float64Array],BigInt64:[`instanceof`,BigInt64Array],BigUint64:[`instanceof`,BigUint64Array]},{name:`TypedArray`});const uu={Boolean:1,Number:1,String:1};const du=J.module({...So({...ko,...jo},(e,t)=>e in uu?[]:[e,[`instanceof`,t]]),Array:iu,TypedArray:lu,FormData:cu});const fu=z({domain:{domain:`number`,meta:`a number representing a Unix timestamp`},divisor:{rule:1,meta:`an integer representing a Unix timestamp`},min:{rule:-864e13,meta:`a Unix timestamp after -8640000000000000`},max:{rule:864e13,meta:`a Unix timestamp before 8640000000000000`},meta:`an integer representing a safe Unix timestamp`});const pu=z({domain:`number`,divisor:1});const mu=J.module({root:V.number,integer:pu,epoch:fu,safe:z({domain:{domain:`number`,numberAllowsNaN:false},min:Number.MIN_SAFE_INTEGER,max:Number.MAX_SAFE_INTEGER}),NaN:[`===`,NaN],Infinity:[`===`,Number.POSITIVE_INFINITY],NegativeInfinity:[`===`,Number.NEGATIVE_INFINITY]},{name:`number`});const Y=(e,t,n)=>{const r={domain:`string`,pattern:{rule:e.source,flags:e.flags,meta:t}};if(n)r.meta={format:n};return io(`intersection`,r)};const hu=Y(hs,`a well-formed integer string`);const gu=J.module({root:hu,parse:z({in:hu,morphs:(e,t)=>{const n=Number.parseInt(e);return Number.isSafeInteger(n)?n:t.error(`an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER`)},declaredOut:V.integer})},{name:`string.integer`});const _u=Y(/^[\dA-Fa-f]+$/,`hex characters only`);const vu=J.module({root:Y(/^(?:[\d+/A-Za-z]{4})*(?:[\d+/A-Za-z]{2}==|[\d+/A-Za-z]{3}=)?$/,`base64-encoded`),url:Y(/^(?:[\w-]{4})*(?:[\w-]{2}(?:==|%3D%3D)?|[\w-]{3}(?:=|%3D)?)?$/,`base64url-encoded`)},{name:`string.base64`});const yu=Y(/^[A-Z].*$/,`capitalized`);const bu=J.module({root:z({in:`string`,morphs:e=>e.charAt(0).toUpperCase()+e.slice(1),declaredOut:yu}),preformatted:yu},{name:`string.capitalize`});const xu=e=>{const t=e.replaceAll(/[ -]+/g,``);let n=0;let r;let i;let a=false;for(let e=t.length-1;e>=0;e--){r=t.substring(e,e+1);i=Number.parseInt(r,10);if(a){i*=2;n+=i>=10?i%10+1:i}else n+=i;a=!a}return!!(n%10===0?t:false)};const Su=/^(?:4\d{12}(?:\d{3,6})?|5[1-5]\d{14}|(222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}|6(?:011|5\d\d)\d{12,15}|3[47]\d{13}|3(?:0[0-5]|[68]\d)\d{11}|(?:2131|1800|35\d{3})\d{11}|6[27]\d{14}|^(81\d{14,17}))$/;const Cu=z({domain:`string`,pattern:{meta:`a credit card number`,rule:Su.source},predicate:{meta:`a credit card number`,predicate:xu}});const wu=/^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))(T((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([,.]\d+(?!:))?)?(\17[0-5]\d([,.]\d+)?)?([Zz]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;const Tu=e=>!Number.isNaN(new Date(e).valueOf());const Eu=z({domain:`string`,predicate:{meta:`a parsable date`,predicate:Tu}}).assertHasKind(`intersection`);const Du=gu.root.internal.narrow((e,t)=>{const n=Number.parseInt(e);const r=mu.epoch(n);if(r instanceof sn){t.errors.merge(r);return false}return true}).configure({description:`an integer string representing a safe Unix timestamp`},`self`).assertHasKind(`intersection`);const Ou=J.module({root:Du,parse:z({in:Du,morphs:e=>new Date(e),declaredOut:V.Date})},{name:`string.date.epoch`});const ku=Y(wu,`an ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) date`).internal.assertHasKind(`intersection`);const Au=J.module({root:ku,parse:z({in:ku,morphs:e=>new Date(e),declaredOut:V.Date})},{name:`string.date.iso`});const ju=J.module({root:Eu,parse:z({declaredIn:Eu,in:`string`,morphs:(e,t)=>{const n=new Date(e);if(Number.isNaN(n.valueOf()))return t.error(`a parsable date`);return n},declaredOut:V.Date}),iso:Au,epoch:Ou},{name:`string.date`});const Mu=Y(/^[\w%+.-]+@[\d.A-Za-z-]+\.[A-Za-z]{2,}$/,`an email address`,`email`);const Nu=`(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])`;const X=`(${Nu}[.]){3}${Nu}`;const Pu=new RegExp(`^${X}$`);const Z=`(?:[0-9a-fA-F]{1,4})`;const Fu=new RegExp(`^((?:${Z}:){7}(?:${Z}|:)|(?:${Z}:){6}(?:${X}|:${Z}|:)|(?:${Z}:){5}(?::${X}|(:${Z}){1,2}|:)|(?:${Z}:){4}(?:(:${Z}){0,1}:${X}|(:${Z}){1,3}|:)|(?:${Z}:){3}(?:(:${Z}){0,2}:${X}|(:${Z}){1,4}|:)|(?:${Z}:){2}(?:(:${Z}){0,3}:${X}|(:${Z}){1,5}|:)|(?:${Z}:){1}(?:(:${Z}){0,4}:${X}|(:${Z}){1,6}|:)|(?::((?::${Z}){0,5}:${X}|(?::${Z}){1,7}|:)))(%[0-9a-zA-Z.]{1,})?\$`);const Iu=J.module({root:[`v4 | v6`,`@`,`an IP address`],v4:Y(Pu,`an IPv4 address`,`ipv4`),v6:Y(Fu,`an IPv6 address`,`ipv6`)},{name:`string.ip`});const Lu=`a JSON string`;const Ru=e=>{if(!(e instanceof SyntaxError))throw e;return`must be ${Lu} (${e})`};const zu=z({meta:Lu,domain:`string`,predicate:{meta:Lu,predicate:(e,t)=>{try{JSON.parse(e);return true}catch(e){return t.reject({code:`predicate`,expected:Lu,problem:Ru(e)})}}}});const Bu=(e,t)=>{if(e.length===0)return t.error({code:`predicate`,expected:Lu,actual:`empty`});try{return JSON.parse(e)}catch(e){return t.error({code:`predicate`,expected:Lu,problem:Ru(e)})}};const Vu=J.module({root:zu,parse:z({meta:`safe JSON string parser`,in:`string`,morphs:Bu,declaredOut:V.jsonObject})},{name:`string.json`});const Hu=Y(/^[a-z]*$/,`only lowercase letters`);const Uu=J.module({root:z({in:`string`,morphs:e=>e.toLowerCase(),declaredOut:Hu}),preformatted:Hu},{name:`string.lower`});const Wu=[`NFC`,`NFD`,`NFKC`,`NFKD`];const Gu=So(Wu,(e,t)=>[t,z({domain:`string`,predicate:e=>e.normalize(t)===e,meta:`${t}-normalized unicode`})]);const Ku=So(Wu,(e,t)=>[t,z({in:`string`,morphs:e=>e.normalize(t),declaredOut:Gu[t]})]);const qu=J.module({root:Ku.NFC,preformatted:Gu.NFC},{name:`string.normalize.NFC`});const Ju=J.module({root:Ku.NFD,preformatted:Gu.NFD},{name:`string.normalize.NFD`});const Yu=J.module({root:Ku.NFKC,preformatted:Gu.NFKC},{name:`string.normalize.NFKC`});const Xu=J.module({root:Ku.NFKD,preformatted:Gu.NFKD},{name:`string.normalize.NFKD`});const Zu=J.module({root:`NFC`,NFC:qu,NFD:Ju,NFKC:Yu,NFKD:Xu},{name:`string.normalize`});const Qu=Y(ds,`a well-formed numeric string`);const $u=J.module({root:Qu,parse:z({in:Qu,morphs:e=>Number.parseFloat(e),declaredOut:V.number})},{name:`string.numeric`});const ed=`a regex pattern`;const td=z({domain:`string`,predicate:{meta:ed,predicate:(e,t)=>{try{new RegExp(e);return true}catch(e){return t.reject({code:`predicate`,expected:ed,problem:String(e)})}}},meta:{format:`regex`}});const nd=/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*)(?:\.(?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*))*))?(?:\+([\dA-Za-z-]+(?:\.[\dA-Za-z-]+)*))?$/;const rd=Y(nd,`a semantic version (see https://semver.org/)`);const id=Y(/^\S.*\S$|^\S?$/,`trimmed`);const ad=J.module({root:z({in:`string`,morphs:e=>e.trim(),declaredOut:id}),preformatted:id},{name:`string.trim`});const od=Y(/^[A-Z]*$/,`only uppercase letters`);const sd=J.module({root:z({in:`string`,morphs:e=>e.toUpperCase(),declaredOut:od}),preformatted:od},{name:`string.upper`});const cd=e=>{if(URL.canParse)return URL.canParse(e);try{new URL(e);return true}catch{return false}};const ld=z({domain:`string`,predicate:{meta:`a URL string`,predicate:cd},meta:{format:`uri`}});const ud=J.module({root:ld,parse:z({declaredIn:ld,in:`string`,morphs:(e,t)=>{try{return new URL(e)}catch{return t.error(`a URL string`)}},declaredOut:z(URL)})},{name:`string.url`});const dd=J.module({root:[`versioned | nil | max`,`@`,{description:`a UUID`,format:`uuid`}],"#nil":`'00000000-0000-0000-0000-000000000000'`,"#max":`'ffffffff-ffff-ffff-ffff-ffffffffffff'`,"#versioned":/[\da-f]{8}-[\da-f]{4}-[1-8][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}/i,v1:Y(/^[\da-f]{8}-[\da-f]{4}-1[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv1`),v2:Y(/^[\da-f]{8}-[\da-f]{4}-2[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv2`),v3:Y(/^[\da-f]{8}-[\da-f]{4}-3[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv3`),v4:Y(/^[\da-f]{8}-[\da-f]{4}-4[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv4`),v5:Y(/^[\da-f]{8}-[\da-f]{4}-5[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv5`),v6:Y(/^[\da-f]{8}-[\da-f]{4}-6[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv6`),v7:Y(/^[\da-f]{8}-[\da-f]{4}-7[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv7`),v8:Y(/^[\da-f]{8}-[\da-f]{4}-8[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,`a UUIDv8`)},{name:`string.uuid`});const fd=J.module({root:V.string,alpha:Y(/^[A-Za-z]*$/,`only letters`),alphanumeric:Y(/^[\dA-Za-z]*$/,`only letters and digits 0-9`),hex:_u,base64:vu,capitalize:bu,creditCard:Cu,date:ju,digits:Y(/^\d*$/,`only digits 0-9`),email:Mu,integer:gu,ip:Iu,json:Vu,lower:Uu,normalize:Zu,numeric:$u,regex:td,semver:rd,trim:ad,upper:sd,url:ud,uuid:dd},{name:`string`});const pd=J.module({bigint:V.bigint,boolean:V.boolean,false:V.false,never:V.never,null:V.null,number:V.number,object:V.object,string:V.string,symbol:V.symbol,true:V.true,unknown:V.unknown,undefined:V.undefined});const md=J.module({root:V.unknown,any:V.unknown},{name:`unknown`});const hd=J.module({root:V.jsonObject,stringify:io(`morph`,{in:V.jsonObject,morphs:e=>JSON.stringify(e),declaredOut:V.string})},{name:`object.json`});const gd=J.module({root:V.object,json:hd},{name:`object`});var _d=class extends G{description='instantiate an object from an index signature and corresponding value type like `Record("string", "number")`'};const vd=B([`K`,V.key],`V`)(e=>({domain:`object`,index:{signature:e.K,value:e.V}}),_d);var yd=class extends G{description='pick a set of properties from an object like `Pick(User, "name | age")`'};const bd=B([`T`,V.object],[`K`,V.key])(e=>e.T.pick(e.K),yd);var xd=class extends G{description='omit a set of properties from an object like `Omit(User, "age")`'};const Sd=B([`T`,V.object],[`K`,V.key])(e=>e.T.omit(e.K),xd);var Cd=class extends G{description="make all named properties of an object optional like `Partial(User)`"};const wd=B([`T`,V.object])(e=>e.T.partial(),Cd);var Td=class extends G{description="make all named properties of an object required like `Required(User)`"};const Ed=B([`T`,V.object])(e=>e.T.required(),Td);var Dd=class extends G{description='exclude branches of a union like `Exclude("boolean", "true")`'};const Od=B(`T`,`U`)(e=>e.T.exclude(e.U),Dd);var kd=class extends G{description='extract branches of a union like `Extract("0 | false | 1", "number")`'};const Ad=B(`T`,`U`)(e=>e.T.extract(e.U),kd);const jd=J.module({Exclude:Od,Extract:Ad,Omit:Sd,Partial:wd,Pick:bd,Record:vd,Required:Ed});const Q=Ql({...pd,...jd,...du,...tu,string:fd,number:mu,object:gd,unknown:md},{prereducedAliases:true,name:`ark`});const $=Q.export();Object.assign(Xl.ambient,$);Xl.typeAttachments={string:$.string.root,number:$.number.root,bigint:$.bigint,boolean:$.boolean,symbol:$.symbol,undefined:$.undefined,null:$.null,object:$.object.root,unknown:$.unknown.root,false:$.false,true:$.true,never:$.never,arrayIndex:$.Array.index,Key:$.Key,Record:$.Record,Array:$.Array.root,Date:$.Date};const Md=Object.assign(Q.type,Xl.typeAttachments);const Nd=Q.match;const Pd=Q.generic;const Fd=Q.schema;const Id=Q.define;const Ld=Q.declare;var Rd=Md({number:`number`,negNumber:`number`,maxNumber:`number`,string:`string`,longString:`string`,boolean:`boolean`,deeplyNested:{foo:`string`,num:`number`,bool:`boolean`},items:`number[]`});export{Rd as default};